CCS PCH C Compiler, Version 3.167, 19491

               Filename: Main.LST

               ROM used: 15046 (92%)
                         Largest free fragment is 1334
               RAM used: 528 (69%) at main() level
                         657 (86%) worst case
               Stack:    10 worst case (6 in main + 4 for interrupts)

*
0000:  GOTO   38C0
*
0008:  MOVWF  05
000A:  MOVFF  FD8,06
000E:  MOVF   FE9,W
0010:  MOVWF  07
0012:  MOVF   FEA,W
0014:  MOVWF  08
0016:  MOVF   FE1,W
0018:  MOVWF  09
001A:  MOVF   FE2,W
001C:  MOVWF  0A
001E:  MOVF   FD9,W
0020:  MOVWF  0B
0022:  MOVF   FDA,W
0024:  MOVWF  0C
0026:  MOVF   FE0,W
0028:  MOVWF  0D
002A:  MOVLB  0
002C:  MOVF   00,W
002E:  MOVWF  0F
0030:  MOVF   01,W
0032:  MOVWF  10
0034:  MOVF   02,W
0036:  MOVWF  11
0038:  MOVF   03,W
003A:  MOVWF  12
003C:  MOVF   04,W
003E:  MOVWF  13
0040:  BTFSS  F9D.5
0042:  GOTO   004C
0046:  BTFSC  F9E.5
0048:  GOTO   00C4
004C:  BTFSS  FA3.7
004E:  GOTO   0058
0052:  BTFSC  FA4.7
0054:  GOTO   0194
0058:  BTFSS  FA3.5
005A:  GOTO   0064
005E:  BTFSC  FA4.5
0060:  GOTO   0132
0064:  BTFSS  FA3.1
0066:  GOTO   0070
006A:  BTFSC  FA4.1
006C:  GOTO   07C8
0070:  BTFSS  FA3.0
0072:  GOTO   007C
0076:  BTFSC  FA4.0
0078:  GOTO   07D2
007C:  MOVF   0F,W
007E:  MOVWF  00
0080:  MOVF   10,W
0082:  MOVWF  01
0084:  MOVF   11,W
0086:  MOVWF  02
0088:  MOVF   12,W
008A:  MOVWF  03
008C:  MOVF   13,W
008E:  MOVWF  04
0090:  MOVF   0D,W
0092:  MOVWF  FE0
0094:  BSF    0D.7
0096:  MOVF   07,W
0098:  MOVWF  FE9
009A:  MOVF   08,W
009C:  MOVWF  FEA
009E:  MOVF   09,W
00A0:  MOVWF  FE1
00A2:  MOVF   0A,W
00A4:  MOVWF  FE2
00A6:  MOVF   0B,W
00A8:  MOVWF  FD9
00AA:  MOVF   0C,W
00AC:  MOVWF  FDA
00AE:  MOVF   05,W
00B0:  MOVFF  06,FD8
00B4:  RETFIE 0
....................  //------------------------------------------------------------------------------  
.................... // File: Main  
.................... //  
.................... // Purpose: Main module and C entry point main().  
.................... //  
.................... //  Notes:   
.................... //  Software UART in CCS compiler does not implement a stop bit. Therefore  
.................... //  you must timeout a stopbit after a putc call. delay_us(500) has worked.   
.................... //  
.................... //  TODO:   
.................... //  1) Make an ISO command that doesn't wait 5mS per char for faster sampling.   
.................... //  2) Check all TBDs  
.................... //  3) Check that all commands and errors are used/handled.  
.................... //  4) Create a security function and message using encryption.  
.................... //  5) VW Pass through mode does no bus message filtering??Or maybe just no init?? 
.................... //  6) PWM needs to send an IFR.  
.................... //  
.................... // Change History:  
.................... // Date		Author		Description  
.................... //          Lafreniere	Created  
.................... //  
.................... // August 12, 2003 - Updated for compatibility with the PIC18F248, for CAN version of product  
.................... // Feburary 26, 2005 - Update to add the B0 adapter unlock command  
.................... // August 3, 2007 - Update to add DashDyno code, host UART speed increase and EERPOM commands.  
.................... // November, 22, 2008 - Updated to add support for Toyota enhanced KWP 9600 mode.  
.................... //------------------------------------------------------------------------------  
.................... #case       	// make compiler case sensitive  
....................   
.................... // define to enable debug code  
.................... //#define DEBUG   1     
....................   
.................... // define to compile for DashDyno  
.................... #define DASH_DYNO  
.................... #define BLUETOOTH  
....................   
.................... #include <18F248.h> 
....................  //////// Standard Header file for the PIC18F248 device ////////////////  
.................... #device PIC18F248  
.................... #list  
....................  
.................... #device ADC=10  // setup A/D for 10 bits  
....................   
.................... #include "a_18F248.h" 
....................  #ifndef _18F248_H  
.................... #define _18F248_H  
....................   
.................... #LIST  
....................   
.................... #endif  
....................  
.................... #include "hardware.h" 
.................... #LIST	  
....................  
.................... #include "Const.h" 
....................  //------------------------------------------------------------------------------  
.................... // File: Const  
.................... //  
.................... // Purpose: Project constants.  
.................... //  
.................... // Change History:  
.................... // Date		Author		Description  
.................... //          Lafreniere	Created  
.................... //------------------------------------------------------------------------------  
.................... #ifndef CONST_H  
.................... #define CONST_H  
....................   
.................... #ifdef DEBUG  
....................     #define TRACE(char) Trace(char);  
.................... #else  
....................     #define TRACE(char)   
.................... #endif  
....................   
.................... // software revision  
.................... #define SOFTWARE_REV            0x08  
....................   
.................... #define MAX_ECU				8 	// per ISO 15675-4 7.3.3. max ECUs is 8  
....................   
.................... #define DEVID1_ADDR 0x3FFFFEL  
.................... #define DEVID2_ADDR 0x3FFFFFL   
....................   
.................... // The old 18F248 and the new 18F2480 have some differences, mostly in the analog  
.................... // to digital converter. Using _DEVID2 check the processor version.   
.................... #define VER_18F248				0x08  
.................... //#define VER_18F2480 					  
....................   
.................... // destination address  
.................... #define DESTINATION_ADDR        0x2d  
....................   
.................... // from host msg byte positions  
.................... #define IDX_HOST_DESTINATION        0  
.................... #define IDX_HOST_COMMAND            1  
.................... #define IDX_HOST_BYTE_COUNT         2  
.................... #define IDX_HOST_START_DATA         3  
.................... #define IDX_HOST_CHECKSUM           14  
....................   
.................... // to host msg byte positions  
.................... #define IDX_VEHICLE_DESTINATION     0  
.................... #define IDX_VEHICLE_COMMAND         1  
.................... #define IDX_VEHICLE_CHECKSUM        13  
....................   
.................... // max size of all messages  
.................... #define HOST_RECV_MSG_SIZE          15      // from host size including all non-OBD II bytes  
.................... #define HOST_SEND_MSG_SIZE          14      // to host size  
.................... #define VEHICLE_MSG_SIZE            12      // to/from max vehicle size, not as sent to host (RSP byte not included)   
.................... #define VEHICLE_MAX_MSGS            32      // number of VEHICLE_MSG_SIZE we can store in RAM  
....................   
.................... // error codes returned to host  
.................... #define ERR_NONE                        0x00   // ERR_NONE must be 0!  
.................... #define ERR_NOT_IMPLEMENTED             0x01  
.................... #define ERR_BAD_CHECKSUM                0x02  
.................... #define ERR_ISO_NO_SYNC                 0x03  
.................... #define ERR_ISO_INCORRECT_INV_ADDR      0x04  
.................... #define ERR_ISO_NO_RESPONSE             0x05  
.................... #define ERR_J1850_NO_RESPONSE           0x07  
.................... #define ERR_ISO_BAD_CHECKSUM            0x08  
.................... #define ERR_J1850_BAD_CRC               0x09      
.................... #define ERR_KWP_BAUD_TOO_SLOW           0x0b    // not used  
.................... #define ERR_KWP_NO_RESPONSE             0x0c    // not used  
.................... #define ERR_KWP_INCORRECT_SYNC          0x0d    // not used  
.................... #define ERR_ISO_NOT_ENABLED             0x10    // not used  
.................... #define ERR_J1850_VPW_NOT_ENABLED       0x11    // not used  
.................... #define ERR_J1850_PWM_NOT_ENABLED       0x12    // not used  
.................... #define ERR_KWP_NOT_ENABLED             0x13    // not used  
.................... #define ERR_VW_PASS_THRU_NOT_ENABLED    0x14    // not used  
.................... #define ERR_CAN_NO_RESPONSE             0x15	// COMSTAT CAN register returned as extra data  
.................... #define ERR_CAN_RX_OVERFLOW             0x16  
.................... #define ERR_CAN_TX_BUFFER_UNAVAIL       0x18  
.................... #define ERR_CAN_RX_MESSAGE_LEN_WRONG    0x19  
.................... #define ERR_CAN_ERROR_INTERRUPT			0x1A	// COMSTAT CAN register returned as extra data  
.................... #define ERR_CAN_INVALID_MSG_INTERRUPT   0x1B    // TXBnCON CAN register returned as extra data 1, 2 and 3  
.................... #define ERR_ISO_INV_ADDR_NOT_RECEIVED	0x1F  
.................... #define ERR_ISO_SYNC_BYTE_NOT_RECEIVED	0x20  
....................   
.................... #define ERR_WRONG_DESTINATION           0x80      
.................... #define ERR_BYTE_COUNT_TOO_LARGE        0x81  
.................... #define ERR_J1850_FRAMING_ERROR         0x82  
.................... #define ERR_J1850_MSG_OVERFLOW          0x83   
.................... #define ERR_ISO_NO_KEYBYTE              0x84  
.................... #define ERR_ADAPTER_LOCKED              0x85  
.................... #define ERR_INVALID_NON_VOLATILE_SECTOR 0x86  
.................... #define ERR_NON_VOLATILE_SECTOR_LOCKED  0x87  
....................   
.................... // host-to-adapter commands  
.................... #define CMD_ISO_WITH_5_BAUD             0x01  
.................... #define CMD_VPW                         0x02  
.................... #define CMD_PWM                         0x04  
.................... #define CMD_CAN_SI_250KB                0x08      
.................... #define CMD_ISO                         0x10  
.................... #define CMD_VW_PASS_THRU_WITH_5_BAUD    0x20    // not used  
.................... #define CMD_VW_PASS_THRU_WITHOUT_5_BAUD 0x40    // not used  
.................... #define CMD_PWM_WITH_IFR                0x80  
.................... #define CMD_ISO_1ST_RESPONSE            0x81  
.................... #define CMD_VPW_1ST_RESPONSE            0x82  
.................... #define CMD_ATOD_CONVERSION             0x83    // not used  
.................... #define CMD_PWM_1ST_RESPONSE            0x84  
.................... #define CMD_KWP_WITH_5_BAUD             0x85  
.................... #define CMD_KWP_REPORT_KW1_KW2          0x86    // not used  
.................... #define CMD_KWP_FAST_INIT               0x87  
.................... #define CMD_KWP                         0x88  
.................... #define CMD_KWP_1ST_RESPONSE            0x89  
.................... #define CMD_CAN_SI_500KB                0x90  
.................... #define CMD_CAN_EI_250KB                0x91  
.................... #define CMD_CAN_EI_500KB                0x92  
.................... #define CMD_CAN_SI_250KB_1ST            0x93  
.................... #define CMD_CAN_SI_500KB_1ST            0x94  
.................... #define CMD_CAN_EI_250KB_1ST            0x95  
.................... #define CMD_CAN_EI_500KB_1ST            0x96  
.................... #define CMD_CAN_SET_STD_MASK_FILTER		0x97  
.................... #define CMD_CAN_SET_XTD_MASK_FILTER		0x98  
.................... #define CMD_CAN_SET_P2_CAN_TIMEOUT		0x99  
.................... #define CMD_CAN_SI_250KB_FBGO			0x9A	// FBGO = fast bus get off  
.................... #define CMD_CAN_SI_500KB_FBGO			0x9B	// FBGO = fast bus get off  
.................... #define CMD_CAN_EI_250KB_FBGO			0x9C	// FBGO = fast bus get off  
.................... #define CMD_CAN_EI_500KB_FBGO			0x9D	// FBGO = fast bus get off  
.................... #define CMD_CAN_SI_250KB_LISTEN			0x9E	  
.................... #define CMD_CAN_SI_500KB_LISTEN			0x9F	  
.................... #define CMD_CAN_EI_250KB_LISTEN			0xA0	  
.................... #define CMD_CAN_EI_500KB_LISTEN			0xA1  
.................... #define CMD_CAN_SI_250KB_NO_RESPONSE	0xA2	  
.................... #define CMD_CAN_SI_500KB_NO_RESPONSE	0xA3	  
.................... #define CMD_CAN_EI_250KB_NO_RESPONSE	0xA4	  
.................... #define CMD_CAN_EI_500KB_NO_RESPONSE	0xA5  
.................... #define CMD_ISO_NO_RESPONSE				0xA6  
.................... #define CMD_ISO_ENABLE_L_LINE_XMIT		0xA9  
.................... #define CMD_ISO_SET_9600_BAUD			0xAB  
.................... #define CMD_ISO_CHECKSUM_ENABLE			0xAC  
.................... #define CMD_ISO_5MS_BYTE_DELAY_ENABLE	0xAD  
.................... #define CMD_UNLOCK_ADAPTER              0xB0	  
.................... #define CMD_READ_EEPROM					0xB9  
.................... #define CMD_WRITE_EEPROM				0xBA  
.................... #define CMD_KWP_FAST_INIT_9600			0xC4  
.................... #define CMD_READ_BATTERY_VOLTAGE		0xF0  
....................   
.................... // adapter-to-host commands  
.................... #define CMD_ERROR                       0x80  
.................... #define CMD_ISO_MSG                     0x81  
.................... #define CMD_VPW_MSG                     0x82  
.................... #define CMD_PWM_MSG                     0x84  
.................... #define CMD_CAN_MSG                     0x88  
.................... #define CMD_KWP_MSG                     0x01  
.................... #define CMD_LOCAL_DATA					0x40  
....................   
.................... // transmit modes (must fit in 3-bits!)  
.................... #define MODE_ISO                 0x00  
.................... #define MODE_VPW                 0x01  
.................... #define MODE_PWM                 0x02  
.................... #define MODE_KWP                 0x03  
.................... #define MODE_CAN                 0x04  
....................   
.................... // interface capabilites (i.e. what com modes does the adapter support)  
.................... #define CAP_ISO         0x01  
.................... #define CAP_VPW         0x02  
.................... #define CAP_PWM         0x04  
.................... #define CAP_KWP         0x08  
.................... #define CAP_CAN         0x10  
.................... #define CAP_DUAL_CAN	0x20  
.................... #define DASH_DYNO_VER	0x40  
.................... #ifdef DASH_DYNO  
.................... #define CAP_INTERFACE   (CAP_ISO | CAP_VPW | CAP_PWM | CAP_KWP | CAP_CAN | DASH_DYNO_VER)  
.................... #else  
.................... #define CAP_INTERFACE   (CAP_ISO | CAP_VPW | CAP_PWM | CAP_KWP | CAP_CAN)  
.................... #endif  
....................   
.................... #endif   
....................  
.................... #include "Globals.h" 
....................  //------------------------------------------------------------------------------  
.................... // File: Globals  
.................... //  
.................... // Purpose: Project global variables.  
.................... //  
.................... // Change History:  
.................... // Date		Author		Description  
.................... //          Lafreniere	Created  
.................... //------------------------------------------------------------------------------  
.................... #ifndef GLOBALS_H  
.................... #define GLOBALS_H  
....................   
.................... #include "Const.h" 
....................  //------------------------------------------------------------------------------  
.................... // File: Const  
.................... //  
.................... // Purpose: Project constants.  
.................... //  
.................... // Change History:  
.................... // Date		Author		Description  
.................... //          Lafreniere	Created  
.................... //------------------------------------------------------------------------------  
.................... #ifndef CONST_H  
.................... #define CONST_H  
....................   
.................... #ifdef DEBUG  
....................     #define TRACE(char) Trace(char);  
.................... #else  
....................     #define TRACE(char)   
.................... #endif  
....................   
.................... // software revision  
.................... #define SOFTWARE_REV            0x08  
....................   
.................... #define MAX_ECU				8 	// per ISO 15675-4 7.3.3. max ECUs is 8  
....................   
.................... #define DEVID1_ADDR 0x3FFFFEL  
.................... #define DEVID2_ADDR 0x3FFFFFL   
....................   
.................... // The old 18F248 and the new 18F2480 have some differences, mostly in the analog  
.................... // to digital converter. Using _DEVID2 check the processor version.   
.................... #define VER_18F248				0x08  
.................... //#define VER_18F2480 					  
....................   
.................... // destination address  
.................... #define DESTINATION_ADDR        0x2d  
....................   
.................... // from host msg byte positions  
.................... #define IDX_HOST_DESTINATION        0  
.................... #define IDX_HOST_COMMAND            1  
.................... #define IDX_HOST_BYTE_COUNT         2  
.................... #define IDX_HOST_START_DATA         3  
.................... #define IDX_HOST_CHECKSUM           14  
....................   
.................... // to host msg byte positions  
.................... #define IDX_VEHICLE_DESTINATION     0  
.................... #define IDX_VEHICLE_COMMAND         1  
.................... #define IDX_VEHICLE_CHECKSUM        13  
....................   
.................... // max size of all messages  
.................... #define HOST_RECV_MSG_SIZE          15      // from host size including all non-OBD II bytes  
.................... #define HOST_SEND_MSG_SIZE          14      // to host size  
.................... #define VEHICLE_MSG_SIZE            12      // to/from max vehicle size, not as sent to host (RSP byte not included)   
.................... #define VEHICLE_MAX_MSGS            32      // number of VEHICLE_MSG_SIZE we can store in RAM  
....................   
.................... // error codes returned to host  
.................... #define ERR_NONE                        0x00   // ERR_NONE must be 0!  
.................... #define ERR_NOT_IMPLEMENTED             0x01  
.................... #define ERR_BAD_CHECKSUM                0x02  
.................... #define ERR_ISO_NO_SYNC                 0x03  
.................... #define ERR_ISO_INCORRECT_INV_ADDR      0x04  
.................... #define ERR_ISO_NO_RESPONSE             0x05  
.................... #define ERR_J1850_NO_RESPONSE           0x07  
.................... #define ERR_ISO_BAD_CHECKSUM            0x08  
.................... #define ERR_J1850_BAD_CRC               0x09      
.................... #define ERR_KWP_BAUD_TOO_SLOW           0x0b    // not used  
.................... #define ERR_KWP_NO_RESPONSE             0x0c    // not used  
.................... #define ERR_KWP_INCORRECT_SYNC          0x0d    // not used  
.................... #define ERR_ISO_NOT_ENABLED             0x10    // not used  
.................... #define ERR_J1850_VPW_NOT_ENABLED       0x11    // not used  
.................... #define ERR_J1850_PWM_NOT_ENABLED       0x12    // not used  
.................... #define ERR_KWP_NOT_ENABLED             0x13    // not used  
.................... #define ERR_VW_PASS_THRU_NOT_ENABLED    0x14    // not used  
.................... #define ERR_CAN_NO_RESPONSE             0x15	// COMSTAT CAN register returned as extra data  
.................... #define ERR_CAN_RX_OVERFLOW             0x16  
.................... #define ERR_CAN_TX_BUFFER_UNAVAIL       0x18  
.................... #define ERR_CAN_RX_MESSAGE_LEN_WRONG    0x19  
.................... #define ERR_CAN_ERROR_INTERRUPT			0x1A	// COMSTAT CAN register returned as extra data  
.................... #define ERR_CAN_INVALID_MSG_INTERRUPT   0x1B    // TXBnCON CAN register returned as extra data 1, 2 and 3  
.................... #define ERR_ISO_INV_ADDR_NOT_RECEIVED	0x1F  
.................... #define ERR_ISO_SYNC_BYTE_NOT_RECEIVED	0x20  
....................   
.................... #define ERR_WRONG_DESTINATION           0x80      
.................... #define ERR_BYTE_COUNT_TOO_LARGE        0x81  
.................... #define ERR_J1850_FRAMING_ERROR         0x82  
.................... #define ERR_J1850_MSG_OVERFLOW          0x83   
.................... #define ERR_ISO_NO_KEYBYTE              0x84  
.................... #define ERR_ADAPTER_LOCKED              0x85  
.................... #define ERR_INVALID_NON_VOLATILE_SECTOR 0x86  
.................... #define ERR_NON_VOLATILE_SECTOR_LOCKED  0x87  
....................   
.................... // host-to-adapter commands  
.................... #define CMD_ISO_WITH_5_BAUD             0x01  
.................... #define CMD_VPW                         0x02  
.................... #define CMD_PWM                         0x04  
.................... #define CMD_CAN_SI_250KB                0x08      
.................... #define CMD_ISO                         0x10  
.................... #define CMD_VW_PASS_THRU_WITH_5_BAUD    0x20    // not used  
.................... #define CMD_VW_PASS_THRU_WITHOUT_5_BAUD 0x40    // not used  
.................... #define CMD_PWM_WITH_IFR                0x80  
.................... #define CMD_ISO_1ST_RESPONSE            0x81  
.................... #define CMD_VPW_1ST_RESPONSE            0x82  
.................... #define CMD_ATOD_CONVERSION             0x83    // not used  
.................... #define CMD_PWM_1ST_RESPONSE            0x84  
.................... #define CMD_KWP_WITH_5_BAUD             0x85  
.................... #define CMD_KWP_REPORT_KW1_KW2          0x86    // not used  
.................... #define CMD_KWP_FAST_INIT               0x87  
.................... #define CMD_KWP                         0x88  
.................... #define CMD_KWP_1ST_RESPONSE            0x89  
.................... #define CMD_CAN_SI_500KB                0x90  
.................... #define CMD_CAN_EI_250KB                0x91  
.................... #define CMD_CAN_EI_500KB                0x92  
.................... #define CMD_CAN_SI_250KB_1ST            0x93  
.................... #define CMD_CAN_SI_500KB_1ST            0x94  
.................... #define CMD_CAN_EI_250KB_1ST            0x95  
.................... #define CMD_CAN_EI_500KB_1ST            0x96  
.................... #define CMD_CAN_SET_STD_MASK_FILTER		0x97  
.................... #define CMD_CAN_SET_XTD_MASK_FILTER		0x98  
.................... #define CMD_CAN_SET_P2_CAN_TIMEOUT		0x99  
.................... #define CMD_CAN_SI_250KB_FBGO			0x9A	// FBGO = fast bus get off  
.................... #define CMD_CAN_SI_500KB_FBGO			0x9B	// FBGO = fast bus get off  
.................... #define CMD_CAN_EI_250KB_FBGO			0x9C	// FBGO = fast bus get off  
.................... #define CMD_CAN_EI_500KB_FBGO			0x9D	// FBGO = fast bus get off  
.................... #define CMD_CAN_SI_250KB_LISTEN			0x9E	  
.................... #define CMD_CAN_SI_500KB_LISTEN			0x9F	  
.................... #define CMD_CAN_EI_250KB_LISTEN			0xA0	  
.................... #define CMD_CAN_EI_500KB_LISTEN			0xA1  
.................... #define CMD_CAN_SI_250KB_NO_RESPONSE	0xA2	  
.................... #define CMD_CAN_SI_500KB_NO_RESPONSE	0xA3	  
.................... #define CMD_CAN_EI_250KB_NO_RESPONSE	0xA4	  
.................... #define CMD_CAN_EI_500KB_NO_RESPONSE	0xA5  
.................... #define CMD_ISO_NO_RESPONSE				0xA6  
.................... #define CMD_ISO_ENABLE_L_LINE_XMIT		0xA9  
.................... #define CMD_ISO_SET_9600_BAUD			0xAB  
.................... #define CMD_ISO_CHECKSUM_ENABLE			0xAC  
.................... #define CMD_ISO_5MS_BYTE_DELAY_ENABLE	0xAD  
.................... #define CMD_UNLOCK_ADAPTER              0xB0	  
.................... #define CMD_READ_EEPROM					0xB9  
.................... #define CMD_WRITE_EEPROM				0xBA  
.................... #define CMD_KWP_FAST_INIT_9600			0xC4  
.................... #define CMD_READ_BATTERY_VOLTAGE		0xF0  
....................   
.................... // adapter-to-host commands  
.................... #define CMD_ERROR                       0x80  
.................... #define CMD_ISO_MSG                     0x81  
.................... #define CMD_VPW_MSG                     0x82  
.................... #define CMD_PWM_MSG                     0x84  
.................... #define CMD_CAN_MSG                     0x88  
.................... #define CMD_KWP_MSG                     0x01  
.................... #define CMD_LOCAL_DATA					0x40  
....................   
.................... // transmit modes (must fit in 3-bits!)  
.................... #define MODE_ISO                 0x00  
.................... #define MODE_VPW                 0x01  
.................... #define MODE_PWM                 0x02  
.................... #define MODE_KWP                 0x03  
.................... #define MODE_CAN                 0x04  
....................   
.................... // interface capabilites (i.e. what com modes does the adapter support)  
.................... #define CAP_ISO         0x01  
.................... #define CAP_VPW         0x02  
.................... #define CAP_PWM         0x04  
.................... #define CAP_KWP         0x08  
.................... #define CAP_CAN         0x10  
.................... #define CAP_DUAL_CAN	0x20  
.................... #define DASH_DYNO_VER	0x40  
.................... #ifdef DASH_DYNO  
.................... #define CAP_INTERFACE   (CAP_ISO | CAP_VPW | CAP_PWM | CAP_KWP | CAP_CAN | DASH_DYNO_VER)  
.................... #else  
.................... #define CAP_INTERFACE   (CAP_ISO | CAP_VPW | CAP_PWM | CAP_KWP | CAP_CAN)  
.................... #endif  
....................   
.................... #endif   
....................  
.................... #include "Timer.h" 
....................  //------------------------------------------------------------------------------  
.................... // File: Timer  
.................... //  
.................... // Purpose: High speed timer (HST) routines.   
.................... //  
.................... // Change History:  
.................... // Date		Author		Description  
.................... //          Lafreniere	Created  
.................... //------------------------------------------------------------------------------  
.................... #ifndef TIMER_H  
.................... #define TIMER_H  
....................   
.................... #define TIMER1_TIMEOUT          0     // 1.6uS per tick with div set to 8  
.................... #define MS_TO_TICKS(mS) 		((mS * 10000) / 16)	  // 1.6uS per tick  
....................   
.................... // max 16-bit number  
.................... #define HST_TWO_MS              1250  
.................... #define HST_TEN_MS              6250  
.................... #define HST_TWENTY_FIVE_MS      15625  
.................... #define HST_FIFTY_MS            31250  
.................... #define HST_FIVE_HUNDRED_MS		312500	// NOTE: this number exceeds 16-bit timer and must be used with Int32  
.................... #define HST_ONE_S				625000	// NOTE: this number exceeds 16-bit timer and must be used with Int32  
....................   
.................... typedef int16 HstTimer; //TBD DEBUG  
.................... //typedef int32 HstTimer;  
....................               
.................... HstTimer HstGetTicks(void) { return get_timer1(); }  
*
00B6:  MOVF   FCE,W
00B8:  MOVFF  FCF,03
00BC:  MOVWF  01
00BE:  MOVF   03,W
00C0:  MOVWF  02
00C2:  RETLW  00
.................... BOOLEAN HstTestTimer(HstTimer timer, HstTimer ticks);  
.................... BOOLEAN HstTestTimerRetrig(HstTimer *timer, HstTimer ticks);  
.................... HstTimer HstElapsedTime(HstTimer timer);  
....................   
.................... #endif  
....................  
....................                    
.................... typedef struct   
.................... {  
....................     int8 comType : 3;  
....................     int8 firstResp : 1;  
.................... 	int8 forceInitCAN : 1;  
....................     int8 canModeChanged : 1;  // true when mode changes (e.g. 250kb to 500kb, or SI to EI)  
....................     int8 adapterLocked : 1;  
.................... 	int8 enableLLineXmit : 1; 		// transmit at 10.4 on both K and L lines (default is K line only)  
.................... 	int8 enableIso9600Baud : 1;		// transmit ISO at 9600 if true, false means 10.4k (default is 10.4k)  
.................... 	int8 enableIso5msByteDelay : 1; // true means 5mS between each byte sent to vehicle, false no delay (default is true)  
.................... 	int8 enableIsoChecksum : 1;		// add checksum byte to ISO messages if true, no byte added if false (default is true)  
.................... } Flags;  
....................   
.................... int8 gDevid1;  
.................... int8 gDevid2;  
....................   
.................... Flags gFlags = { MODE_ISO, FALSE };  
*
38CE:  CLRF   18
38D0:  CLRF   19
.................... int8 gError = ERR_NONE;  
38D2:  CLRF   1A
.................... int8 gErrorExtraData1 = 0;  
38D4:  CLRF   1B
.................... int8 gErrorExtraData2 = 0;  
38D6:  CLRF   1C
.................... int8 gErrorExtraData3 = 0;  
38D8:  CLRF   1D
....................   
.................... int8 gHostBuf[HOST_RECV_MSG_SIZE];  
.................... //*** #locate gHostBuf=0x2d  // pic18f248 should not require ram to be managed  
.................... int8 gHostBufCnt = 0;  
38DA:  CLRF   1E
.................... int16 gHostRecvTimeout = 0;  
38DC:  CLRF   1F
38DE:  CLRF   20
....................   
.................... int8 gVehicleBuf[VEHICLE_MAX_MSGS][VEHICLE_MSG_SIZE];  
.................... //*** #locate gVehicleBuf=0xa0  
....................   
.................... int8 gVehicleBufCnt = 0;  
38E0:  CLRF   21
....................   
.................... int8 gCurrentCmd = 0;   // current command sent from host  
38E2:  CLRF   22
.................... int8 gLastCmd = 0;      // last command sent from host  
38E4:  CLRF   23
....................   
.................... int32 gP2can = HST_FIFTY_MS;  
38E6:  MOVLW  12
38E8:  MOVLB  1
38EA:  MOVWF  xC1
38EC:  MOVLW  7A
38EE:  MOVWF  xC2
38F0:  CLRF   xC3
38F2:  CLRF   xC4
38F4:  BCF    F93.6
38F6:  BCF    F8A.6
38F8:  BCF    F93.6
38FA:  BCF    F8A.6
38FC:  BCF    F93.7
38FE:  BCF    F8A.7
3900:  BCF    F93.7
3902:  BCF    F8A.7
3904:  MOVLW  0A
3906:  MOVWF  FAF
3908:  MOVLW  26
390A:  MOVWF  FAC
390C:  MOVLW  90
390E:  MOVWF  FAB
....................   
.................... // decyption variables  
.................... int16  gLfsr;  
.................... //int8 gLast;  
....................   
.................... #endif  
....................  
....................   
.................... #include "PWM-02.c" 
....................  //------------------------------------------------------------------------------  
.................... // File: pwm-01.c  
.................... //  
.................... // Purpose: PWM Bus Interface  
.................... //  
.................... // Change History:  
.................... // Date		Author		Description  
.................... //          Bernie		Created  
.................... // August 2003 - updated for operation with the PIC18F248   
.................... //------------------------------------------------------------------------------  
....................   
.................... #include "glob_bus.h" 
....................  //------------------------------------------------------------------------------  
.................... // File: Glob_bus.h  
.................... //  
.................... // Purpose: Bus Interface global variables.  
.................... //  
.................... // Change History:  
.................... // Date		Author		Description  
.................... //          Bernie		Created  
.................... //------------------------------------------------------------------------------  
.................... #ifndef GLOB_BUS_H  
.................... #define GLOB_BUS_H  
....................   
....................   
.................... //  ************ Global Bus Protocol Variable for VPW & PWM Routines ****************  
....................   
....................   
.................... int8	LinkControl;		// Data Link Control & Status Register  
.................... #locate LinkControl=0x26  
.................... 	/* defines for the LinkControl variable bit positions */  
.................... #bit MsgRecvd = LinkControl.0		// An incomming message was received  
.................... #bit FrError = LinkControl.1		// A framing error was detected  
.................... #bit InFrResp = LinkControl.2		// An inframe response was received  
.................... #bit MsgSent = LinkControl.3		// The TX message has been sent  
.................... #bit MsgOverflow = LinkControl.4 	// A received message is longer than VEHICLE_MSG_SIZE  
.................... #bit NoBusActivity = LinkControl.5 	// Bus stuck, maximum bus acccess time exceeded  
....................   
....................   
.................... int8	LinkFlags;			// Local Data Link operation flags  
.................... #locate LinkFlags=0x27  
.................... #bit EOD			= LinkFlags.0	// End of Data Flag  
.................... #bit EOF 			= LinkFlags.1	// End of Frame Flag  
.................... #bit NxtBit 		= LinkFlags.2	// Value of next bit to transmit  
.................... #bit Act_phase_flag	= LinkFlags.3 	// VPW active phase flag  
....................   
.................... int8	ShiftReg;			// Data Byte shift register, need to be in Bank0  
.................... #locate ShiftReg=0x28  
.................... int8	MaskReg;			// Mask Register, needs to be in Bank0  
.................... #locate MaskReg=0x29  
.................... int8	PhaseTime;			// VPW active or passive phase time, needs to be in Bank0  
.................... #locate PhaseTime=0x2a  
.................... int8	BusByteCntr;		// Byte counter used in all PWM & VPW routines  
.................... #locate	BusByteCntr=0x2b  
.................... int8	BusBuffPntr_low;		// Buffer Pointer used in all PWM & VPW routines  
.................... #locate	BusBuffPntr_low=0x2c  
.................... int8	BusBuffPntr_high;		  
.................... #locate	BusBuffPntr_high=0x2d  
.................... int8	BusTimeOut;			// Used to determine if bus is stuck for error exit  
.................... #locate BusTimeOut=0x2e	  
.................... int16	BusBuffPntr;		// Buffer Pointer used in all PWM & VPW routines  
.................... #locate	BusBuffPntr=0x2f  
.................... int8	BSR_temp;			// Temporary storage for Bank Select Register  
.................... #locate	BSR_temp=0x31  
....................   
.................... #endif  
....................   
....................   
....................  
.................... #include "util.h" 
....................  //------------------------------------------------------------------------------  
.................... // File: Util  
.................... //  
.................... // Purpose: Misc utility routines.   
.................... //  
.................... // Change History:  
.................... // Date		Author		Description  
.................... //          Lafreniere	Created  
.................... //------------------------------------------------------------------------------  
.................... #ifndef UTIL_H  
.................... #define UTIL_H  
....................   
.................... // starting address for the 4-byte EEPOM write protect table  
.................... #define EEPROM_WRITE_PROTECT_TABLE_ADDR 	252  
....................   
.................... // the logical sector size is arbitrary and has nothing to do with the PIC hardware  
.................... #define EEPROM_SECTOR_SIZE 	8  
....................   
.................... void ReadEeprom();  
.................... void ReadEepromLocal(int8 sector);  
.................... void WriteEeprom();  
.................... int8 IsEepromSectorWriteProtected(int8 sector);  
.................... int32 ReadEepromSectorWriteProtectTable();  
.................... void WriteEerpomSectorWriteProtectTable(int32 writeProtectBits);  
.................... void init_ports();  
.................... void Bus_If_Init(void);  
.................... void DecryptBlock(int8 *outbfr, int8 *inbfr);  
.................... int8 IsCmdCAN(int8 cmd);  
.................... int8 IsCmdLocal(int8 cmd);  
.................... int8 IsCmdFBGO(int8 cmd);  
.................... int8 IsCmdListen(int8 cmd);  
.................... int8 IsCmdNoResponse(int8 cmd);  
.................... int8 IsCmdFirstResp(int8 cmd);  
.................... int8 IsCmdStandardId(int8 cmd);  
.................... int8 IsCmd250kb(int8 cmd);  
.................... int8 checksum(int8* pMsg, int8 size);  
.................... int8 crc8(int8* buffer, int8 count);  
.................... int32 StrToInt32(int8* str);  
.................... int8 TraceStr(int8* pMsg, int8 size);  
.................... int8 Trace(int8 msg);  
....................   
.................... #endif  
....................  
....................   
.................... // *************** INITIALIZE TIMER 2 ****************************  
.................... //   
.................... //  TIMER 2 IS INITIALIZED TO RUN AT 1/4 THE OSCILLATOR RATE (5MHZ = 200NS / CNT)  
.................... //  ITS LEFT TO FREE RUN, WE SET UP THE PR2 COMPARE REGISTER SO THAT THE COUNTER  
.................... //  AUTOMATICALLY RESTARTS AFTER REACHING THE COUNT SET IN THE PR2 REGISTER.  
.................... //   
.................... //  WE WILL LOOP ON THE OVERFLOW BIT TO KNOW WHEN THE COUNT HAS ROLLED OVER  
.................... //   
.................... //  THIS COUNTER IS BEING USED TO TIME THE TRANSMITTED BIT CELLS:  
.................... //  IN PWM, THE TIMER IS SET TO ROLLOVER EVERY 8US (24US BITCELL /3 = 8US)  
.................... //   
.................... //  Here is the code to test if we have reached or exceeded a given timer value  
....................   
.................... //timer2_wait_loop  
.................... // 	btfss		PIR1, TMR2IF	//  the bit will be set on rollover  
.................... // 	goto		timer2_wait_loop  
.................... // 	bcf	PIR1, 	TMR2IF			//  Yes we timed out, now clear the bit & continue  
.................... // 	continue with code  
....................   
.................... void tmr2_init() {  
.................... 	setup_timer_2 (T2_DIV_BY_1, 39, 1);  
*
0CBA:  MOVLW  00
0CBC:  MOVWF  01
0CBE:  IORLW  04
0CC0:  MOVWF  FCA
0CC2:  MOVLW  27
0CC4:  MOVWF  FCB
.................... 				// setup Timer2, as an 8us period timer (3 * 8us = 24us) a bit cell  
.................... 				// Set Prescaler 1:1  
.................... 				// 39 = count for a 8 us period ( 8us/200ns = 40 -1 decimal)  
.................... 				// Set Postscale Count 1:1  
.................... }  
0CC6:  GOTO   0D2E (RETURN)
....................   
....................   
.................... // ************  Entry for Receiving a PWM message  ***********  
.................... //   
.................... int8 PWMRecv(int16* RxBufferPntr, int8* RxCntPntr, int8 timeout) {  
.................... 	BusTimeOut = timeout;   	// Maximum Bus Inactivity Time Out Counter   
*
1014:  MOVFF  242,2E
.................... 								// approx 2 msec per count  
.................... 	Bus_If_Init(); 				// Initialize local variables & timers  
1018:  CALL   0B58
.................... 	BusBuffPntr = RxBufferPntr;  
101C:  MOVFF  23F,30
1020:  MOVFF  23E,2F
.................... 	BusBuffPntr_low = make8(BusBuffPntr, 0);  // load the pointer address for indirect addressing  
1024:  MOVF   2F,W
1026:  MOVWF  2C
.................... 	BusBuffPntr_high = make8(BusBuffPntr, 1);  
1028:  MOVF   30,W
102A:  MOVWF  2D
....................   
.................... 	#asm  
.................... 	movff	BusBuffPntr_low, FSR0L  
102C:  MOVFF  2C,FE9
.................... 	movff	BusBuffPntr_high, FSR0H  
1030:  MOVFF  2D,FEA
....................   
.................... 	bcf		PIR1, TMR2IF		// make sure timer 2 overflow bit is reset  
1034:  BCF    F9E.1
.................... wait_bus_activity1:  
.................... 	btfss	PIR1, TMR2IF  
1036:  BTFSS  F9E.1
.................... 	goto	wait_bus_activity2  
1038:  GOTO   1046
.................... 	bcf		PIR1, TMR2IF  
103C:  BCF    F9E.1
.................... 	decf	BusTimeOut, f		//check if Bus Access has timed out	  
103E:  DECF   2E,F
.................... 	btfsc	STATUS, Z  
1040:  BTFSC  FD8.2
.................... 	goto	RxBusInactivityExit  
1042:  GOTO   10C4
....................   
.................... wait_bus_activity2:  
.................... 	clrf	TMR0L				// restart timer at 400ns per count  
1046:  CLRF   FD6
.................... bus_active1:  
.................... 	btfss 	PWM_In				// skips next inst if bus active  
1048:  BTFSS  F80.2
.................... 	goto	wait_bus_activity1  
104A:  GOTO   1036
.................... 								// we have an active bus now  
.................... 	movlw 	( 28000 /400 )		// (desired time in ns)/400ns cylce time  
104E:  MOVLW  46
.................... 	subwf	TMR0L, W			// subtract from the current timer value  
1050:  SUBWF  FD6,W
.................... 								// look for a minimum SOF pulse of 29us (in nanoseconds)  
.................... 	btfss	STATUS, C			//  "C" is set if time equal or exceeded  
1052:  BTFSS  FD8.0
.................... 	goto	bus_active1			// loop until we find a pulse longer than 28us  
1054:  GOTO   1048
....................    
.................... wait_SOF_drop:					// we have found a SOF, now wait for it to fall  
.................... 	movlw 	( 38000 /400 )		// (desired time in ns)/400ns cylce time  
1058:  MOVLW  5F
.................... 	subwf	TMR0L, W			// subtract from the current timer value  
105A:  SUBWF  FD6,W
.................... 								// Check if bus stays high longer than 38us (could be a break pulse)  
.................... 	btfsc	STATUS, C			//  "C" is set if time equal or exceeded  
105C:  BTFSC  FD8.0
.................... 	goto	FrError_Exit		// take the framing error exit if pulse is too long  
105E:  GOTO   10B8
.................... 	btfsc 	PWM_In				// check PWM_IN skip next inst when bus goes passive  
1062:  BTFSC  F80.2
.................... 	goto	wait_SOF_drop  
1064:  GOTO   1058
.................... 								// SOF has dropped  
.................... 	#endasm  
.................... 	setup_timer_2( T2_DIV_BY_1, 255, 1 );			//  intialize timer2 for 200ns counting  
1068:  MOVLW  00
106A:  MOVWF  01
106C:  IORLW  04
106E:  MOVWF  FCA
1070:  MOVLW  FF
1072:  MOVWF  FCB
.................... 	#asm   
....................   
.................... wait_data_bit:					// now wait for rising edge of first data bit  
.................... 	clrf	TMR2				// restart timer 2 to time bit cell  
1074:  CLRF   FCC
.................... 	btfsc 	PWM_In				// skips next inst as long as bus stays passive  
1076:  BTFSC  F80.2
.................... 	goto	first_bit  
1078:  GOTO   108A
.................... 	movlw 	( 63000 /400 )		// (desired time in ns)/400ns cylce time  
107C:  MOVLW  9D
.................... 	subwf	TMR0L, W			// subtract from the current timer value  
107E:  SUBWF  FD6,W
.................... 								// check if SOF has been down too long (frerror or break)  
.................... 	btfss	STATUS, C			//  "C" is set if time equal or exceeded	  
1080:  BTFSS  FD8.0
.................... 	goto 	wait_data_bit		// loop back & check bus state again  
1082:  GOTO   1074
....................  	goto	FrError_Exit		// exit if 1st bit does not arrive in time  
1086:  GOTO   10B8
....................   
.................... first_bit:						// start getting the data bits  
.................... get_data_bits:				  
.................... 	movlw	0b00000001			// prime the RX shift register  
108A:  MOVLW  01
.................... 	movwf	ShiftReg  
108C:  MOVWF  28
.................... get_inframe_response:			// entry point for getting the in-frame response bytes			  
.................... wait_bit_fall:  
.................... 	btfss 	PWM_In				// skips next inst as long as bus stays active  
108E:  BTFSS  F80.2
.................... 	goto	the_bit_fell  
1090:  GOTO   10A2
.................... 	movlw 	( 22000 /200 )		// (desired time in ns)/200ns cylce time  
1094:  MOVLW  6E
.................... 	subwf	TMR2, W				// subtract from the current timer value  
1096:  SUBWF  FCC,W
.................... 								// check if active phase of bit cell is up too long  
.................... 	btfss	STATUS, C			//  "C" is set if time equal or exceeded	  
1098:  BTFSS  FD8.0
.................... 	goto 	wait_bit_fall		// loop back & check bus state again  
109A:  GOTO   108E
.................... 	goto	FrError_Exit		// it was up too long, take framing error exit  
109E:  GOTO   10B8
....................    
.................... the_bit_fell:					// bit fell, now check if this was a one or a zero  
.................... 	movlw 	( 12500 /200 )		// (desired time in ns)/200ns cylce time  
10A2:  MOVLW  3E
.................... 	subwf	TMR2, W				// subtract from the current timer value  
10A4:  SUBWF  FCC,W
.................... 								// check if active phase of bit cell was longer than 12.5us  
.................... 	btfss	STATUS, C			//  "C" is set if 12.5us has been equaled or exceeded  
10A6:  BTFSS  FD8.0
.................... 	goto	shift_in_a_1		// it was a 1 if less than 12.5us  
10A8:  GOTO   10CA
.................... 	bcf		STATUS, C			// clear C becuse we want to rotate in a zero	  
10AC:  BCF    FD8.0
.................... 	goto 	shift_it_in			// it was a 0 if more than 12.5us  
10AE:  GOTO   10CC
....................   
....................   
.................... read_another_bit:  
.................... 	clrf	TMR2				// clear timer to time next bit  
10B2:  CLRF   FCC
.................... 	goto	wait_bit_fall  
10B4:  GOTO   108E
....................   
.................... FrError_Exit:  
.................... 	bsf		FrError 			// set framing error flag in link control register  
10B8:  BSF    26.1
.................... 	goto	RX_PWM_Exit  
10BA:  GOTO   110C
....................   
.................... MsgError_Exit:  
.................... 	bsf		MsgOverflow			// set overflow error flag in link control register  
10BE:  BSF    26.4
.................... 	goto	RX_PWM_Exit  
10C0:  GOTO   110C
....................   
.................... RxBusInactivityExit:  
.................... 	bsf		NoBusActivity		// set the error flag bit in LinkControl  
10C4:  BSF    26.5
.................... 	goto	RX_PWM_Exit2		// error exit if bus is stuck busy  
10C6:  GOTO   1110
....................   
.................... 					  
.................... shift_in_a_1:  
.................... 	bsf		STATUS, C			// set C for rotation of a 1 into register  
10CA:  BSF    FD8.0
.................... shift_it_in:  
.................... 	rlcf	ShiftReg, F			// rotate the C bit into the LSB position (data comes in MSB first)  
10CC:  RLCF   28,F
.................... 								// after 8 rotations, the first bit in will be in the MSB position  
.................... 	btfss	STATUS, C			// register is full when the preset one bit comes out  
10CE:  BTFSS  FD8.0
.................... 	goto	wait_strt_nxt_bit  	// branch if register not full yet  
10D0:  GOTO   10EA
.................... 								// shift register is full, save the byte  
....................   
.................... 	incf	BusByteCntr, F		// add one to the received bytes count  
10D4:  INCF   2B,F
.................... 	movlw	VEHICLE_MSG_SIZE+1	// check if we have exceeded the maximum msg size  
10D6:  MOVLW  0D
.................... 	subwf	BusByteCntr, W  
10D8:  SUBWF  2B,W
.................... 	btfsc	STATUS, C			// 'C' will be set when we are oversize  
10DA:  BTFSC  FD8.0
.................... 	goto	MsgError_Exit		// its an error if we are over the max byte count  
10DC:  GOTO   10BE
....................   
.................... 	movf	ShiftReg, W			// shift register is full, save the accumulated byte to RxBuffer  
10E0:  MOVF   28,W
....................  	movwf	INDF0  
10E2:  MOVWF  FEF
.................... 	incf	FSR0L, F			// advance indirect memory pointer to next byte	  
10E4:  INCF   FE9,F
.................... 	movlw	0b00000001			// prime the shift register again  
10E6:  MOVLW  01
.................... 	movwf	ShiftReg			  
10E8:  MOVWF  28
.................... 			  
....................   
.................... //  **** delete support for In Frame Response  
.................... //InFrame_Ck:					// now lets check if there is an inframe response  
.................... //	btfsc 	PWM_In				// check to see if inframe response active phase shows up			  
.................... //	goto 	Ck_InFrame_Status	// executes this inst if bus goes back active  
.................... //	movlw 	( 66000 /400 )		// (desired time in ns)/400ns cylce time  
.................... //	subwf	TMR0L, W			// subtract from the current timer value  
.................... //								// check if bus stays passive longer than 66us  
.................... //	btfss	STATUS, C			//  "C" is set if 66us has been equaled or exceeded  
.................... //	goto	InFrame_Ck			// loop back & wait until bus is inactive for 66us  
.................... //  ******************  
....................   
.................... //  **** delete support for In Frame Response  
.................... //Ck_InFrame_Status:  
.................... //	clrf	TMR0L				// restart timer0 to start timing 1st inframe response bit  
.................... //	btfsc	InFrResp			// test if we have already detected an inframe response  
.................... //	goto	FrError_Exit		// this is an error if already found an inframe response  
.................... //	bsf		InFrResp 			// Set the inframe response detected status flag  
.................... //	goto	get_inframe_response	// go receive the inframe message  
.................... //  **********************		  
....................   
.................... wait_strt_nxt_bit:  
.................... 	btfsc 	PWM_In				// check to see if we get another data bit comming			  
10EA:  BTFSC  F80.2
.................... 	goto 	read_another_bit	// executes this inst if bus is active  
10EC:  GOTO   10B2
.................... 	movlw 	( 29500 /200 )		// (desired time in ns)/200ns cylce time  
10F0:  MOVLW  93
.................... 	subwf	TMR2, W				// subtract from the current timer value  
10F2:  SUBWF  FCC,W
.................... 								// check if bus stays passive longer than 29us  
.................... 	btfss	STATUS, C			//  "C" is set if 29us has been equaled or exceeded  
10F4:  BTFSS  FD8.0
.................... 	goto	wait_strt_nxt_bit  
10F6:  GOTO   10EA
.................... 	bsf		MsgRecvd			// set the message received flag  
10FA:  BSF    26.0
....................    
.................... end_of_data_ck:					// now look for end of frame sequence  
.................... 	btfsc 	PWM_In				// check to see that another active phase doesnt show up			  
10FC:  BTFSC  F80.2
.................... 	goto 	FrError_Exit		// executes this inst if bus goes back active  
10FE:  GOTO   10B8
.................... 								// if it does, its an error  
.................... 	movlw 	( 40000 /200 )		// (desired time in ns)/200ns cylce time  
1102:  MOVLW  C8
.................... 	subwf	TMR2, W				// subtract from the current timer value  
1104:  SUBWF  FCC,W
.................... 								// check if bus stays passive longer than 45us  
.................... 	btfss	STATUS, C			//  "C" is set if 45us has been equaled or exceeded  
1106:  BTFSS  FD8.0
.................... 	goto	end_of_data_ck		// loop back & wait until until the bus is inactive for 45us  
1108:  GOTO   10FC
.................... RX_PWM_Exit:  
.................... 	bsf		EOD					//  set the end of data flag  
110C:  BSF    27.0
.................... 	bsf		EOF					//  set end of frame flag  
110E:  BSF    27.1
.................... RX_PWM_Exit2:  
.................... 	#endasm  
.................... 	*RxCntPntr = BusByteCntr;	// return count of received bytes  
1110:  MOVLB  2
1112:  MOVF   x40,W
1114:  MOVWF  FE9
1116:  MOVLB  0
1118:  MOVFF  241,FEA
111C:  MOVFF  2B,FEF
.................... 	return LinkControl;			// return status of the read operation  
1120:  MOVF   26,W
1122:  MOVWF  01
.................... }  
1124:  GOTO   12E2 (RETURN)
....................   
.................... // ###################################################################  
.................... // ***************  Entry for PWM Transmit Routine  ******************	  
.................... //   
.................... int8 PWMSend(int16* TxBufferPntr, int8 PWMTxCnt, int8 timeout) {  
.................... 	BusTimeOut = timeout;   	// Maximum Bus Inactivity Time Out Counter   
*
0CCA:  MOVFF  216,2E
.................... 								// approx 2 msec per count  
....................     #asm  
....................     lost_arbitration2:			// internal, lost arbitration re-entry point  
....................     #endasm  
....................   
.................... 	Bus_If_Init(); 				// Initialize local variables & timers  
0CCE:  CALL   0B58
....................   
.................... 	BusBuffPntr = TxBufferPntr;  
0CD2:  MOVFF  214,30
0CD6:  MOVFF  213,2F
.................... 	BusBuffPntr_low = make8(BusBuffPntr, 0);  // load the pointer address for indirect addressing  
0CDA:  MOVF   2F,W
0CDC:  MOVWF  2C
.................... 	BusBuffPntr_high = make8(BusBuffPntr, 1);  
0CDE:  MOVF   30,W
0CE0:  MOVWF  2D
....................   
.................... 	BusByteCntr = PWMTxCnt;		// load the the TxCnt (being pointed at)  
0CE2:  MOVFF  215,2B
....................   
.................... 	#asm  
.................... 	bcf		PIR1, TMR2IF		// make sure timer 2 overflow bit is reset  
0CE6:  BCF    F9E.1
.................... 	movff	BusBuffPntr_low, FSR0L  
0CE8:  MOVFF  2C,FE9
.................... 	movff	BusBuffPntr_high, FSR0H  
0CEC:  MOVFF  2D,FEA
....................   
.................... EOF_wait1:  
.................... 	movf	BusTimeOut, f		// check if Bus Access Time has timed out  
0CF0:  MOVF   2E,F
.................... 	btfsc	STATUS, Z  
0CF2:  BTFSC  FD8.2
.................... 	goto	TxBusBusyExit		// error exit if bus is stuck busy  
0CF4:  GOTO   0D9C
.................... 	btfss	PIR1, TMR2IF		// check if bus timeout period counter has expired  
0CF8:  BTFSS  F9E.1
.................... 	goto	EOF_wait3			// jump if timer has not timed out yet  
0CFA:  GOTO   0D02
.................... 	bcf		PIR1, TMR2IF		// reset timer overflow flag  
0CFE:  BCF    F9E.1
.................... 	decf	BusTimeOut, f		// sub one timer tick from timeout count  
0D00:  DECF   2E,F
....................   
.................... EOF_wait3:  
.................... 	clrf	TMR0L				// restart timer  
0D02:  CLRF   FD6
.................... EOF_wait2:  
.................... 	btfsc 	PWM_In				// skips next when bus is passive  
0D04:  BTFSC  F80.2
.................... 	goto	EOF_wait1			// loop back & clear timer whenever bus is active  
0D06:  GOTO   0CF0
....................   
.................... 	movlw 	( 70000 /400 )		// (desired time in ns)/400ns cylce time  
0D0A:  MOVLW  AF
.................... 	subwf	TMR0L, W			// subtract from the current timer value   
0D0C:  SUBWF  FD6,W
.................... 								// check if bus stays passive longer than 70us for EOF  
.................... 	btfss	STATUS, C			//  "C" is set if 70us has been equaled or exceeded  
0D0E:  BTFSS  FD8.0
.................... 	goto	EOF_wait2			// loop as long as active, checking for 70us duration  
0D10:  GOTO   0D04
....................   
.................... IFS_wait:						// End of Frame found, now check if anyone else starts  
.................... 								// after 70 us if any other node sends a SOF, we can  
.................... 								// put one out as well, even if before the 96us is up  
.................... 	btfsc 	PWM_In				// executes next inst is bus goes active  
0D14:  BTFSC  F80.2
.................... 	goto	strt_transmission	// branch out if bus goes active  
0D16:  GOTO   0D24
.................... 	movlw 	( 96000 /400 )		// (desired time in ns)/400ns cylce time  
0D1A:  MOVLW  F0
.................... 	subwf	TMR0L, W			// subtract from the current timer value  
0D1C:  SUBWF  FD6,W
.................... 								// check if bus stays passive longer than 96us for IFS  
.................... 	btfss	STATUS, C			//  "C" is set if 96us has been equaled or exceeded  
0D1E:  BTFSS  FD8.0
.................... 	goto	IFS_wait			// continue checking til a SOF shows up, or the 96 us times out  
0D20:  GOTO   0D14
....................    
.................... strt_transmission:				// we have seen a SOF or the 96us IFS time has expired  
.................... 								// in either case, we now drive our own 32us SOF pulse  
.................... 	clrf	TMR0L				// restart the timer  
0D24:  CLRF   FD6
.................... 	bcf		PORTA, PWM_P_Out	// set PWM Bus Active  
0D26:  BCF    F80.3
.................... 	bsf		PORTA, PWM_N_Out	// P=0, N=1  
0D28:  BSF    F80.1
.................... 	#endasm  
.................... 	tmr2_init();				// setup Timer2, as an 8us period timer (3 * 8us = 24us) a bit cell  
0D2A:  GOTO   0CBA
.................... 	  
.................... 	#asm  
.................... SOF_delay:  
.................... 	movlw 	( 30000 /400 )		// (desired time ns startup time)/400ns cylce time  
0D2E:  MOVLW  4B
.................... 								// nominal per spec is 32 us (use 1us shorter for decay time on bus)  
.................... 	subwf	TMR0L, W			// subtract from the current timer value  
0D30:  SUBWF  FD6,W
.................... 								// check if bus stays passive longer than 32us for IFS  
.................... 								//  subtracted 1 us for software & circuit delays  
.................... 	btfss	STATUS, C			//  "C" is set if 32us has been equaled or exceeded  
0D32:  BTFSS  FD8.0
.................... 	goto	SOF_delay			// drive the SOF pulse for the full 32us  
0D34:  GOTO   0D2E
....................    
.................... 	bsf		PORTA, PWM_P_Out	// set PWM Bus Inactive  
0D38:  BSF    F80.3
.................... 	bcf		PORTA, PWM_N_Out	// P=1, N=0			  
0D3A:  BCF    F80.1
.................... 								// drive BUS passive to terminate SOF pulse  
....................    
.................... start_sending_bits:  
.................... settle_delay:					// allow the bus to settle, per spec should be 1.7us max  
.................... 	movlw 	( 34000 /400 )		// (desired time in ns)/400ns cylce time  
0D3C:  MOVLW  55
.................... 	subwf	TMR0L, W			// subtract from the current timer value  
0D3E:  SUBWF  FD6,W
.................... 								// allow 2.4us settle time (34.4-32=2.4us) for bus to go passive  
.................... 	btfss	STATUS, C			//  "C" is set if 35us has been equaled or exceeded  
0D40:  BTFSS  FD8.0
.................... 	goto	settle_delay		// wait the 2.4 us settle time  
0D42:  GOTO   0D3C
....................    
.................... 	btfsc 	PWM_In				// skips next inst if bus is still passive  
0D46:  BTFSC  F80.2
.................... 	goto	lost_arbitration	// Oh-oh, the bus is being driven, we loose arbitration				  
0D48:  GOTO   0DEE
.................... 								// get the first bit to transmit  
....................  	bcf		NxtBit				// Clear NxtBit in advance of test  
0D4C:  BCF    27.2
.................... 	btfsc	INDF0, 7			// test the MSbit of the first byte in the buffer  
0D4E:  BTFSC  FEF.7
....................   
.................... 	bsf		NxtBit				// if the MSB wasn't a zero, set a one into NxtBit  
0D50:  BSF    27.2
....................    
.................... SOF_passive_delay:				// keep checking to make sure no one else starts driving the bus  
.................... 	btfsc 	PWM_In				// skips next inst if bus is still passive  
0D52:  BTFSC  F80.2
.................... 	goto	lost_arbitration	// Oh-oh, the bus is being driven, we loose arbitration  
0D54:  GOTO   0DEE
.................... 	movlw 	( 45500 /400 )		// (desired time in ns)/400ns cylce time  
0D58:  MOVLW  71
.................... 	subwf	TMR0L, W			// subtract from the current timer value  
0D5A:  SUBWF  FD6,W
.................... 								// wait for the 16us of passive time after the active SOF pulse  
.................... 	btfss	STATUS, C			//  "C" is set if 47us has been equaled or exceeded  
0D5C:  BTFSS  FD8.0
.................... 	goto	SOF_passive_delay	// wait the 16us of passive SOF time  
0D5E:  GOTO   0D52
....................    
.................... 	clrf	TMR2				// re-start (zero) timer2 to synchronize it with end of SOF time  
0D62:  CLRF   FCC
.................... 	bcf		PIR1, TMR2IF		// clear timer 2 interrupt flag, in case it was set  
0D64:  BCF    F9E.1
.................... 	nop							// actual timer2 interrupts are not enabled, we will be testing the flag bit  
0D66:  NOP   
.................... 	nop							// a few nop's to compenstate for TMR2 startup time after reset  
0D68:  NOP   
.................... 	nop							//  of prescaller / postscaler caused by write to TMR2  
0D6A:  NOP   
.................... 	nop  
0D6C:  NOP   
.................... 	nop  
0D6E:  NOP   
....................    
.................... strt_bit_cell:  
.................... 	bcf		PORTA, PWM_P_Out	// set PWM Bus Active  
0D70:  BCF    F80.3
.................... 	bsf		PORTA, PWM_N_Out	// P=0, N=1 for start of bit cell  
0D72:  BSF    F80.1
.................... 	clrf	TMR0L				// restart timer 0  
0D74:  CLRF   FD6
.................... 	btfss	NxtBit				// test if the next bit is a one or a zero  
0D76:  BTFSS  27.2
.................... 	goto	its_a_zero  
0D78:  GOTO   0DA2
.................... its_a_one:  
.................... 	btfss	PIR1, TMR2IF		// check if 1st 8us time period is complete yet  
0D7C:  BTFSS  F9E.1
.................... 	goto	its_a_one  
0D7E:  GOTO   0D7C
.................... 	bsf		PORTA, PWM_P_Out	// set PWM Bus Inactive  
0D82:  BSF    F80.3
.................... 	bcf		PORTA, PWM_N_Out	// P=1, N=0			  
0D84:  BCF    F80.1
.................... 								// for a one, go passive after 8us of active time  
.................... 	bcf		PIR1, TMR2IF		// reset the timer overflow bit  
0D86:  BCF    F9E.1
....................   
.................... wait_half_cell:  
.................... 	movlw 	( 12500 /400 )		// (desired time ns startup time)/400ns cylce time  
0D88:  MOVLW  1F
.................... 	subwf	TMR0L, W			// subtract from the current timer value  
0D8A:  SUBWF  FD6,W
.................... 								// wait 4.5us of passive time (halfway between a one & a zero)  
.................... 								// 8us one time + 4.5us = 12.5us   
.................... 	btfss	STATUS, C			//  "C" is set when 12.5us has been equaled or exceeded  
0D8C:  BTFSS  FD8.0
.................... 	goto	wait_half_cell		// wait the 4.5us  
0D8E:  GOTO   0D88
.................... 	btfsc 	PWM_In				// skips next inst if bus is still passive  
0D92:  BTFSC  F80.2
.................... 	goto	lost_arbitration	// Oh-oh, the bus is being driven, we loose arbitration  
0D94:  GOTO   0DEE
.................... 	goto	wait_2nd_half  
0D98:  GOTO   0DAA
....................   
.................... TxBusBusyExit:  
.................... 	bsf		NoBusActivity		// set the error flag bit in LinkControl  
0D9C:  BSF    26.5
.................... 	goto	TxErrorExit  
0D9E:  GOTO   0DFE
....................    
.................... its_a_zero:						// a zero drives the bus active for 2, 8us timer periods  
.................... 	btfss	PIR1, TMR2IF		// wait for 1st 8us time period to complete  
0DA2:  BTFSS  F9E.1
.................... 	goto	its_a_zero  
0DA4:  GOTO   0DA2
.................... 	bcf		PIR1, TMR2IF		// reset the timer overflow bit		  
0DA8:  BCF    F9E.1
.................... wait_2nd_half:			  
.................... 	btfss	PIR1, TMR2IF		// wait for 2nd 8us time period to complete  
0DAA:  BTFSS  F9E.1
.................... 	goto	wait_2nd_half  
0DAC:  GOTO   0DAA
.................... 	bsf		PORTA, PWM_P_Out	// set PWM Bus Inactive  
0DB0:  BSF    F80.3
.................... 	bcf		PORTA, PWM_N_Out	// P=1, N=0  
0DB2:  BCF    F80.1
.................... 								// after the 16us go set BUS passive  
.................... 	bcf		PIR1, TMR2IF		// reset the timer overflow bit  
0DB4:  BCF    F9E.1
....................    
.................... get_next_bit:					// get next bit to transmit  
.................... 	bcf		STATUS, C			// make sure 'C' bit is clear before rotating  
0DB6:  BCF    FD8.0
.................... 	rrcf	MaskReg, F			// Move Mask to next bit position  
0DB8:  RRCF   29,F
.................... 	btfsc	STATUS, C			// if C is set, the entire byte has been sent  
0DBA:  BTFSC  FD8.0
.................... 	goto	get_next_byte		// setup the next byte  
0DBC:  GOTO   0DDC
.................... test_the_bit:					// check if the masked bit is a one or a zero  
.................... 	movf	MaskReg, W			// fetch the Mask Register  
0DC0:  MOVF   29,W
.................... 	andwf	INDF0, W			// and the mask with current byte being transmitted (indirect)  
0DC2:  ANDWF  FEF,W
.................... 	bcf		NxtBit  
0DC4:  BCF    27.2
.................... 	btfss	STATUS, Z			// skip next instruction if bit was a zero  
0DC6:  BTFSS  FD8.2
.................... 	bsf		NxtBit				// NxtBit is now set up for the next bit to be sent, now  
0DC8:  BSF    27.2
....................    
.................... wait_cell_passive:				// wait for the 8us of passive time that marks end of bit cell  
.................... 	btfsc  	PWM_In				// skips next inst if bus is still passive  
0DCA:  BTFSC  F80.2
.................... 	goto	lost_arbitration	// Oh-oh, the bus is being driven, we loose arbitration  
0DCC:  GOTO   0DEE
.................... 	btfss	PIR1, TMR2IF		// wait for 3rd & final 8us time period to complete (24us bit cell)  
0DD0:  BTFSS  F9E.1
.................... 	goto	wait_cell_passive  
0DD2:  GOTO   0DCA
.................... 	bcf		PIR1, TMR2IF		// reset the timer overflow bit  
0DD6:  BCF    F9E.1
.................... 	goto	strt_bit_cell		// go back to transmit the next bit  
0DD8:  GOTO   0D70
....................    
.................... get_next_byte:  
.................... 	incf	FSR0L, F			// increment the TX buffer pointer  
0DDC:  INCF   FE9,F
.................... 	decf	BusByteCntr, F		// sub one from the count of bytes to be sent  
0DDE:  DECF   2B,F
.................... 	btfsc	STATUS, Z			// have we sent them all yet  
0DE0:  BTFSC  FD8.2
.................... 	goto	all_sent			// exit loop if we are done sending  
0DE2:  GOTO   0DF8
.................... 	movlw	0x80  
0DE6:  MOVLW  80
.................... 	movwf	MaskReg				// put a one back into the MSB position  
0DE8:  MOVWF  29
.................... 	goto	test_the_bit		// go transmit the MSB bit of this new byte  
0DEA:  GOTO   0DC0
....................   
.................... lost_arbitration:  
.................... 	movf	BusTimeOut, f		// Check the bus access time out count to see  
0DEE:  MOVF   2E,F
.................... 	btfss	STATUS, Z			// if its already zero	  
0DF0:  BTFSS  FD8.2
.................... 	decf	BusTimeOut, f		// reduce bus time out on each lost arbitration cycle  
0DF2:  DECF   2E,F
.................... 	goto	lost_arbitration2			  
0DF4:  GOTO   0CCE
....................    
.................... all_sent:  
.................... 	bsf		MsgSent				// set the Message Sent Flag  
0DF8:  BSF    26.3
.................... //	movlw	RxBuffer  
.................... //	movwf	FSR0L				// setup RxBuffer pointer in case of in-frame response  
.................... //	movlw	0b00000001			// prime first RxBuffer byte as a shift register  
.................... //	movwf	INDF0  
....................   
.................... TX_PWM_Exit:  
.................... 	bsf		EOD					//  set the end of data flag  
0DFA:  BSF    27.0
.................... 	bsf		EOF					//  set end of frame flag  
0DFC:  BSF    27.1
.................... TxErrorExit:  
.................... 	#endasm  
.................... 	return LinkControl;			// return the status of the transmit operation  
0DFE:  MOVF   26,W
0E00:  MOVWF  01
.................... }  
0E02:  GOTO   0EB8 (RETURN)
.................... 	  
....................   
.................... // ##############   End of pwm-xx.asm    ########################  
....................   
....................   
....................  
.................... #include "VPW-02.c" 
....................  //------------------------------------------------------------------------------  
.................... // File: vpw-01.c  
.................... //  
.................... // Purpose: VPW Bus Interface  
.................... //  
.................... // Change History:  
.................... // Date		Author		Description  
.................... //          Bernie		Created  
.................... // August 2003 - updated for operation with the PIC18F248   
.................... //------------------------------------------------------------------------------  
....................   
.................... #include "glob_bus.h" 
....................  //------------------------------------------------------------------------------  
.................... // File: Glob_bus.h  
.................... //  
.................... // Purpose: Bus Interface global variables.  
.................... //  
.................... // Change History:  
.................... // Date		Author		Description  
.................... //          Bernie		Created  
.................... //------------------------------------------------------------------------------  
.................... #ifndef GLOB_BUS_H  
.................... #define GLOB_BUS_H  
....................   
....................   
.................... //  ************ Global Bus Protocol Variable for VPW & PWM Routines ****************  
....................   
....................   
.................... int8	LinkControl;		// Data Link Control & Status Register  
.................... #locate LinkControl=0x26  
.................... 	/* defines for the LinkControl variable bit positions */  
.................... #bit MsgRecvd = LinkControl.0		// An incomming message was received  
.................... #bit FrError = LinkControl.1		// A framing error was detected  
.................... #bit InFrResp = LinkControl.2		// An inframe response was received  
.................... #bit MsgSent = LinkControl.3		// The TX message has been sent  
.................... #bit MsgOverflow = LinkControl.4 	// A received message is longer than VEHICLE_MSG_SIZE  
.................... #bit NoBusActivity = LinkControl.5 	// Bus stuck, maximum bus acccess time exceeded  
....................   
....................   
.................... int8	LinkFlags;			// Local Data Link operation flags  
.................... #locate LinkFlags=0x27  
.................... #bit EOD			= LinkFlags.0	// End of Data Flag  
.................... #bit EOF 			= LinkFlags.1	// End of Frame Flag  
.................... #bit NxtBit 		= LinkFlags.2	// Value of next bit to transmit  
.................... #bit Act_phase_flag	= LinkFlags.3 	// VPW active phase flag  
....................   
.................... int8	ShiftReg;			// Data Byte shift register, need to be in Bank0  
.................... #locate ShiftReg=0x28  
.................... int8	MaskReg;			// Mask Register, needs to be in Bank0  
.................... #locate MaskReg=0x29  
.................... int8	PhaseTime;			// VPW active or passive phase time, needs to be in Bank0  
.................... #locate PhaseTime=0x2a  
.................... int8	BusByteCntr;		// Byte counter used in all PWM & VPW routines  
.................... #locate	BusByteCntr=0x2b  
.................... int8	BusBuffPntr_low;		// Buffer Pointer used in all PWM & VPW routines  
.................... #locate	BusBuffPntr_low=0x2c  
.................... int8	BusBuffPntr_high;		  
.................... #locate	BusBuffPntr_high=0x2d  
.................... int8	BusTimeOut;			// Used to determine if bus is stuck for error exit  
.................... #locate BusTimeOut=0x2e	  
.................... int16	BusBuffPntr;		// Buffer Pointer used in all PWM & VPW routines  
.................... #locate	BusBuffPntr=0x2f  
.................... int8	BSR_temp;			// Temporary storage for Bank Select Register  
.................... #locate	BSR_temp=0x31  
....................   
.................... #endif  
....................   
....................   
....................  
.................... #include "Util.h" 
....................  //------------------------------------------------------------------------------  
.................... // File: Util  
.................... //  
.................... // Purpose: Misc utility routines.   
.................... //  
.................... // Change History:  
.................... // Date		Author		Description  
.................... //          Lafreniere	Created  
.................... //------------------------------------------------------------------------------  
.................... #ifndef UTIL_H  
.................... #define UTIL_H  
....................   
.................... // starting address for the 4-byte EEPOM write protect table  
.................... #define EEPROM_WRITE_PROTECT_TABLE_ADDR 	252  
....................   
.................... // the logical sector size is arbitrary and has nothing to do with the PIC hardware  
.................... #define EEPROM_SECTOR_SIZE 	8  
....................   
.................... void ReadEeprom();  
.................... void ReadEepromLocal(int8 sector);  
.................... void WriteEeprom();  
.................... int8 IsEepromSectorWriteProtected(int8 sector);  
.................... int32 ReadEepromSectorWriteProtectTable();  
.................... void WriteEerpomSectorWriteProtectTable(int32 writeProtectBits);  
.................... void init_ports();  
.................... void Bus_If_Init(void);  
.................... void DecryptBlock(int8 *outbfr, int8 *inbfr);  
.................... int8 IsCmdCAN(int8 cmd);  
.................... int8 IsCmdLocal(int8 cmd);  
.................... int8 IsCmdFBGO(int8 cmd);  
.................... int8 IsCmdListen(int8 cmd);  
.................... int8 IsCmdNoResponse(int8 cmd);  
.................... int8 IsCmdFirstResp(int8 cmd);  
.................... int8 IsCmdStandardId(int8 cmd);  
.................... int8 IsCmd250kb(int8 cmd);  
.................... int8 checksum(int8* pMsg, int8 size);  
.................... int8 crc8(int8* buffer, int8 count);  
.................... int32 StrToInt32(int8* str);  
.................... int8 TraceStr(int8* pMsg, int8 size);  
.................... int8 Trace(int8 msg);  
....................   
.................... #endif  
....................  
....................   
.................... // ************  Entry for Receiving a VPW message  ***********  
....................   
.................... int8 VPWRecv (int16* RxBufferPntr, int8* RxCntPntr, int8 timeout) {  
.................... 	BusTimeOut = timeout;   	// Maximum Bus Inactivity Time Out Counter   
*
0EEC:  MOVFF  242,2E
.................... 								// approx 2 msec per count  
.................... 	Bus_If_Init(); 				// Initialize local variables & timers  
0EF0:  CALL   0B58
.................... 	BusBuffPntr = RxBufferPntr;  
0EF4:  MOVFF  23F,30
0EF8:  MOVFF  23E,2F
.................... 	BusBuffPntr_low = make8(BusBuffPntr, 0);  // load the pointer address for indirect addressing  
0EFC:  MOVF   2F,W
0EFE:  MOVWF  2C
.................... 	BusBuffPntr_high = make8(BusBuffPntr, 1);  
0F00:  MOVF   30,W
0F02:  MOVWF  2D
....................   
.................... 	setup_timer_0( RTCC_INTERNAL | RTCC_DIV_8 );	//  intialize & start timer0 at 1.6us per count  
0F04:  MOVLW  82
0F06:  MOVWF  FD5
....................   
.................... 	#asm  
.................... //	movff	BSR_temp, BSR		// Save current setting of Bank Select Register  
.................... ///	movlb	0					//Set BSR to bank zero   
.................... 	movff	BusBuffPntr_low, FSR0L  
0F08:  MOVFF  2C,FE9
.................... 	movff	BusBuffPntr_high, FSR0H  
0F0C:  MOVFF  2D,FEA
....................   
.................... 	bcf		PIR1, TMR2IF		// make sure timer 2 overflow bit is reset  
0F10:  BCF    F9E.1
.................... wait_bus_activity_v:  
.................... 	btfss	PIR1, TMR2IF  
0F12:  BTFSS  F9E.1
.................... 	goto	wait_bus_activity2_v  
0F14:  GOTO   0F22
.................... 	bcf		PIR1, TMR2IF  
0F18:  BCF    F9E.1
.................... 	decf	BusTimeOut, f		//check if Bus Access has timed out (300 msec max)	  
0F1A:  DECF   2E,F
.................... 	btfsc	STATUS, Z  
0F1C:  BTFSC  FD8.2
.................... 	goto	Rx_BusInactivityExit  
0F1E:  GOTO   0FF4
....................   
.................... wait_bus_activity2_v:  
.................... 	clrf	TMR0L				//  restart timer0  
0F22:  CLRF   FD6
.................... bus_active1_v:  
.................... 	btfss PORTA, VPW_In			//  skips next inst if bus active  
0F24:  BTFSS  F80.4
.................... 	goto	wait_bus_activity_v  
0F26:  GOTO   0F12
.................... 								//  we have an active bus now  
.................... 								// calculate the count of time to compare to in nanoseconds  
.................... 	movlw 	( 163000/1600 )		// (desired time in ns)/1.6us cylce time  
0F2A:  MOVLW  65
.................... 	subwf	TMR0L, W			// subtract from the current timer value  
0F2C:  SUBWF  FD6,W
.................... 								// The "C" bit is a one when the time has been equaled or exceeded	  
.................... 								//  look for a minimum SOF pulse of 163us (in nanoseconds)  
.................... 	btfss	STATUS, C			//  "C" is set if time equal or exceeded  
0F2E:  BTFSS  FD8.0
.................... 	goto	bus_active1_v		//  loop until we find a pulse longer than 163us  
0F30:  GOTO   0F24
....................    
.................... wait_SOF_drop_v:				//  we have found a SOF, now wait for it to fall  
.................... 								//  Check if bus stays high longer than 239us (could be a break pulse)  
.................... 	movlw 	( 239000 /1600 )	// (desired time in ns)/1.6us cylce time  
0F34:  MOVLW  95
.................... 	subwf	TMR0L, W			// subtract from the current timer value									  
0F36:  SUBWF  FD6,W
.................... 	btfsc	STATUS, C			//  "C" is set if time equal or exceeded  
0F38:  BTFSC  FD8.0
.................... 	goto	FrError_Exit_v		//  take the framming error exit if pulse is too long  
0F3A:  GOTO   0FFA
.................... 	btfsc	PORTA, VPW_In		//  skip next inst when bus goes passive  
0F3E:  BTFSC  F80.4
.................... 	goto	wait_SOF_drop_v  
0F40:  GOTO   0F34
.................... 								//  SOF has dropped  
....................   
.................... first_bit_v:					//  start getting the data bits  
.................... get_inframe_response_v:			//  entry point for getting the in-frame response bytes  
.................... 	clrf	TMR0L				//  restart timer 0 to time bit cell		  
0F44:  CLRF   FD6
.................... 	bcf		Act_phase_flag  
0F46:  BCF    27.3
.................... get_data_bits_v:				  
.................... 	movlw	0b00000001			//  prime the shift register  
0F48:  MOVLW  01
.................... 	movwf	ShiftReg  
0F4A:  MOVWF  28
....................   
....................   
.................... passive_phase:					//  decode if a one or a zero during this passive phase period  
.................... 								//  in passive phase, 64us nom pulse is a zero (34us min - 96us max)  
.................... 								//  in passive phase, 128us nom pulse is a one (96us min - 163us max)  
.................... 	btfss	PORTA, VPW_In		//  wait for the current passive phase to end  
0F4C:  BTFSS  F80.4
.................... 	goto	still_passive		//  if still passive go check that if it has exceeded max time of 163us  
0F4E:  GOTO   0F72
.................... 	movf	TMR0L, W			//  Fetch current value of timer, the duration of this pulse  
0F52:  MOVF   FD6,W
.................... 	movwf	PhaseTime			//  temporarily save it  
0F54:  MOVWF  2A
.................... 	clrf	TMR0L				//  reset the timer to start timing the phase that just started  
0F56:  CLRF   FD6
.................... 	bsf		Act_phase_flag  	//  mark the polarity of this new phase that we just detected  
0F58:  BSF    27.3
.................... 								//  check to see if pulse was too short, under 34us long  
.................... 	movlw 	( 35000 /1600 )		// (desired time in ns)/1.6us cylce time  
0F5A:  MOVLW  15
.................... 	subwf	PhaseTime, W		// subtract from the measured phase time  
0F5C:  SUBWF  2A,W
.................... 	btfss	STATUS, C			//  "C" is set if 34us has been equaled or exceeded  
0F5E:  BTFSS  FD8.0
.................... 	goto	FrError_Exit_v		//  its an error if pulse was too short  
0F60:  GOTO   0FFA
.................... 								//  check if the phase time was less than 96us  
.................... 	movlw 	( 95500 /1600 )		// (desired time in ns)/1.6us cylce time  
0F64:  MOVLW  3B
.................... 	subwf	PhaseTime, W		// subtract from the measured phase time	  
0F66:  SUBWF  2A,W
.................... 	btfss	STATUS, C			//  "C" is set if 96us has been equaled or exceeded		  
0F68:  BTFSS  FD8.0
.................... 	goto	shift_in_a_0_v		//  short passive is a zero  
0F6A:  GOTO   0FB4
.................... 	goto	shift_in_a_1_v		//  long passive is a one  
0F6E:  GOTO   0FBA
....................    
.................... still_passive:  
.................... 								//  check if bus stays passive longer than 164us  
.................... 	movlw 	( 164000 /1600 )	// (desired time in ns)/1.6us cylce time  
0F72:  MOVLW  66
.................... 	subwf	TMR0L, W			// subtract from the current timer value  
0F74:  SUBWF  FD6,W
.................... 	btfss	STATUS, C			//  "C" is set if 163us has been equaled or exceeded  
0F76:  BTFSS  FD8.0
.................... 	goto	passive_phase		//  under 163, loop back & check bus polarity again  
0F78:  GOTO   0F4C
.................... 	goto	end_of_data_ck_v	//  been down for 163us or more, go check if its the end of data	  
0F7C:  GOTO   0FE4
....................   
....................   
.................... active_phase:					//  decode if a one or a zero during this active phase period  
.................... 								//  in active phase, 64us nom pulse is a one (34us min - 96us max)  
.................... 								//  in active phase, 128us nom pulse is a zero (96us min - 163us max)  
.................... 	btfsc	PORTA, VPW_In		//  wait for the current active phase to end  
0F80:  BTFSC  F80.4
.................... 	goto	still_active		//  if still active go check that if it has exceeded max time of 163us  
0F82:  GOTO   0FA6
.................... 	movf	TMR0L, W			//  Fetch current value of timer, the duration of this pulse  
0F86:  MOVF   FD6,W
.................... 	movwf	PhaseTime			//  temporarily save it  
0F88:  MOVWF  2A
.................... 	clrf	TMR0L				//  reset the timer to start timing the phase that just started  
0F8A:  CLRF   FD6
.................... 	bcf		Act_phase_flag  	//  mark the polarity of this new passive phase that we just detected  
0F8C:  BCF    27.3
.................... 								//  check to see if pulse was too short, under 34us long  
.................... 	movlw 	( 33500 /1600 )		// (desired time in ns)/1.6us cylce time  
0F8E:  MOVLW  14
.................... 	subwf	PhaseTime, W		// subtract from the measured phase time  
0F90:  SUBWF  2A,W
.................... 	btfss	STATUS, C			//  "C" is set if 34us has been equaled or exceeded  
0F92:  BTFSS  FD8.0
.................... 	goto	FrError_Exit_v		//  its an error if pulse was too short  
0F94:  GOTO   0FFA
.................... 								//  check if the phase time was less than 96us  
.................... 	movlw 	( 95500 /1600 )		// (desired time in ns)/1.6us cylce time  
0F98:  MOVLW  3B
.................... 	subwf	PhaseTime, W		// subtract from the measured phase time  
0F9A:  SUBWF  2A,W
.................... 	btfss	STATUS, C			//  "C" is set if 96us has been equaled or exceeded		  
0F9C:  BTFSS  FD8.0
.................... 	goto	shift_in_a_1_v		//  short active is a one  
0F9E:  GOTO   0FBA
.................... 	goto	shift_in_a_0_v		//  long passive is a zero  
0FA2:  GOTO   0FB4
....................   
.................... still_active:  
.................... 								//  check if bus stays passive longer than 164us  
.................... 	movlw 	( 164000 /1600 )	// (desired time in ns) /1.6us cylce time  
0FA6:  MOVLW  66
.................... 	subwf	TMR0L, W			// subtract from the current timer value  
0FA8:  SUBWF  FD6,W
.................... 	btfss	STATUS, C			//  "C" is set if 163us has been equaled or exceeded  
0FAA:  BTFSS  FD8.0
.................... 	goto	active_phase		//  under 163, loop back & check bus polarity again  
0FAC:  GOTO   0F80
.................... 	goto	FrError_Exit_v		//  been active for 163us or more, must be an error or Break	  
0FB0:  GOTO   0FFA
....................   
....................    
.................... shift_in_a_0_v:					//  clear C for rotating a zero into register  
.................... 	bcf		STATUS, C  
0FB4:  BCF    FD8.0
.................... 	goto	shift_it_in_v  
0FB6:  GOTO   0FBC
.................... 					  
.................... shift_in_a_1_v:	  
.................... 	bsf		STATUS, C			//  set C for rotating a 1 into register  
0FBA:  BSF    FD8.0
.................... shift_it_in_v:  
.................... 	rlcf	ShiftReg, F			//  rotate the C bit into the LSB position (data comes in MSB first)  
0FBC:  RLCF   28,F
.................... 								//  after 8 rotations, the first bit in will be in the MSB position  
.................... 	btfss	STATUS, C			//  register is full when the preset one bit comes out  
0FBE:  BTFSS  FD8.0
.................... 	goto	get_nxt_bit_v	  	//  branch if register not full yet  
0FC0:  GOTO   0FDA
.................... 								//  shift register is full, save the byte  
....................   
.................... 	incf	BusByteCntr, F		//  add one to the received bytes count  
0FC4:  INCF   2B,F
.................... 	movlw	VEHICLE_MSG_SIZE+1	//  check if we have exceeded the maximum of 12 bytes  
0FC6:  MOVLW  0D
.................... 	subwf	BusByteCntr, W  
0FC8:  SUBWF  2B,W
.................... 	btfsc	STATUS, C			//  'C' will be set when we are over maximum record length  
0FCA:  BTFSC  FD8.0
.................... 	goto	MsgLen_Exit_v		//  its an error if we are over the msg size limit  
0FCC:  GOTO   0FEE
....................   
.................... 	movf	ShiftReg, W			// shift register is full, save the accumulated byte to RxBuffer  
0FD0:  MOVF   28,W
.................... 	movwf	INDF0  
0FD2:  MOVWF  FEF
.................... 	incf	FSR0L, F			//  advance indirect memory pointer to next byte	  
0FD4:  INCF   FE9,F
.................... 	movlw	0b00000001			//  prime the RxBuffer byte as a shift register  
0FD6:  MOVLW  01
.................... 	movwf	ShiftReg			//  indirect write to the buffer  
0FD8:  MOVWF  28
....................   
.................... get_nxt_bit_v:  
.................... 	btfss	Act_phase_flag  	//  branch to either active or passive phase bit decode  
0FDA:  BTFSS  27.3
.................... 	goto	passive_phase		//  in VPW acive & passive phases alternate on every bit  
0FDC:  GOTO   0F4C
.................... 	goto	active_phase  
0FE0:  GOTO   0F80
....................    
.................... end_of_data_ck_v:				  
.................... 	bsf		MsgRecvd			//  set the message received flag  
0FE4:  BSF    26.0
.................... 	bsf		EOD					//  set the end of data flag  
0FE6:  BSF    27.0
.................... // ***  Following Statements Removed to elliminate In-Frame Response Checking ****  
.................... // ***  Per discussion with David 8-13-2002  
.................... //InFrame_Ck_v:					//  now lets check if there is an inframe response  
.................... //	btfsc	PORTA, VPW_In		//  check to see if inframe response active phase shows up			  
.................... //	goto 	Ck_InFrame_Status_v	//  executes this inst if bus goes back active  
.................... //								//  check if bus stays passive longer than 239us  
.................... //	movlw 	( 239000 /1600 )	// (desired time in ns)/1.6us cylce time  
.................... //	subwf	TMR0L, W			// subtract from the current timer value  
.................... //	btfss	STATUS, C			//  "C" is set if 239us has been equaled or exceeded  
.................... //	goto	InFrame_Ck_v		//  loop back & wait until bus is inactive for 239us  
.................... // ***  
.................... 	bsf		EOF					//  we have identified an end of frame  
0FE8:  BSF    27.1
.................... 	goto	VPW_RX_Exit			//  return to the calling "C" application  
0FEA:  GOTO   0FFC
.................... 	  
....................   
.................... // ***  Following Statements Removed to elliminate In-Frame Response Checking ****  
.................... // ***  Per discussion with David 8-13-2002   
.................... //Ck_InFrame_Status_v:  
.................... //	clrf	TMR0L				//  restart timer0 to start timing 1st inframe response bit  
.................... //	btfsc	InFrResp			//  test if we have already detected an inframe response  
.................... //	goto	FrError_Exit_v		//  this is an error if already found an inframe response  
.................... //	bsf		InFrResp 			//  Set the inframe response detected status flag  
.................... //   
.................... //wait_NB_done:					//  wait for the VPW normalization bit to end (throw it away)  
.................... //	btfss	PORTA, VPW_In  
.................... //	goto	NB_done  
.................... //								//  test to make sure the maximum pulse time of 96us is not exceeded  
.................... //	movlw 	( 99000 /1600 )		// (desired time in ns)/1.6us cylce time  
.................... //	subwf	TMR0L, W			// subtract from the current timer value  
.................... //	btfsc	STATUS, C			//  "C" is set if 99us has been equaled or exceeded  
.................... //	goto	FrError_Exit_v		//  take error exit if pulse is too long  
.................... //	goto	wait_NB_done		//  loop until pulse ends  
.................... //  
.................... //  
.................... //NB_done:						//  the NB terminated, now lets make sure it was correct duration  
.................... //								//  its an error if bus was active less than 34us  
.................... //	movlw 	( 33000 )/1600 )	// (desired time in ns)/1.6us cylce time  
.................... //	subwf	TMR0L, W			// subtract from the current timer value  
.................... //	btfss	STATUS, C			//  "C" is set if 34us has been equaled or exceeded  
.................... //	goto	FrError_Exit_v		//  take error exit if too short	  
.................... //	goto	get_inframe_response_v	//  go receive the inframe message  
.................... // ****  
....................   
.................... MsgLen_Exit_v:  
.................... 	bsf		MsgOverflow			// set overflow error flag in link control register	  
0FEE:  BSF    26.4
.................... 	goto	VPW_RX_Exit  
0FF0:  GOTO   0FFC
.................... 	  
.................... Rx_BusInactivityExit:  
.................... 	bsf		NoBusActivity		// set the error flag bit in LinkControl  
0FF4:  BSF    26.5
.................... 	goto	VPW_RX_Exit			// error exit if bus is stuck busy  
0FF6:  GOTO   0FFC
....................   
.................... FrError_Exit_v:					//  time exceeded or other problem if we get here  
.................... 	bsf		FrError 			//  set framing error flag in control register  
0FFA:  BSF    26.1
.................... VPW_RX_Exit:  
.................... //	movff	BSR_temp, BSR		// Restore setting of Bank Select Register  
.................... 	#endasm  
....................   
.................... 	*RxCntPntr = BusByteCntr;	// return count of received bytes  
0FFC:  MOVLB  2
0FFE:  MOVF   x40,W
1000:  MOVWF  FE9
1002:  MOVLB  0
1004:  MOVFF  241,FEA
1008:  MOVFF  2B,FEF
.................... 	return LinkControl;			// return status for the calling application  
100C:  MOVF   26,W
100E:  MOVWF  01
.................... }		  
1010:  GOTO   128E (RETURN)
....................    
.................... // ###################################################################  
.................... // ***************  Entry for VPW Transmit Routine  ******************	  
.................... //  
.................... int8 VPWSend (int16* TxBufferPntr, int8 VPWTxCnt, int8 timeout) {  
.................... 	BusTimeOut = timeout;   	// Maximum Bus Inactivity Time Out Counter   
*
0B72:  MOVFF  216,2E
.................... 								// approx 2 msec per count  
....................     #asm  
....................     lost_arbitration_v2:		// internal, lost arbitration re-entry point  
....................     #endasm  
....................       
.................... 	Bus_If_Init(); 				// Initialize local variables & timers  
0B76:  CALL   0B58
.................... 	BusBuffPntr = TxBufferPntr;  
0B7A:  MOVFF  214,30
0B7E:  MOVFF  213,2F
.................... 	BusBuffPntr_low = make8(BusBuffPntr, 0);  // load the pointer address for indirect addressing  
0B82:  MOVF   2F,W
0B84:  MOVWF  2C
.................... 	BusBuffPntr_high = make8(BusBuffPntr, 1);  
0B86:  MOVF   30,W
0B88:  MOVWF  2D
....................   
.................... 	#asm  
.................... //	movff	BSR_temp, BSR		// Save current setting of Bank Select Register  
.................... //	movlb	0					//Set BSR to bank zero  
.................... 	movff	BusBuffPntr_low, FSR0L  
0B8A:  MOVFF  2C,FE9
.................... 	movff	BusBuffPntr_high, FSR0H  
0B8E:  MOVFF  2D,FEA
.................... 	#endasm  
....................   
.................... 	BusByteCntr = VPWTxCnt;		// load the the TxCnt (being pointed at)  
0B92:  MOVFF  215,2B
....................   
.................... 	setup_timer_0( RTCC_INTERNAL | RTCC_DIV_8 ); // initialize timer0 to run at 200ns / count  
0B96:  MOVLW  82
0B98:  MOVWF  FD5
....................   
.................... 	#asm  
.................... 	bcf		PIR1, TMR2IF		// make sure timer 2 overflow bit is reset  
0B9A:  BCF    F9E.1
.................... EOF_wait1_v:  
.................... 	btfss	PIR1, TMR2IF  
0B9C:  BTFSS  F9E.1
.................... 	goto	EOF_wait3_v			// jump if timer has not timed out yet  
0B9E:  GOTO   0BAE
.................... 	bcf		PIR1, TMR2IF  
0BA2:  BCF    F9E.1
.................... 	movf	BusTimeOut, f		// check if Bus Access has timed out	  
0BA4:  MOVF   2E,F
.................... 	btfsc	STATUS, Z  
0BA6:  BTFSC  FD8.2
.................... 	goto	TxBusBusyExit_v		// error exit if bus is stuck busy  
0BA8:  GOTO   0CA4
.................... 	decf	BusTimeOut, f		// sub one timer tick from timeout count  
0BAC:  DECF   2E,F
....................   
.................... EOF_wait3_v:  
.................... 	clrf	TMR0L				// restart timer  
0BAE:  CLRF   FD6
.................... EOF_wait2_v:  
.................... 	btfsc	PORTA, VPW_In		// skips next when bus is inactive  
0BB0:  BTFSC  F80.4
.................... 	goto	EOF_wait1_v			// loop back until we see an inactive bus  
0BB2:  GOTO   0B9C
....................   
.................... 								// check if bus stays passive longer than 239us for EOF  
.................... 	movlw 	( 239000 /1600 )	// (desired time in ns)/1.6us cylce time  
0BB6:  MOVLW  95
.................... 	subwf	TMR0L, W			// subtract from the current timer value  
0BB8:  SUBWF  FD6,W
.................... 	btfss	STATUS, C			// "C" is set if 239us has been equaled or exceeded  
0BBA:  BTFSS  FD8.0
.................... 	goto	EOF_wait2_v			// loop as long as passive  
0BBC:  GOTO   0BB0
....................   
.................... IFS_wait_v:						// End of Frame found, now check if anyone else starts  
.................... 								// after 239 us, if any other node sends a SOF, we can  
.................... 								// put one out as well, even before the 300us IFS is up  
.................... 	btfsc	PORTA, VPW_In		// executes next inst is bus goes active again  
0BC0:  BTFSC  F80.4
.................... 	goto	strt_transmission_v	// branch out if bus goes active  
0BC2:  GOTO   0BD0
.................... 								// check if bus stays passive longer than 300us for IFS  
.................... 	movlw 	( 300000 /1600 )	// (desired time in ns)/1.6us cylce time  
0BC6:  MOVLW  BB
.................... 	subwf	TMR0L, W			// subtract from the current timer value  
0BC8:  SUBWF  FD6,W
.................... 	btfss	STATUS, C			// "C" is set if 300us has been equaled or exceeded  
0BCA:  BTFSS  FD8.0
.................... 	goto	IFS_wait_v			// continue checking til a SOF shows up, or the 300 us times out  
0BCC:  GOTO   0BC0
....................   
.................... strt_transmission_v:			// we have seen a SOF or the 300us IFS time has expired  
.................... 								// in either case, we now drive our own 200us SOF pulse  
.................... 	clrf	TMR0L				// restart the timer  
0BD0:  CLRF   FD6
.................... 	bsf		PORTB, VPW_Out		// drive VPW BUS active  
0BD2:  BSF    F81.1
.................... 	  
.................... SOF_delay_v:  
.................... 								// Leave bus active for 200us  
.................... 	movlw 	( 200000 /1600 )	// (desired time in ns)/1.6us cylce time  
0BD4:  MOVLW  7D
.................... 	subwf	TMR0L, W			// subtract from the current timer value  
0BD6:  SUBWF  FD6,W
.................... 	btfss	STATUS, C			// "C" is set if 32us has been equaled or exceeded  
0BD8:  BTFSS  FD8.0
.................... 	goto	SOF_delay_v			// drive the SOF pulse for the full 200us  
0BDA:  GOTO   0BD4
....................   
.................... 	bcf		PORTB, VPW_Out		// drive BUS passive to terminate SOF pulse  
0BDE:  BCF    F81.1
.................... 	clrf	TMR0L				// restart the timer  
0BE0:  CLRF   FD6
....................   
.................... start_sending_bits_v:  
.................... settle_delay_v:					// allow the bus to settle, per Moto 33390 spec should be 17.7us max  
.................... 								// allow 21us settle time for bus to go passive  
.................... 	movlw 	( 21000 /1600 )		// (desired time in ns)/1.6us cylce time  
0BE2:  MOVLW  0D
.................... 	subwf	TMR0L, W			// subtract from the current timer value  
0BE4:  SUBWF  FD6,W
.................... 	btfss	STATUS, C			// "C" is set if 35us has been equaled or exceeded  
0BE6:  BTFSS  FD8.0
.................... 	goto	settle_delay_v		// wait the 21 us settle time  
0BE8:  GOTO   0BE2
....................   
.................... 	btfsc	PORTA, VPW_In		// skips next inst if bus is still passive  
0BEC:  BTFSC  F80.4
.................... 	goto	lost_arbitration_v	// Oh-oh, the bus is being driven, we loose arbitration				  
0BEE:  GOTO   0C38
.................... 								// get the first bit to transmit  
....................  	bcf		NxtBit				// NxtBit is already zero because of being reset at start  
0BF2:  BCF    27.2
.................... 	btfsc	INDF0, 7			// test the MSbit of the first byte in the buffer  
0BF4:  BTFSC  FEF.7
.................... 	bsf		NxtBit				// if the MSB wasn't a zero, set a one into NxtBit  
0BF6:  BSF    27.2
....................   
.................... TX_passive_phase:  
.................... 	btfsc	NxtBit				// Check if next bit is a zero or a one  
0BF8:  BTFSC  27.2
.................... 	goto	passive_1			// branch if its a one  
0BFA:  GOTO   0C20
.................... passive_0:  
.................... 	call	get_next_bit_v		// setup the next bit to be transmitted  
0BFE:  CALL   0C7C
.................... passive_0_ck:  
.................... 	btfsc	PORTA, VPW_In		// check if someone else may be driving the bus  
0C02:  BTFSC  F80.4
.................... 	goto	lost_arbitration_v	// exit routine if someone else is driving the bus  
0C04:  GOTO   0C38
.................... 								// leave bus active for 64us for a passive 0 pulse  
.................... 	movlw 	( 64000 /1600 )		// (desired time in ns)/1.6us cylce time  
0C08:  MOVLW  28
.................... 	subwf	TMR0L, W			// subtract from the current timer value  
0C0A:  SUBWF  FD6,W
.................... 	btfss	STATUS, C			// "C" is set when 64us has been equaled or exceeded  
0C0C:  BTFSS  FD8.0
.................... 	goto	passive_0_ck		// loop until pulse is finished  
0C0E:  GOTO   0C02
....................    
.................... end_passive:  
.................... 	btfsc	MsgSent				//  test if we are done transmitting before driving bus active  
0C12:  BTFSC  26.3
.................... 	goto	VPW_TX_end_of_data  //  go execute end of data routine if done  
0C14:  GOTO   0CAE
.................... 	clrf	TMR0L				//  reset the timer  
0C18:  CLRF   FD6
.................... 	bsf		PORTB, VPW_Out		//  set the bus active for next phase  
0C1A:  BSF    F81.1
.................... 	goto	TX_active_phase		//  now lets continue with the active phase  
0C1C:  GOTO   0C42
....................    
.................... passive_1:  
.................... 	call	get_next_bit_v		//  setup the next bit to be transmitted  
0C20:  CALL   0C7C
.................... passive_1_ck:  
.................... 	btfsc	PORTA, VPW_In		//  check if someone else may be driving the bus  
0C24:  BTFSC  F80.4
.................... 	goto	lost_arbitration_v	//  exit routine if someone else is driving the bus  
0C26:  GOTO   0C38
.................... 								//  leave bus passive for 128us for a passive 1 pulse  
.................... 	movlw 	( 128000 /1600 )	// (desired time in ns)/1.6us cylce time  
0C2A:  MOVLW  50
.................... 	subwf	TMR0L, W			// subtract from the current timer value  
0C2C:  SUBWF  FD6,W
.................... 	btfss	STATUS, C			//  "C" is set when 128us has been equaled or exceeded  
0C2E:  BTFSS  FD8.0
.................... 	goto	passive_1_ck		//  loop until pulse is finished  
0C30:  GOTO   0C24
.................... 	goto	end_passive			//  go get ready for next phase	  
0C34:  GOTO   0C12
....................    
.................... lost_arbitration_v:  
.................... 	movf	BusTimeOut, f		// Check the bus access time out count to see  
0C38:  MOVF   2E,F
.................... 	btfss	STATUS, Z			// if its already zero	  
0C3A:  BTFSS  FD8.2
.................... 	decf	BusTimeOut, f		// reduce bus time out on each lost arbitration cycle  
0C3C:  DECF   2E,F
.................... 	goto	lost_arbitration_v2	  
0C3E:  GOTO   0B76
....................    
.................... TX_active_phase:  
.................... 	btfsc	NxtBit				//  Check if next bit is a zero or a one  
0C42:  BTFSC  27.2
.................... 	goto	active_1			//  branch if its a one  
0C44:  GOTO   0C6E
.................... active_0:  
.................... 								//  drive bus active for 128us for an active 0 pulse  
.................... 	movlw 	( 128000 /1600 )	// (desired time in ns)/1.6us cylce time  
0C48:  MOVLW  50
.................... 	subwf	TMR0L, W			// subtract from the current timer value  
0C4A:  SUBWF  FD6,W
.................... 	btfss	STATUS, C			//  "C" is set when 128us has been equaled or exceeded  
0C4C:  BTFSS  FD8.0
.................... 	goto	active_0			//  loop until pulse is finished  
0C4E:  GOTO   0C48
....................    
.................... end_active:  
.................... 	clrf	TMR0L				//  reset the timer  
0C52:  CLRF   FD6
.................... 	bcf		PORTB, VPW_Out		//  set the bus passive for next phase  
0C54:  BCF    F81.1
.................... 	call	get_next_bit_v		//  setup the next bit to be transmitted  
0C56:  CALL   0C7C
.................... 	btfsc	MsgSent				//  test if we are done transmitting yet  
0C5A:  BTFSC  26.3
.................... 	goto	VPW_TX_end_of_data	//  go execute end of data routine if done  
0C5C:  GOTO   0CAE
.................... passive_delay_v:				//  allow the bus to settle, per Moto 33390 spec should be 17.7us max  
.................... 								//  allow 21us settle time for bus to go passive  
.................... 	movlw 	( 21000 /1600 )		// (desired time in ns)/1.6us cylce time  
0C60:  MOVLW  0D
.................... 	subwf	TMR0L, W			// subtract from the current timer value  
0C62:  SUBWF  FD6,W
.................... 	btfss	STATUS, C			//  "C" is set if 21us has been equaled or exceeded  
0C64:  BTFSS  FD8.0
.................... 	goto	passive_delay_v		//  wait the 21 us settle time before testing for lost arbitration  
0C66:  GOTO   0C60
.................... 	goto	TX_passive_phase	//  now lets continue with the passive phase  
0C6A:  GOTO   0BF8
....................    
.................... active_1:  
.................... 								//  drive bus active for 64us for an active 1 pulse  
.................... 	movlw 	( 64000 /1600 )		// (desired time in ns)/1.6us cylce time  
0C6E:  MOVLW  28
.................... 	subwf	TMR0L, W			// subtract from the current timer value  
0C70:  SUBWF  FD6,W
.................... 	btfss	STATUS, C			//  "C" is set when 64us has been equaled or exceeded  
0C72:  BTFSS  FD8.0
.................... 	goto	active_1			//  loop until pulse is finished  
0C74:  GOTO   0C6E
.................... 	goto	end_active			//  go get ready for next phase	  
0C78:  GOTO   0C52
....................    
.................... get_next_bit_v:					//  get next bit to transmit  
.................... 	bcf		STATUS, C			//  make sure 'C' bit is clear before rotating  
0C7C:  BCF    FD8.0
.................... 	rrcf	MaskReg, F			//  Move Mask to next bit position  
0C7E:  RRCF   29,F
.................... 	btfsc	STATUS, C			//  if C is set, the entire byte has been sent  
0C80:  BTFSC  FD8.0
.................... 	goto	get_next_byte_v		//  setup the next byte  
0C82:  GOTO   0C92
.................... test_the_bit_v:					//  check if the masked bit is a one or a zero  
.................... 	movf	MaskReg, W			//  fetch the Mask Register  
0C86:  MOVF   29,W
.................... 	andwf	INDF0, W			//  and the mask with current byte being transmitted (indirect)  
0C88:  ANDWF  FEF,W
.................... 	bcf		NxtBit  
0C8A:  BCF    27.2
.................... 	btfss	STATUS, Z			//  skip next instruction if bit was a zero  
0C8C:  BTFSS  FD8.2
.................... 	bsf		NxtBit				//  NxtBit is now set up for the next bit to be sent  
0C8E:  BSF    27.2
.................... 	return  
0C90:  RETURN 0
....................    
.................... get_next_byte_v:  
.................... 	incf	FSR0L, F			//  increment the TX buffer pointer  
0C92:  INCF   FE9,F
.................... 	decf	BusByteCntr, F		//  sub one from the count of bytes to be sent  
0C94:  DECF   2B,F
.................... 	btfsc	STATUS, Z			//  have we sent them all yet  
0C96:  BTFSC  FD8.2
.................... 	goto	all_sent_v			//  exit loop if we are done sending  
0C98:  GOTO   0CAA
.................... 	movlw	0x80  
0C9C:  MOVLW  80
.................... 	movwf	MaskReg				//  put a one back into the MSB position  
0C9E:  MOVWF  29
.................... 	goto	test_the_bit_v		//  setup NxtBit for the MSB bit of this new byte  
0CA0:  GOTO   0C86
....................   
.................... TxBusBusyExit_v:  
.................... 	bsf		NoBusActivity		// set the error flag bit in LinkControl  
0CA4:  BSF    26.5
.................... 	goto	TxErrorExit_v			  
0CA6:  GOTO   0CB2
....................    
.................... all_sent_v:  
.................... 	bsf		MsgSent				//  set the Message Sent Flag  
0CAA:  BSF    26.3
.................... 								//  Support for in-frame response was removed per David  
.................... //	movlw	RxBuffer  
.................... //	movwf	FSR0L				//  setup RxBuffer pointer in case of in-frame response  
.................... //	movlw	0b00000001			//  prime first RxBuffer byte as a shift register  
.................... //	movwf	INDF0  
.................... 	return  
0CAC:  RETURN 0
....................   
.................... VPW_TX_end_of_data:  
.................... 	bsf		EOD					//  set the end of data flag  
0CAE:  BSF    27.0
.................... 	bsf		EOF					//  set end of frame flag  
0CB0:  BSF    27.1
.................... TxErrorExit_v:  
.................... //	movff	BSR_temp, BSR		// Restore setting of Bank Select Register  
.................... 	#endasm  
....................   
.................... 	return LinkControl;			// return status for the calling application  
0CB2:  MOVF   26,W
0CB4:  MOVWF  01
.................... }	   
0CB6:  GOTO   0E90 (RETURN)
.................... 								  
....................    
.................... // ##############   End of vpw-xx.c    ########################  
....................   
....................   
....................  
.................... #include "CAN18XX8.c" 
....................  /*********************************************************************  
....................  *  
....................  *              PIC18CXX8 CAN C Library Source Code  
....................  *  
....................  *********************************************************************  
....................  * FileName:        CAN18CXX8.C  
....................  * Dependencies:    CAN18CXX8.h  
....................  * Date:            09/06/00  
....................  * Processor:       PIC18CXX8  
....................  * Complier:        MPLAB 5.11.00    
....................  *                 (**bcl Sept 16, 2003 - changed to CCS C compiler)  
....................  * Company:         Microchip Technology, Inc.  
....................  *  
....................  * Software License Agreement  
....................  *  
....................  * The software supplied herewith by Microchip Technology Incorporated  
....................  * (the Company) for its PICmicro Microcontroller is intended and  
....................  * supplied to you, the Companys customer, for use solely and  
....................  * exclusively on Microchip PICmicro Microcontroller products. The  
....................  * software is owned by the Company and/or its supplier, and is  
....................  * protected under applicable copyright laws. All rights are reserved.  
....................  * Any use in violation of the foregoing restrictions may subject the  
....................  * user to criminal sanctions under applicable laws, as well as to  
....................  * civil liability for the breach of the terms and conditions of this  
....................  * license.  
....................  *  
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,  
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED  
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,  
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR  
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.  
....................  *  
....................  * Author               Date    Comment  
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
....................  * Nilesh Rajbharti     9/6/00  Original        (Rev 1.0)  
....................  * Nilesh Rajbharti     12/1/00 Fixed bugs.  
....................  *                              (CANRegsToID, CANReceiveMessage,  
....................  *                               CANSetMask + Added  
....................  *                               CAN_CONFIG_DBL_BUFFER_ON/OFF option)  
....................  * Nilesh Rajbharti     6/8/01  Renamed CAN_CONFIG_DBL_BUFFERED to  
....................  *                              CAN_RX_DBL_BUFFERED  
....................  *  
....................  * Nilesh Rajbharti     6/5/02  Modified RXB0DLC_RTR def to fix compiler  
....................  *                              missing def problem.  
....................  *                              Fixed CANIDToRegs() where "static"  
....................  *                              mode would not compile.  (Rev 1.2)  
....................  *  
....................  * Bernie Lafreniere	8/16/03 Start porting driver to run on CCS C with  
....................  *								the PIC18F248 processor.  
....................  *  
....................  ********************************************************************/  
....................   
.................... /*  
....................  * Private helper functions to convert 32-bit CAN ID value into  
....................  * corresponding PIC18CXX8 registers and vice-versa.  
....................  */  
....................   
.................... /*static void CANIDToRegs(BYTE* ptr,  
....................                         int32 val,  
....................                         BYTE config_flags);  
.................... static void RegsToCANID(BYTE* ptr,  
....................                         int32 *val,  
....................                         BYTE config_flags);  
....................   
.................... */  
....................   
.................... #include "CAN18XX8.h"	// CAN interface driver 
....................  /*********************************************************************  
....................  *              PIC18CXX8 CAN C Library Header File  
....................  *********************************************************************  
....................  * FileName:        CAN18CXX8.h  
....................  * Dependencies:    None  
....................  * Date:            09/06/00  
....................  * Processor:       PIC18CXX8  
....................  * Complier:        MPLAB 5.11.00  
....................  * Company:         Microchip Technology, Inc.  
....................  *  
....................  *  
....................  * Software License Agreement  
....................  *  
....................  * The software supplied herewith by Microchip Technology Incorporated  
....................  * (the Company) for its PICmicro Microcontroller is intended and  
....................  * supplied to you, the Companys customer, for use solely and  
....................  * exclusively on Microchip PICmicro Microcontroller products. The  
....................  * software is owned by the Company and/or its supplier, and is  
....................  * protected under applicable copyright laws. All rights are reserved.  
....................  *  Any use in violation of the foregoing restrictions may subject the  
....................  * user to criminal sanctions under applicable laws, as well as to  
....................  * civil liability for the breach of the terms and conditions of this  
....................  * license.  
....................  *  
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,  
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED  
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,  
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR  
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.  
....................  *  
....................  * Author               Date    Comment  
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
....................  * Nilesh Rajbharti     9/6/00  Original        (Rev 1.0)  
....................  * Nilesh Rajbharti     12/1/00 Fixed bugs.  
....................  *                              (CANRegsToID, CANReceiveMessage,  
....................  *                               CANSetMask + Added  
....................  *                               CAN_CONFIG_DBL_BUFFER_ON/OFF option)  
....................  * Nilesh Rajbharti     6/8/01  Renamed CAN_CONFIG_DBL_BUFFERED to  
....................  *                              CAN_RX_DBL_BUFFERED  
....................  *  
....................  * Bernie Lafreniere	8/16/03 Start porting driver to run on CCS C with  
....................  *								the PIC18F248 processor.  
....................  *  
....................  *********************************************************************/  
.................... #ifndef CAN18XX8_H          // To avoid duplicate inclusion  
.................... #define CAN18XX8_H  
....................   
.................... #bit RXB0CON_RX0DBEN    = RXB0CON.2	// PIC18XX8 CAN register.bit mapping  
.................... #bit RXB0CON_RXFUL      = RXB0CON.7  
.................... #bit RXB1CON_RXFUL      = RXB1CON.7  
.................... #bit TXB0CON_TXREQ      = TXB0CON.3  
....................   
.................... #bit TXB1CON_TXPRI0     = TXB1CON.0  
.................... #bit TXB1CON_TXPRI1     = TXB1CON.1  
.................... #bit TXB1CON_TXREQ      = TXB1CON.3  
.................... #bit TXB1CON_TXERR      = TXB1CON.4  
.................... #bit TXB1CON_TXLARB     = TXB1CON.5  
.................... #bit TXB1CON_TXABT      = TXB1CON.6  
....................   
.................... #bit TXB2CON_TXPRI0     = TXB2CON.0  
.................... #bit TXB2CON_TXPRI1     = TXB2CON.1  
.................... #bit TXB2CON_TXREQ      = TXB2CON.3  
.................... #bit TXB2CON_TXERR      = TXB2CON.4  
.................... #bit TXB2CON_TXLARB     = TXB2CON.5  
.................... #bit TXB2CON_TXABT      = TXB2CON.6  
....................   
.................... #bit BRGCON2_SAM        = BRGCON2.6  
.................... #bit BRGCON2_SEG2PHTS   = BRGCON2.7  
.................... #bit BRGCON3_WAKFIL     = BRGCON3.6  
.................... #bit PIR3_RXB0IF        = PIR3.0  
.................... #bit PIR3_RXB1IF        = PIR3.1  
.................... #bit PIR3_IRXIF         = PIR3.7  
.................... #bit COMSTAT_TXB0       = COMSTAT.5  
.................... #bit COMSTAT_TXBP       = COMSTAT.4  
.................... #bit COMSTAT_RXBP       = COMSTAT.3  
.................... #bit COMSTAT_RX1OVFL    = COMSTAT.6  
.................... #bit COMSTAT_RX0OVFL    = COMSTAT.7  
.................... #bit RXB0DLC_RTR        = RXB0DLC.6  
.................... #bit RXB0SIDL_EXID      = RXB0SIDL.3  
.................... #bit CANCON_ABAT        = CANCON.4  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  *  
....................  * union CAN_MESSAGE_ID  
....................  *  
....................  * This union provides abstract data type for CAN message id.  
....................  * It is used for both 11-bit and 29-bit message identifiers.  
....................  * There are multiple union members to be able to access individual  
....................  * parts of it.  
....................  *  
....................  ********************************************************************/  
....................  // Parse-out 29-bit or 11-bit (saved in 32-bit number)  
.................... typedef union _CAN_MESSAGE_ID  
.................... {  
....................     int32 ID;  
....................   
....................     struct  
....................     {  
....................         struct  
....................         {  
....................             int8 SIDL:3;        // SIDL<5:7>  
....................             int8 SIDH:5;        // SIDH<0:4>  
....................         } BYTE1;  
....................         struct  
....................         {  
....................             int8 SIDHU:3;       // SIDH<5:7>  
....................             int8 EIDL_LN:5;     // EIDL<0:4>  
....................         } BYTE2;  
....................         struct  
....................         {  
....................             int8 EIDL_UN:3;     // EIDL<5:7>  
....................             int8 EIDH_LN:5;     // EIDH<0:4>  
....................         } BYTE3;  
....................         struct  
....................         {  
....................             int8 EIDH_UN:3;     // EIDH<5:7>  
....................             int8 EIDHU:2;       // SIDL<0:1>  
....................             int8 PAD:3;			// bcl added name "PAD" to make CCS happy  
....................         } BYTE4;  
....................     } ID_VALS;  
....................   
....................     // This is to allow individual byte access within message id.  
....................     struct  
....................     {  
....................         BYTE BYTE_1;  
....................         BYTE BYTE_2;  
....................         BYTE BYTE_3;  
....................         BYTE BYTE_4;  
....................     } BYTES;  
.................... } CAN_MESSAGE_ID;  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  *  
....................  * enum CAN_TX_MSG_FLAGS  
....................  *  
....................  * This enumeration values define flags related to transmission of a  
....................  * CAN message.  There could be more than one this flag  
....................  * ANDed together to form multiple flags.  
....................  *  
....................  *********************************************************************/  
....................  typedef enum CAN_TX_MSG_FLAGS  
....................  {  
....................     CAN_TX_PRIORITY_BITS= 0b00000011,  
....................     CAN_TX_PRIORITY_0   = 0b11111100,   // XXXXXX00  
....................     CAN_TX_PRIORITY_1   = 0b11111101,   // XXXXXX01  
....................     CAN_TX_PRIORITY_2   = 0b11111110,   // XXXXXX10  
....................     CAN_TX_PRIORITY_3   = 0b11111111,   // XXXXXX11  
....................   
....................     CAN_TX_FRAME_BIT    = 0b00001000,  
....................     CAN_TX_STD_FRAME    = 0b11111111,   // XXXXX1XX  
....................     CAN_TX_XTD_FRAME    = 0b11110111,   // XXXXX0XX  
....................   
....................     CAN_TX_RTR_BIT      = 0b01000000,  
....................     CAN_TX_NO_RTR_FRAME = 0b11111111,   // X1XXXXXX  
....................     CAN_TX_RTR_FRAME    = 0b10111111    // X0XXXXXX  
.................... };  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  *  
....................  * enum CAN_RX_MSG_FLAGS  
....................  *  
....................  * These enumeration values define flags related to reception of a CAN  
....................  * message.  There could be more than one these flags  
....................  * ANDed together to form multiple flags.  
....................  * If a particular bit is set, corresponding meaning is TRUE or else  
....................  * it will be FALSE.  
....................  *  
....................  * e.g.  
....................  *      if (MsgFlag & CAN_RX_OVERFLOW)  
....................  *      {  
....................  *          // Receiver overflow has occured.  We have lost previous  
....................  *          // message.  
....................  *          ...  
....................  *      }  
....................  *  
....................  ********************************************************************/  
.................... typedef enum CAN_RX_MSG_FLAGS  
.................... {  
....................     CAN_RX_FILTER_BITS  = 0b00000111,   // Use this to access filter  
....................                                         // bits  
....................     CAN_RX_FILTER_1     = 0b00000000,  
....................     CAN_RX_FILTER_2     = 0b00000001,  
....................     CAN_RX_FILTER_3     = 0b00000010,  
....................     CAN_RX_FILTER_4     = 0b00000011,  
....................     CAN_RX_FILTER_5     = 0b00000100,  
....................     CAN_RX_FILTER_6     = 0b00000101,  
....................   
....................     CAN_RX_OVERFLOW     = 0b00001000,   // Set if Overflowed else  
....................                                         // cleared  
....................   
....................     CAN_RX_INVALID_MSG  = 0b00010000,   // Set if invalid else  
....................                                         // cleared  
....................   
....................     CAN_RX_XTD_FRAME    = 0b00100000,   // Set if XTD message else  
....................                                         // cleared  
....................   
....................     CAN_RX_RTR_FRAME    = 0b01000000,   // Set if RTR message else  
....................                                         // cleared  
....................   
....................     CAN_RX_DBL_BUFFERED = 0b10000000    // Set if this message was  
....................                                         // hardware double-buffered  
.................... };  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
....................   
.................... /*********************************************************************  
....................  *  
....................  * enum CAN_MASK  
....................  *  
....................  * These enumeration values define mask codes.  Routine CANSetMask()  
....................  * requires this code as one of its arguments.  These enumerations  
....................  * must be used by itself i.e. it cannot be ANDed to form multiple  
....................  * values.  
....................  *  
....................  ********************************************************************/  
.................... typedef enum CAN_MASK  
.................... {  
....................      CAN_MASK_B1,  
....................      CAN_MASK_B2  
.................... };  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  *  
....................  * enum CAN_FILTER  
....................  *  
....................  * These enumeration values define filter codes.  Routine CANSetFilter  
....................  * requires this code as one of its arguments.  These enumerations  
....................  * must be used by itself  
....................  * i.e. it cannot be ANDed to form multiple values.  
....................  *  
....................  ********************************************************************/  
.................... typedef enum CAN_FILTER  
.................... {  
....................     CAN_FILTER_B1_F1,  
....................     CAN_FILTER_B1_F2,  
....................     CAN_FILTER_B2_F1,  
....................     CAN_FILTER_B2_F2,  
....................     CAN_FILTER_B2_F3,  
....................     CAN_FILTER_B2_F4  
.................... };  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  *  
....................  * enum CAN_OP_MODE  
....................  *  
....................  * This enumeration values define codes related to CAN module  
....................  * operation mode. CANSetOperationMode() routine requires this code.  
....................  * These values must be used by itself  
....................  * i.e. it cannot be ANDed to form * multiple values.  
....................  *  
....................  ********************************************************************/  
.................... typedef enum CAN_OP_MODE  
.................... {  
....................     CAN_OP_MODE_BITS    = 0b11100000,   // Use this to access opmode  
....................                                         // bits  
....................     CAN_OP_MODE_NORMAL  = 0b00000000,  
....................     CAN_OP_MODE_SLEEP   = 0b00100000,  
....................     CAN_OP_MODE_LOOP    = 0b01000000,  
....................     CAN_OP_MODE_LISTEN  = 0b01100000,  
....................     CAN_OP_MODE_CONFIG  = 0b10000000  
.................... };  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  *  
....................  * enum CAN_CONFIG_FLAGS  
....................  *  
....................  * These enumeration values define flags related to configuring the CAN  
....................  * module. Routines CANInitialize() and CANSetBaudRate() use these  
....................  * codes. One or more of these values may be ANDed to form multiple  
....................  * flags.  
....................  *  
....................  ********************************************************************/  
.................... //typedef enum CAN_CONFIG_FLAGS  
.................... //{  
.................... #define    CAN_CONFIG_DEFAULT           0b11111111,   // 11111111  
....................   
.................... #define    CAN_CONFIG_PHSEG2_PRG_BIT    0b00000001  
.................... #define    CAN_CONFIG_PHSEG2_PRG_ON     0b11111111   // XXXXXXX1  
.................... #define    CAN_CONFIG_PHSEG2_PRG_OFF    0b11111110   // XXXXXXX0  
....................   
.................... #define    CAN_CONFIG_LINE_FILTER_BIT   0b00000010  
.................... #define    CAN_CONFIG_LINE_FILTER_ON    0b11111111   // XXXXXX1X  
.................... #define    CAN_CONFIG_LINE_FILTER_OFF   0b11111101   // XXXXXX0X  
....................   
.................... #define    CAN_CONFIG_SAMPLE_BIT        0b00000100  
.................... #define    CAN_CONFIG_SAMPLE_ONCE       0b11111111   // XXXXX1XX  
.................... #define    CAN_CONFIG_SAMPLE_THRICE     0b11111011   // XXXXX0XX  
....................   
.................... #define    CAN_CONFIG_MSG_TYPE_BIT      0b00001000  
.................... #define    CAN_CONFIG_STD_MSG           0b11111111   // XXXX1XXX  
.................... #define    CAN_CONFIG_XTD_MSG           0b11110111   // XXXX0XXX  
....................   
.................... #define    CAN_CONFIG_DBL_BUFFER_BIT    0b00010000  
.................... #define    CAN_CONFIG_DBL_BUFFER_ON     0b11111111   // XXX1XXXX  
.................... #define    CAN_CONFIG_DBL_BUFFER_OFF    0b11101111   // XXX0XXXX  
....................   
.................... #define    CAN_CONFIG_MSG_BITS          0b01100000  
.................... #define    CAN_CONFIG_ALL_MSG           0b11111111   // X11XXXXX  
.................... #define    CAN_CONFIG_VALID_XTD_MSG     0b11011111   // X10XXXXX  
.................... #define    CAN_CONFIG_VALID_STD_MSG     0b10111111   // X01XXXXX  
.................... #define    CAN_CONFIG_ALL_VALID_MSG     0b10011111    // X00XXXXX  
.................... //};  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  * Function:        void CANInitialize( BYTE SJW,  
....................  *                                      BYTE BRP,  
....................  *                                      BYTE PHSEG1,  
....................  *                                      BYTE PHSEG2,  
....................  *                                      BYTE PROPSEG,  
....................  *                                      BYTE config)  
....................  *  
....................  * PreCondition:    MCU must be in Configuration mode or else these  
....................  *                  values will be ignored.  
....................  *  
....................  * Input:           SJW     - SJW value as defined in 18CXX8 datasheet  
....................  *                              (Must be between 1 thru 4)  
....................  *                  BRP     - BRP value as defined in 18CXX8 datasheet  
....................  *                              (Must be between 1 thru 64)  
....................  *                  PHSEG1  - PHSEG1 value as defined in 18CXX8  
....................  *                            datasheet  
....................  *                              (Must be between 1 thru 8)  
....................  *                  PHSEG2  - PHSEG2 value as defined in 18CXX8  
....................  *                            datasheet  
....................  *                              (Must be between 1 thru 8)  
....................  *                  PROPSEG - PROPSEG value as defined in 18CXX8  
....................  *                            datasheet  
....................  *                              (Must be between 1 thru 8)  
....................  *                  flags   - Value of type enum CAN_CONFIG_FLAGS  
....................  *  
....................  * Output:          CAN bit rate is set.  
....................  *                  All masks registers are set '0'  
....................  *                  to allow all messages.  
....................  *                  Filter registers are set according to flag value.  
....................  *                  If (config & CAN_CONFIG_VALID_XTD_MSG)  
....................  *                      Set all filters to XTD_MSG  
....................  *                  Else if (config & CONFIG_VALID_STD_MSG)  
....................  *                      Set all filters to STD_MSG  
....................  *                  Else  
....................  *                      Set half of the filters to STD while rests to  
....................  *                      XTD_MSG.  
....................  *  
....................  * Side Effects:    All pending transmissions are aborted.  
....................  ********************************************************************/  
.................... void CANInitialize(BYTE SJW,  
....................                     BYTE BRP,  
....................                     BYTE PHSEG1,  
....................                     BYTE PHSEG2,  
....................                     BYTE PROPSEG,  
....................                     BYTE config);  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
....................   
.................... /*********************************************************************  
....................  * Function:        void CANSetOperationMode(CAN_OP_MODE mode)  
....................  *  
....................  * PreCondition:    None  
....................  *  
....................  * Input:           mode    - Operation mode code  
....................  *                            must be of type enum CAN_OP_MODES  
....................  *  
....................  * Output:          MCU is set to requested mode  
....................  *  
....................  * Side Effects:    None  
....................  *  
....................  * Note:            This is a blocking call.  It will not return until  
....................  *                  requested mode is set.  
....................  ********************************************************************/  
.................... void CANSetOperationMode(CAN_OP_MODE mode);  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
....................   
.................... /*********************************************************************  
....................  * Macro:           void CANSetOperationModeNoWait(CAN_OP_MODE mode)  
....................  *  
....................  * PreCondition:    None  
....................  *  
....................  * Input:           mode    - Operation mode code  
....................  *                            must be of type enum CAN_OP_MODES  
....................  *  
....................  * Output:          MCU is set to requested mode  
....................  *  
....................  * Side Effects:    None  
....................  *  
....................  * Note:            This is a non-blocking call.  
....................  *                  It does not verify that  
....................  *                  CAN module is switched to requested mode or not.  
....................  *                  Caller must use CANGetOperationMode() to verify  
....................  *                  correct operation mode before performing mode  
....................  *                  specific operation.  
....................  *  
....................  ********************************************************************/  
.................... #define CANSetOperationModeNoWait(mode) (CANCON = mode)  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  * Macro:           CAN_OP_MODE CANSetOperationMode()  
....................  *  
....................  * PreCondition:    None  
....................  *  
....................  * Input:           None  
....................  *  
....................  * Output:          Current operational mode of CAN module is returned  
....................  *  
....................  * Side Effects:    None  
....................  *  
....................  ********************************************************************/  
.................... #define CANGetOperationMode() (CANCON & CAN_OP_MODE_BITS)  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  * Function:        void CANSetBaudRate(BYTE SJW,  
....................  *                                      BYTE BRP,  
....................  *                                      BYTE PHSEG1,  
....................  *                                      BYTE PHSEG2,  
....................  *                                      BYTE PROPSEG,  
....................  *                                      BYTE flags)  
....................  *  
....................  * PreCondition:    MCU must be in Configuration mode or else these  
....................  *                  values will be ignored.  
....................  *  
....................  * Input:           SJW     - SJW value as defined in 18CXX8 datasheet  
....................  *                              (Must be between 1 thru 4)  
....................  *                  BRP     - BRP value as defined in 18CXX8 datasheet  
....................  *                              (Must be between 1 thru 64)  
....................  *                  PHSEG1  - PHSEG1 value as defined in 18CXX8  
....................  *                            datasheet  
....................  *                              (Must be between 1 thru 8)  
....................  *                  PHSEG2  - PHSEG2 value as defined in 18CXX8  
....................  *                            datasheet  
....................  *                              (Must be between 1 thru 8)  
....................  *                  PROPSEG - PROPSEG value as defined in 18CXX8  
....................  *                            datasheet  
....................  *                              (Must be between 1 thru 8)  
....................  *                  flags   - Value of type enum CAN_CONFIG_FLAGS  
....................  *  
....................  * Output:          CAN bit rate is set as per given values.  
....................  *  
....................  * Side Effects:    None  
....................  *  
....................  ********************************************************************/  
.................... void CANSetBaudRate (BYTE SJW,  
....................                      BYTE BRP,  
....................                      BYTE PHSEG1,  
....................                      BYTE PHSEG2,  
....................                      BYTE PROPSEG,  
....................                      BYTE flags);  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  * Function:        void CANSetMask(enum CAN_MASK code,  
....................  *                                  int32 val,  
....................  *                                  BYTE type)  
....................  *  
....................  * PreCondition:    MCU must be in Configuration mode.  If not, all  
....................  *                  values  
....................  *                  will be ignored.  
....................  *  
....................  * Input:           code    - One of CAN_MASK value  
....................  *                  val     - Actual mask register value.  
....................  *                  type    - Type of message to filter either  
....................  *                            CAN_CONFIG_XTD_MSG or CAN_CONFIG_STD_MSG  
....................  *  
....................  * Output:          Given value is bit adjusted to appropriate buffer  
....................  *                  mask registers.  
....................  *  
....................  * Side Effects:    None  
....................  ********************************************************************/  
.................... void CANSetMask (CAN_MASK code,  
....................                 int32 val,  
....................                 BYTE type);  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  * Function:        void CANSetFilter(enum CAN_FILTER code,  
....................  *                                    int32 val,  
....................  *                                    BYTE type)  
....................  *  
....................  * PreCondition:    MCU must be in Configuration mode.  If not, all  
....................  *                  values will be ignored.  
....................  *  
....................  * Input:           code    - One of CAN_FILTER value  
....................  *                  val     - Actual filter register value.  
....................  *                  type    - Type of message to filter either  
....................  *                            CAN_CONFIG_XTD_MSG or CAN_CONFIG_STD_MSG  
....................  *  
....................  * Output:          Given value is bit adjusted to appropriate buffer  
....................  *                  filter registers.  
....................  *  
....................  * Side Effects:    None  
....................  ********************************************************************/  
.................... void CANSetFilter ( CAN_FILTER code,  
....................                     int32 val,  
....................                     BYTE type);  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  * Function:        BOOL CANSendMessage(int32 id,  
....................  *                                  BYTE *Data,  
....................  *                                  BYTE DataLen,  
....................  *                                  enum CAN_TX_MSG_FLAGS MsgFlags)  
....................  *  
....................  * PreCondition:    None  
....................  *  
....................  * Input:           id          - CAN message identifier.  
....................  *                                Only 11 or 29 bits may be used  
....................  *                                depending on standard or extended  
....................  *                                message type.  
....................  *                  Data        - Data bytes of upto 8 bytes in length  
....................  *                  DataLen     - Data length from 1 thru 8.  
....................  *                  MsgFlags    - One or CAN_TX_MSG_FLAGS values ANDed  
....................  *                                together  
....................  *  
....................  * Output:          If at least one empty transmit buffer is found,  
....................  *                  given message is queued to be transmitted. If none  
....................  *                  found FALSE value is returned.  
....................  *  
....................  * Side Effects:    None  
....................  *  
....................  ********************************************************************/  
.................... BOOLEAN CANSendMessage (int32 id,  
....................                      BYTE *Data,  
....................                      BYTE DataLen,  
....................                      CAN_TX_MSG_FLAGS MsgFlags);  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  * Function:        BOOL CANReceiveMessage(int32 *id,  
....................  *                                  BYTE *Data,  
....................  *                                  BYTE *DataLen,  
....................  *                                  enum CAN_RX_MSG_FLAGS *MsgFlags)  
....................  *  
....................  * PreCondition:    None  
....................  *  
....................  * Input:           None  
....................  *  
....................  * Output:          id          - CAN message identifier.  
....................  *                  Data        - Data bytes of upto 8 bytes in length  
....................  *                  DataLen     - Data length from 1 thru 8.  
....................  *                  MsgFlags    - One or CAN_RX_MSG_FLAGS values ANDed  
....................  *                                together  
....................  *  
....................  * Output:          If at least one full receive buffer is found,  
....................  *                  it is extrated and returned. If none found FALSE  
....................  *                  value is returned.  
....................  *  
....................  * Side Effects:    None  
....................  *  
....................  ********************************************************************/  
.................... BOOLEAN CANReceiveMessage(int32* id,  
....................                         BYTE *Data,  
....................                         BYTE *DataLen,  
....................                         CAN_RX_MSG_FLAGS *MsgFlags);  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  * Macro:           BYTE CANGetTxErrorCount()  
....................  *  
....................  * PreCondition:    None  
....................  *  
....................  * Input:           None  
....................  *  
....................  * Output:          Current transmit error count as defined by  
....................  *                  CAN specifications.  
....................  *  
....................  * Side Effects:    None  
....................  *  
....................  ********************************************************************/  
.................... #define CANGetTxErrorCount()    (TXERRCNT)  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  * Macro:           BYTE CANGetRxErrorCount()  
....................  *  
....................  * PreCondition:    None  
....................  *  
....................  * Input:           None  
....................  *  
....................  * Output:          Current receive error count as defined by  
....................  *                  CAN specifications.  
....................  *  
....................  * Side Effects:    None  
....................  *  
....................  ********************************************************************/  
.................... #define CANGetRxErrorCount()    (RXERRCNT)  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  * Macro:           BOOL CANIsBusOff()  
....................  *  
....................  * PreCondition:    None  
....................  *  
....................  * Input:           None  
....................  *  
....................  * Output:          TRUE if CAN Module is off due to excessive error  
....................  *                  FALSE is it is not off.  
....................  *  
....................  * Side Effects:    None  
....................  *  
....................  ********************************************************************/  
.................... #define CANIsBusOff()           (COMSTAT_TXB0)  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  * Macro:           BOOL CANIsTxPassive()  
....................  *  
....................  * PreCondition:    None  
....................  *  
....................  * Input:           None  
....................  *  
....................  * Output:          TRUE if CAN transmit module is error passive as  
....................  *                  defined by CAN specifications.  
....................  *  
....................  * Side Effects:    None  
....................  *  
....................  ********************************************************************/  
.................... #define CANIsTxPassive()        (COMSTAT_TXBP)  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  * Macro:           BYTE CANIsRxPassive()  
....................  *  
....................  * PreCondition:    None  
....................  *  
....................  * Input:           None  
....................  *  
....................  * Output:          TRUE if CAN receive module is error active as  
....................  *                  defined by CAN specifications.  
....................  *  
....................  * Side Effects:    None  
....................  *  
....................  ********************************************************************/  
.................... #define CANIsRxPassive()        (COMSTAT_RXBP)  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  * Macro:           void CANAbortAll()  
....................  *  
....................  * PreCondition:    None  
....................  *  
....................  * Input:           None  
....................  *  
....................  * Output:          None  
....................  *  
....................  * Side Effects:    None  
....................  *  
....................  ********************************************************************/  
.................... #define CANAbortAll()           (CANCON_ABAT = 1)  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  * Macro:           BOOL  CANIsRxReady()  
....................  *  
....................  * PreCondition:    None  
....................  *  
....................  * Input:           None  
....................  *  
....................  * Output:          TRUE if at least one of the CAN receive buffer is  
....................  *                  empty FALSE if none receive buffers are empty.  
....................  *  
....................  * Side Effects:    None  
....................  *  
....................  ********************************************************************/  
.................... #define CANIsRxReady()          (RXB0CON_RXFUL || RXB1CON_RXFUL)  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  * Macro:           BOOL CANIsTxReady()  
....................  *  
....................  * PreCondition:    None  
....................  *  
....................  * Input:           None  
....................  *  
....................  * Output:          TRUE if at least one CAN transmit buffer is empty  
....................  *                  FALSE if all CAN transmit buffers are full  
....................  *  
....................  * Side Effects:    None  
....................  *  
....................  ********************************************************************/  
.................... #define CANIsTxReady()          (!TXB0CON_TXREQ || \  
....................                                  !TXB1CON_TXREQ || \  
....................                                  !TXB2CON_TXREQ )  
....................   
.................... #endif      // CAN18XX8_H  
....................   
....................  
....................   
.................... /*********************************************************************  
....................  * Function:        void CANInitialize(BYTE SJW,  
....................  *                                      BYTE BRP,  
....................  *                                      BYTE PHSEG1,  
....................  *                                      BYTE PHSEG2,  
....................  *                                      BYTE PROPSEG,  
....................  *                                      BYTE config)  
....................  *  
....................  * PreCondition:    MCU must be in Configuration mode or else these  
....................  *                  values will be ignored.  
....................  *  
....................  * Input:           SJW     - SJW value as defined in 18CXX8 datasheet  
....................  *                              (Must be between 1 thru 4)  
....................  *                  BRP     - BRP value as defined in 18CXX8 datasheet  
....................  *                              (Must be between 1 thru 64)  
....................  *                  PHSEG1  - PHSEG1 value as defined in 18CXX8  
....................  *                            datasheet  
....................  *                              (Must be between 1 thru 8)  
....................  *                  PHSEG2  - PHSEG2 value as defined in 18CXX8  
....................  *                            datasheet  
....................  *                              (Must be between 1 thru 8)  
....................  *                  PROPSEG - PROPSEG value as defined in 18CXX8  
....................  *                            datasheet  
....................  *                              (Must be between 1 thru 8)  
....................  *                  flags   - Value of type BYTE  
....................  *  
....................  * Output:          CAN bit rate is set. All masks registers are set  
....................  *                  '0' to allow all messages.  
....................  *                  Filter registers are set according to flag value.  
....................  *                  If (config & CAN_CONFIG_VALID_XTD_MSG)  
....................  *                      Set all filters to XTD_MSG  
....................  *                  Else if (config & CONFIG_VALID_STD_MSG)  
....................  *                      Set all filters to STD_MSG  
....................  *                  Else  
....................  *                      Set half of the filters to STD while rest to  
....................  *                      XTD_MSG.  
....................  *  
....................  * Side Effects:    All pending transmissions are aborted.  
....................  *  
....................  ********************************************************************/  
....................  void CANInitialize(BYTE SJW,  
....................                     BYTE BRP,  
....................                     BYTE PHSEG1,  
....................                     BYTE PHSEG2,  
....................                     BYTE PROPSEG,  
....................                     BYTE config)  
....................  {  
....................      BYTE FilterConfig1;  
....................      BYTE FilterConfig2;  
....................   
....................     // In order to setup necessary config parameters of CAN module,  
....................     // it must be in CONFIG mode.  
....................     CANSetOperationMode(CAN_OP_MODE_CONFIG);  	//Set configuration mode  
*
20BA:  MOVLW  80
20BC:  MOVLB  2
20BE:  MOVWF  x18
20C0:  MOVLB  0
20C2:  CALL   1D36
....................   
....................     // Now set the baud rate, tQ and segment counts  
....................     CANSetBaudRate(SJW,  
....................                     BRP,  
....................                     PHSEG1,  
....................                     PHSEG2,  
....................                     PROPSEG,  
....................                     config);  
20C6:  MOVFF  210,218
20CA:  MOVFF  211,219
20CE:  MOVFF  212,21A
20D2:  MOVFF  213,21B
20D6:  MOVFF  214,21C
20DA:  MOVFF  215,21D
20DE:  GOTO   1D50
....................   
....................     RXB0CON = config & CAN_CONFIG_MSG_BITS;		//Receive: All, Valid XTND, Valid STD or All Valid CAN messages  
20E2:  MOVLB  2
20E4:  MOVF   x15,W
20E6:  ANDLW  60
20E8:  MOVWF  F60
....................     if ( (config & CAN_CONFIG_DBL_BUFFER_BIT) == CAN_CONFIG_DBL_BUFFER_ON )  
....................         RXB0CON_RX0DBEN = 1;					//Enable Buffer0 overflow to write Buffer1  
20EA:  MOVF   x15,W
20EC:  ANDLW  10
20EE:  SUBLW  FF
20F0:  BTFSS  FD8.2
20F2:  GOTO   20F8
20F6:  BSF    F60.2
....................   
....................     RXB1CON = RXB0CON;							//Set common bits of both Rx cntrl registers equal  
20F8:  MOVLB  0
20FA:  MOVFF  F60,F50
....................   
....................     // Set default filter and mask registers for all receive buffers.  
....................     CANSetMask(CAN_MASK_B1, 0, CAN_CONFIG_XTD_MSG);  
20FE:  MOVLB  2
2100:  CLRF   x18
2102:  CLRF   x1C
2104:  CLRF   x1B
2106:  CLRF   x1A
2108:  CLRF   x19
210A:  MOVLW  F7
210C:  MOVWF  x1D
210E:  MOVLB  0
2110:  CALL   1FC4
....................     CANSetMask(CAN_MASK_B2, 0, CAN_CONFIG_XTD_MSG);  
2114:  MOVLW  01
2116:  MOVLB  2
2118:  MOVWF  x18
211A:  CLRF   x1C
211C:  CLRF   x1B
211E:  CLRF   x1A
2120:  CLRF   x19
2122:  MOVLW  F7
2124:  MOVWF  x1D
2126:  MOVLB  0
2128:  CALL   1FC4
....................   
....................     switch( (config & CAN_CONFIG_MSG_BITS) | ~CAN_CONFIG_MSG_BITS )  
....................     {  
212C:  MOVLB  2
212E:  MOVF   x15,W
2130:  ANDLW  60
2132:  IORLW  9F
2134:  MOVWF  00
2136:  MOVLW  DF
2138:  SUBWF  00,W
213A:  MOVLB  0
213C:  BTFSC  FD8.2
213E:  GOTO   2150
2142:  MOVLW  BF
2144:  SUBWF  00,W
2146:  BTFSC  FD8.2
2148:  GOTO   215C
214C:  GOTO   216A
....................     case CAN_CONFIG_VALID_XTD_MSG:  
....................         FilterConfig1 = CAN_CONFIG_XTD_MSG;  
2150:  MOVLW  F7
2152:  MOVLB  2
2154:  MOVWF  x16
....................         FilterConfig2 = CAN_CONFIG_XTD_MSG;  
2156:  MOVWF  x17
....................         break;  
2158:  GOTO   2178
....................   
....................     case CAN_CONFIG_VALID_STD_MSG:  
....................         FilterConfig1 = CAN_CONFIG_STD_MSG;  
215C:  MOVLW  FF
215E:  MOVLB  2
2160:  MOVWF  x16
....................         FilterConfig2 = CAN_CONFIG_STD_MSG;  
2162:  MOVWF  x17
....................         break;  
2164:  GOTO   2178
2168:  MOVLB  0
....................     default:  
....................         FilterConfig1 = CAN_CONFIG_STD_MSG;  
216A:  MOVLW  FF
216C:  MOVLB  2
216E:  MOVWF  x16
....................         FilterConfig2 = CAN_CONFIG_XTD_MSG;  
2170:  MOVLW  F7
2172:  MOVWF  x17
....................         break;  
2174:  GOTO   2178
....................     }  
....................   
....................     // By default, there will be no mask on any receive filters,  
....................     // hence filter value of '0' will be ignored.  
....................     CANSetFilter(CAN_FILTER_B1_F1, 0, FilterConfig1);  
2178:  CLRF   x18
217A:  CLRF   x1C
217C:  CLRF   x1B
217E:  CLRF   x1A
2180:  CLRF   x19
2182:  MOVLB  0
2184:  MOVFF  216,21D
2188:  CALL   2006
....................     CANSetFilter(CAN_FILTER_B1_F2, 0, FilterConfig1);  
218C:  MOVLW  01
218E:  MOVLB  2
2190:  MOVWF  x18
2192:  CLRF   x1C
2194:  CLRF   x1B
2196:  CLRF   x1A
2198:  CLRF   x19
219A:  MOVLB  0
219C:  MOVFF  216,21D
21A0:  CALL   2006
....................     CANSetFilter(CAN_FILTER_B2_F1, 0, FilterConfig2);  
21A4:  MOVLW  02
21A6:  MOVLB  2
21A8:  MOVWF  x18
21AA:  CLRF   x1C
21AC:  CLRF   x1B
21AE:  CLRF   x1A
21B0:  CLRF   x19
21B2:  MOVLB  0
21B4:  MOVFF  217,21D
21B8:  CALL   2006
....................     CANSetFilter(CAN_FILTER_B2_F2, 0, FilterConfig2);  
21BC:  MOVLW  03
21BE:  MOVLB  2
21C0:  MOVWF  x18
21C2:  CLRF   x1C
21C4:  CLRF   x1B
21C6:  CLRF   x1A
21C8:  CLRF   x19
21CA:  MOVLB  0
21CC:  MOVFF  217,21D
21D0:  CALL   2006
....................     CANSetFilter(CAN_FILTER_B2_F3, 0, FilterConfig2);  
21D4:  MOVLW  04
21D6:  MOVLB  2
21D8:  MOVWF  x18
21DA:  CLRF   x1C
21DC:  CLRF   x1B
21DE:  CLRF   x1A
21E0:  CLRF   x19
21E2:  MOVLB  0
21E4:  MOVFF  217,21D
21E8:  CALL   2006
....................     CANSetFilter(CAN_FILTER_B2_F4, 0, FilterConfig2);  
21EC:  MOVLW  05
21EE:  MOVLB  2
21F0:  MOVWF  x18
21F2:  CLRF   x1C
21F4:  CLRF   x1B
21F6:  CLRF   x1A
21F8:  CLRF   x19
21FA:  MOVLB  0
21FC:  MOVFF  217,21D
2200:  CALL   2006
....................   
....................     // Restore to Normal mode.  
....................     CANSetOperationMode(CAN_OP_MODE_NORMAL);  
2204:  MOVLB  2
2206:  CLRF   x18
2208:  MOVLB  0
220A:  CALL   1D36
.................... }  
220E:  RETLW  00
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  * Function:        void CANSetOperationMode(CAN_OP_MODE mode)  
....................  *  
....................  * PreCondition:    None  
....................  *  
....................  * Input:           mode    - Operation mode code  
....................  *                            must be of type CAN_OP_MODES  
....................  *  
....................  * Output:          MCU is set to requested mode  
....................  *  
....................  * Side Effects:    None  
....................  *  
....................  * Overview:        Given mode byte is copied to CANSTAT and made  
....................  *                  sure that requested mode is set.  
....................  *  
....................  * Note:            This is a blocking call.  It will not return until  
....................  *                  requested mode is set.  
....................  ********************************************************************/  
.................... void CANSetOperationMode(CAN_OP_MODE mode)  
.................... {  
....................      // Request desired mode of the CAN engine.  
....................      CANCON = mode;  
*
1D36:  MOVFF  218,F6F
....................   
....................     // Wait for the CAN engine to set the desired mode.  
....................     while( (CANSTAT & CAN_OP_MODE_BITS) != mode );  
1D3A:  MOVF   F6E,W
1D3C:  ANDLW  E0
1D3E:  MOVLB  2
1D40:  SUBWF  x18,W
1D42:  BTFSC  FD8.2
1D44:  BRA    1D4C
1D46:  MOVLB  0
1D48:  GOTO   1D3A
.................... }  
1D4C:  MOVLB  0
1D4E:  RETLW  00
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  * Function:        void CANSetBaudRate(BYTE SJW,  
....................  *                                      BYTE BRP,  
....................  *                                      BYTE PHSEG1,  
....................  *                                      BYTE PHSEG2,  
....................  *                                      BYTE PROPSEG,  
....................  *                                      BYTE flags)  
....................  *  
....................  * PreCondition:    MCU must be in Configuration mode or else these  
....................  *                  values will be ignored.  
....................  *  
....................  * Input:           SJW     - SJW value as defined in 18CXX8 datasheet  
....................  *                              (Must be between 1 thru 4)  
....................  *                  BRP     - BRP value as defined in 18CXX8 datasheet  
....................  *                              (Must be between 1 thru 64)  
....................  *                  PHSEG1  - PHSEG1 value as defined in 18CXX8  
....................  *                            datasheet  
....................  *                              (Must be between 1 thru 8)  
....................  *                  PHSEG2  - PHSEG2 value as defined in 18CXX8  
....................  *                            datasheet  
....................  *                              (Must be between 1 thru 8)  
....................  *                  PROPSEG - PROPSEG value as defined in 18CXX8  
....................  *                            datasheet  
....................  *                              (Must be between 1 thru 8)  
....................  *                  flags   - Value of type BYTE  
....................  *  
....................  * Output:          CAN bit rate is set as per given values.  
....................  *  
....................  * Side Effects:    None  
....................  *  
....................  * Overview:        Given values are bit adjusted to fit in 18CXX8  
....................  *                  BRGCONx registers and copied.  
....................  *  
....................  ********************************************************************/  
....................  void CANSetBaudRate(BYTE SJW,  
....................                      BYTE BRP,  
....................                      BYTE PHSEG1,  
....................                      BYTE PHSEG2,  
....................                      BYTE PROPSEG,  
....................                      BYTE flags)  
....................  {  
....................      // Actual values are offset '0'. (Can engine has 1 as a minimum)  
....................      // Hence map given values from offset '1' to offset '0'  
....................      SJW--;  
1D50:  MOVLB  2
1D52:  DECF   x18,F
....................      BRP--;  
1D54:  DECF   x19,F
....................      PHSEG1--;  
1D56:  DECF   x1A,F
....................      PHSEG2--;  
1D58:  DECF   x1B,F
....................      PROPSEG--;  
1D5A:  DECF   x1C,F
....................   
....................     // Bit adjust given values into their appropriate registers.  
....................     BRGCON1 = SJW << 6;  
1D5C:  SWAPF  x18,W
1D5E:  MOVWF  F70
1D60:  RLCF   F70,F
1D62:  RLCF   F70,F
1D64:  MOVLW  C0
1D66:  ANDWF  F70,F
....................     BRGCON1 |= BRP;  
1D68:  MOVF   x19,W
1D6A:  IORWF  F70,F
....................   
....................     BRGCON2 = PHSEG1 << 3;  
1D6C:  RLCF   x1A,W
1D6E:  MOVWF  F71
1D70:  RLCF   F71,F
1D72:  RLCF   F71,F
1D74:  MOVLW  F8
1D76:  ANDWF  F71,F
....................     BRGCON2 |= PROPSEG;  
1D78:  MOVF   x1C,W
1D7A:  IORWF  F71,F
....................   
....................     if ( !(flags & CAN_CONFIG_SAMPLE_BIT) )  
....................         BRGCON2_SAM = 1;					//Set sample thrice mode  
1D7C:  BTFSC  x1D.2
1D7E:  GOTO   1D84
1D82:  BSF    F71.6
....................   
....................     if ( flags & CAN_CONFIG_PHSEG2_PRG_BIT )  
....................         BRGCON2_SEG2PHTS = 1;				//Set segments fully programmable mode  
1D84:  BTFSS  x1D.0
1D86:  GOTO   1D8C
1D8A:  BSF    F71.7
....................   
....................   
....................     BRGCON3 = PHSEG2;  
1D8C:  MOVLB  0
1D8E:  MOVFF  21B,F72
....................     if ( flags & CAN_CONFIG_LINE_FILTER_BIT )  
....................         BRGCON3_WAKFIL = 1;					//Enable Line Filter for wake-up  
1D92:  MOVLB  2
1D94:  BTFSS  x1D.1
1D96:  GOTO   1D9C
1D9A:  BSF    F72.6
....................   
.................... }  
1D9C:  MOVLB  0
1D9E:  GOTO   20E2 (RETURN)
....................   
.................... //////////////////////////////////////////////////////////////////////  
.................... /*********************************************************************  
....................  * Function:        void CANIDToRegs(BYTE* ptr,  
....................  *                                      int32 val,  
....................  *                                      BYTE config_flags)  
....................  *  
....................  * PreCondition:    None  
....................  *  
....................  * Input:           ptr     - Starting address of a buffer to be updated  
....................  *                  val     - 32-bit value to be converted  
....................  *                  type    - Type of message - either  
....................  *                            CAN_CONFIG_XTD_MSG or CAN_CONFIG_STD_MSG  
....................  *  
....................  * Output:          Given CAN id value 'val' is bit adjusted and copied  
....................  *                  into corresponding PIC18CXX8 CAN registers  
....................  *  
....................  * Side Effects:    None  
....................  *  
....................  * Overview:        If given id is of type standard identifier,  
....................  *                  only SIDH and SIDL are updated  
....................  *                  If given id is of type extended identifier,  
....................  *                  bits val<17:0> is copied to EIDH, EIDL and SIDH<1:0>  
....................  *                  bits val<28:18> is copied to SIDH and SIDL  
....................  *  
....................  ********************************************************************/  
.................... static void CANIDToRegs(BYTE* ptr,  
....................                         int32 val,  
....................                         BYTE type)  
.................... {  
....................     CAN_MESSAGE_ID *Value;  
....................   
....................     Value =  (CAN_MESSAGE_ID*)&val;  
1DA2:  MOVLW  02
1DA4:  MOVLB  2
1DA6:  MOVWF  x44
1DA8:  MOVLW  3E
1DAA:  MOVWF  x43
....................   
....................     if ( type & CAN_CONFIG_MSG_TYPE_BIT )  
....................     {  
1DAC:  BTFSS  x42.3
1DAE:  GOTO   1E62
....................         // Standard Identifier  
....................         *ptr = Value->BYTES.BYTE_1 >> 3;        // Copy SID<7:3> to SIDH<4:0>  
1DB2:  MOVLB  0
1DB4:  MOVLB  2
1DB6:  MOVF   x3C,W
1DB8:  MOVWF  x45
1DBA:  MOVLB  0
1DBC:  MOVLB  2
1DBE:  MOVF   x43,W
1DC0:  MOVWF  FE9
1DC2:  MOVF   x44,W
1DC4:  MOVWF  FEA
1DC6:  RRCF   FEF,W
1DC8:  MOVWF  00
1DCA:  RRCF   00,F
1DCC:  RRCF   00,F
1DCE:  MOVLW  1F
1DD0:  ANDWF  00,F
1DD2:  MOVF   00,W
1DD4:  MOVWF  x48
1DD6:  MOVLB  0
1DD8:  MOVFF  23D,FEA
1DDC:  MOVFF  245,FE9
1DE0:  MOVFF  248,FEF
....................         *ptr |= (Value->BYTES.BYTE_2 << 5);     // Copy SID<10:8> to SIDH<7:5>  
1DE4:  MOVLB  2
1DE6:  MOVF   x3C,W
1DE8:  MOVWF  x45
1DEA:  MOVLB  0
1DEC:  MOVFF  23D,FEA
1DF0:  MOVFF  245,FE9
1DF4:  MOVFF  FEF,247
1DF8:  MOVLW  01
1DFA:  MOVLB  2
1DFC:  ADDWF  x43,W
1DFE:  MOVWF  FE9
1E00:  MOVLW  00
1E02:  ADDWFC x44,W
1E04:  MOVWF  FEA
1E06:  SWAPF  FEF,W
1E08:  MOVWF  00
1E0A:  RLCF   00,F
1E0C:  MOVLW  E0
1E0E:  ANDWF  00,F
1E10:  MOVF   00,W
1E12:  IORWF  x47,W
1E14:  MOVWF  x49
1E16:  MOVLB  0
1E18:  MOVFF  23D,FEA
1E1C:  MOVFF  245,FE9
1E20:  MOVFF  249,FEF
....................         ptr++;                                  // Point to SIDL  
1E24:  MOVLB  2
1E26:  INCF   x3C,F
1E28:  BTFSC  FD8.2
1E2A:  INCF   x3D,F
....................         *ptr = Value->BYTES.BYTE_1 << 5;        // Copy SID<2:0> to SIDL<7:5>  
1E2C:  MOVLB  0
1E2E:  MOVLB  2
1E30:  MOVF   x3C,W
1E32:  MOVWF  x45
1E34:  MOVLB  0
1E36:  MOVLB  2
1E38:  MOVF   x43,W
1E3A:  MOVWF  FE9
1E3C:  MOVF   x44,W
1E3E:  MOVWF  FEA
1E40:  SWAPF  FEF,W
1E42:  MOVWF  00
1E44:  RLCF   00,F
1E46:  MOVLW  E0
1E48:  ANDWF  00,F
1E4A:  MOVF   00,W
1E4C:  MOVWF  x48
1E4E:  MOVLB  0
1E50:  MOVFF  23D,FEA
1E54:  MOVFF  245,FE9
1E58:  MOVFF  248,FEF
....................     }  
....................     else  
....................     {  
1E5C:  GOTO   1FC2
1E60:  MOVLB  2
....................         // Extended Identifier  
....................         *ptr = Value->BYTES.BYTE_3 >> 5;        // Copy EID<23:21> to SIDH<2:0>  
1E62:  MOVLB  0
1E64:  MOVLB  2
1E66:  MOVF   x3C,W
1E68:  MOVWF  x45
1E6A:  MOVLB  0
1E6C:  MOVLW  02
1E6E:  MOVLB  2
1E70:  ADDWF  x43,W
1E72:  MOVWF  FE9
1E74:  MOVLW  00
1E76:  ADDWFC x44,W
1E78:  MOVWF  FEA
1E7A:  SWAPF  FEF,W
1E7C:  MOVWF  00
1E7E:  RRCF   00,F
1E80:  MOVLW  07
1E82:  ANDWF  00,F
1E84:  MOVF   00,W
1E86:  MOVWF  x48
1E88:  MOVLB  0
1E8A:  MOVFF  23D,FEA
1E8E:  MOVFF  245,FE9
1E92:  MOVFF  248,FEF
....................         *ptr |= Value->BYTES.BYTE_4 << 3;       // Copy EID<28:24> to SIDH<7:3>  
1E96:  MOVLB  2
1E98:  MOVF   x3C,W
1E9A:  MOVWF  x45
1E9C:  MOVLB  0
1E9E:  MOVFF  23D,FEA
1EA2:  MOVFF  245,FE9
1EA6:  MOVFF  FEF,247
1EAA:  MOVLW  03
1EAC:  MOVLB  2
1EAE:  ADDWF  x43,W
1EB0:  MOVWF  FE9
1EB2:  MOVLW  00
1EB4:  ADDWFC x44,W
1EB6:  MOVWF  FEA
1EB8:  RLCF   FEF,W
1EBA:  MOVWF  00
1EBC:  RLCF   00,F
1EBE:  RLCF   00,F
1EC0:  MOVLW  F8
1EC2:  ANDWF  00,F
1EC4:  MOVF   00,W
1EC6:  IORWF  x47,W
1EC8:  MOVWF  x49
1ECA:  MOVLB  0
1ECC:  MOVFF  23D,FEA
1ED0:  MOVFF  245,FE9
1ED4:  MOVFF  249,FEF
....................         ptr++;                                  // Point to SIDL  
1ED8:  MOVLB  2
1EDA:  INCF   x3C,F
1EDC:  BTFSC  FD8.2
1EDE:  INCF   x3D,F
....................         *ptr = (Value->BYTES.BYTE_3 << 3) & 0xE0; // Copy EID<20:18> to SIDL<7:5>  
1EE0:  MOVLB  0
1EE2:  MOVLB  2
1EE4:  MOVF   x3C,W
1EE6:  MOVWF  x45
1EE8:  MOVLB  0
1EEA:  MOVLW  02
1EEC:  MOVLB  2
1EEE:  ADDWF  x43,W
1EF0:  MOVWF  FE9
1EF2:  MOVLW  00
1EF4:  ADDWFC x44,W
1EF6:  MOVWF  FEA
1EF8:  RLCF   FEF,W
1EFA:  MOVWF  00
1EFC:  RLCF   00,F
1EFE:  RLCF   00,F
1F00:  MOVLW  F8
1F02:  ANDWF  00,F
1F04:  MOVF   00,W
1F06:  ANDLW  E0
1F08:  MOVWF  x49
1F0A:  MOVLB  0
1F0C:  MOVFF  23D,FEA
1F10:  MOVFF  245,FE9
1F14:  MOVFF  249,FEF
....................                                                 // mask out EID<17:16> bits  
....................         *ptr |= 0b00001000;                     // Set EXIDEN bit  to SIDL<3>  
1F18:  MOVLB  2
1F1A:  MOVF   x3C,W
1F1C:  MOVWF  FE9
1F1E:  MOVLB  0
1F20:  MOVFF  23D,FEA
1F24:  MOVF   FEF,W
1F26:  IORLW  08
1F28:  MOVWF  FEF
....................         *ptr |= Value->BYTES.BYTE_3 & 0x03;     // Copy EID<17:16> to SIDL<1:0>  
1F2A:  MOVLB  2
1F2C:  MOVF   x3C,W
1F2E:  MOVWF  x45
1F30:  MOVLB  0
1F32:  MOVFF  23D,FEA
1F36:  MOVFF  245,FE9
1F3A:  MOVFF  FEF,247
1F3E:  MOVLW  02
1F40:  MOVLB  2
1F42:  ADDWF  x43,W
1F44:  MOVWF  FE9
1F46:  MOVLW  00
1F48:  ADDWFC x44,W
1F4A:  MOVWF  FEA
1F4C:  MOVF   FEF,W
1F4E:  ANDLW  03
1F50:  IORWF  x47,W
1F52:  MOVWF  x49
1F54:  MOVLB  0
1F56:  MOVFF  23D,FEA
1F5A:  MOVFF  245,FE9
1F5E:  MOVFF  249,FEF
....................         ptr++;                                  // Point to EIDH  
1F62:  MOVLB  2
1F64:  INCF   x3C,F
1F66:  BTFSC  FD8.2
1F68:  INCF   x3D,F
....................         *ptr = Value->BYTES.BYTE_2;             // Copy EID<15:8> to EIDH<7:0>  
1F6A:  MOVLB  0
1F6C:  MOVLB  2
1F6E:  MOVF   x3C,W
1F70:  MOVWF  x45
1F72:  MOVLB  0
1F74:  MOVLW  01
1F76:  MOVLB  2
1F78:  ADDWF  x43,W
1F7A:  MOVWF  FE9
1F7C:  MOVLW  00
1F7E:  ADDWFC x44,W
1F80:  MOVWF  FEA
1F82:  MOVF   FEF,W
1F84:  MOVWF  x47
1F86:  MOVLB  0
1F88:  MOVFF  23D,FEA
1F8C:  MOVFF  245,FE9
1F90:  MOVFF  247,FEF
....................         ptr++;                                  // Point to EIDL  
1F94:  MOVLB  2
1F96:  INCF   x3C,F
1F98:  BTFSC  FD8.2
1F9A:  INCF   x3D,F
....................         *ptr = Value->BYTES.BYTE_1;             // Copy EID<7:0> to EIDL<7:0>  
1F9C:  MOVLB  0
1F9E:  MOVLB  2
1FA0:  MOVF   x3C,W
1FA2:  MOVWF  x45
1FA4:  MOVLB  0
1FA6:  MOVLB  2
1FA8:  MOVF   x43,W
1FAA:  MOVWF  FE9
1FAC:  MOVF   x44,W
1FAE:  MOVWF  FEA
1FB0:  MOVF   FEF,W
1FB2:  MOVWF  x47
1FB4:  MOVLB  0
1FB6:  MOVFF  23D,FEA
1FBA:  MOVFF  245,FE9
1FBE:  MOVFF  247,FEF
....................     }  
.................... }  
1FC2:  RETLW  00
....................   
.................... //////////////////////////////////////////////////////////////////////  
.................... /*********************************************************************  
....................  * Function:        void RegsToCANID(BYTE *ptr,  
....................  *                                      int32 *val,  
....................  *                                      BYTE type)  
....................  *  
....................  * PreCondition:    None  
....................  *  
....................  * Input:           ptr     - Starting address of a buffer to be updated  
....................  *                  val     - 32-bit buffer to hold value  
....................  *                  type    - Type of message - either  
....................  *                            CAN_CONFIG_XTD_MSG or CAN_CONFIG_STD_MSG  
....................  *  
....................  * Output:          CAN registers starting at given address are bit  
....................  *                  adjusted and copied into 'val'  
....................  *  
....................  * Side Effects:    None  
....................  *  
....................  * Overview:        If given id is of type standard identifier,  
....................  *                  only SIDH and SIDL are used  
....................  *                  If given id is of type extended identifier,  
....................  *                  bits EIDH, EIDL and SIDL<1:0> is copied to val<17:0>  
....................  *                  bits SIDH and SIDL is copied to val<28:18>  
....................  *  
....................  ********************************************************************/  
.................... static void RegsToCANID(BYTE* ptr,  
....................                         int32 *val,  
....................                         BYTE type)  
.................... {  
....................     CAN_MESSAGE_ID *Value;  
....................   
....................     Value = (CAN_MESSAGE_ID*)val;  
*
02B0:  MOVFF  287,28A
02B4:  MOVFF  286,289
....................   
....................     if ( type & CAN_CONFIG_MSG_TYPE_BIT )  
....................     {  
02B8:  MOVLB  2
02BA:  BTFSS  x88.3
02BC:  GOTO   03B4
....................         // Standard Identifier  
....................         Value->BYTES.BYTE_1 = (*ptr << 3);      // Copy SIDH<4:0> to SID<7:3>  
02C0:  MOVF   x89,W
02C2:  MOVWF  01
02C4:  MOVF   x8A,W
02C6:  MOVWF  03
02C8:  MOVF   01,W
02CA:  MOVWF  x8B
02CC:  MOVLB  0
02CE:  MOVFF  03,28C
02D2:  MOVLB  2
02D4:  MOVF   x84,W
02D6:  MOVWF  FE9
02D8:  MOVLB  0
02DA:  MOVFF  285,FEA
02DE:  RLCF   FEF,W
02E0:  MOVWF  00
02E2:  RLCF   00,F
02E4:  RLCF   00,F
02E6:  MOVLW  F8
02E8:  ANDWF  00,F
02EA:  MOVF   00,W
02EC:  MOVLB  2
02EE:  MOVWF  x8E
02F0:  MOVLB  0
02F2:  MOVFF  28C,FEA
02F6:  MOVFF  28B,FE9
02FA:  MOVFF  28E,FEF
....................         Value->BYTES.BYTE_2 = *ptr >> 5;        // Copy SIDH<7:5> to SID<10:8>  
02FE:  MOVLW  01
0300:  MOVLB  2
0302:  ADDWF  x89,W
0304:  MOVWF  01
0306:  MOVLW  00
0308:  ADDWFC x8A,W
030A:  MOVWF  03
030C:  MOVF   01,W
030E:  MOVWF  x8B
0310:  MOVLB  0
0312:  MOVFF  03,28C
0316:  MOVLB  2
0318:  MOVF   x84,W
031A:  MOVWF  FE9
031C:  MOVLB  0
031E:  MOVFF  285,FEA
0322:  SWAPF  FEF,W
0324:  MOVWF  00
0326:  RRCF   00,F
0328:  MOVLW  07
032A:  ANDWF  00,F
032C:  MOVF   00,W
032E:  MOVLB  2
0330:  MOVWF  x8E
0332:  MOVLB  0
0334:  MOVFF  28C,FEA
0338:  MOVFF  28B,FE9
033C:  MOVFF  28E,FEF
....................         ptr++;                                  // Point to SIDL  
0340:  MOVLB  2
0342:  INCF   x84,F
0344:  BTFSC  FD8.2
0346:  INCF   x85,F
....................         Value->BYTES.BYTE_1 |= (*ptr >> 5);     // Copy SIDL<7:6> to SID<2:0>  
0348:  MOVF   x89,W
034A:  MOVWF  01
034C:  MOVF   x8A,W
034E:  MOVWF  03
0350:  MOVF   01,W
0352:  MOVWF  x8B
0354:  MOVLB  0
0356:  MOVFF  03,28C
035A:  MOVFF  03,FEA
035E:  MOVFF  28B,FE9
0362:  MOVFF  FEF,28D
0366:  MOVLB  2
0368:  MOVF   x84,W
036A:  MOVWF  FE9
036C:  MOVLB  0
036E:  MOVFF  285,FEA
0372:  SWAPF  FEF,W
0374:  MOVWF  00
0376:  RRCF   00,F
0378:  MOVLW  07
037A:  ANDWF  00,F
037C:  MOVF   00,W
037E:  MOVLB  2
0380:  IORWF  x8D,W
0382:  MOVWF  x8F
0384:  MOVLB  0
0386:  MOVFF  28C,FEA
038A:  MOVFF  28B,FE9
038E:  MOVFF  28F,FEF
....................         Value->BYTES.BYTE_3 = 0x00;  
0392:  MOVLW  02
0394:  MOVLB  2
0396:  ADDWF  x89,W
0398:  MOVWF  FE9
039A:  MOVLW  00
039C:  ADDWFC x8A,W
039E:  MOVWF  FEA
03A0:  CLRF   FEF
....................         Value->BYTES.BYTE_4 = 0x00;  
03A2:  MOVLW  03
03A4:  ADDWF  x89,W
03A6:  MOVWF  FE9
03A8:  MOVLW  00
03AA:  ADDWFC x8A,W
03AC:  MOVWF  FEA
03AE:  CLRF   FEF
....................     }  
....................     else  
....................     {  
03B0:  GOTO   0556
....................         // Extended Identifier  
....................         Value->BYTES.BYTE_3 = (*ptr << 5);      // Copy SIDH<2:0> to EID<23:21>  
03B4:  MOVLW  02
03B6:  ADDWF  x89,W
03B8:  MOVWF  01
03BA:  MOVLW  00
03BC:  ADDWFC x8A,W
03BE:  MOVWF  03
03C0:  MOVF   01,W
03C2:  MOVWF  x8B
03C4:  MOVLB  0
03C6:  MOVFF  03,28C
03CA:  MOVLB  2
03CC:  MOVF   x84,W
03CE:  MOVWF  FE9
03D0:  MOVLB  0
03D2:  MOVFF  285,FEA
03D6:  SWAPF  FEF,W
03D8:  MOVWF  00
03DA:  RLCF   00,F
03DC:  MOVLW  E0
03DE:  ANDWF  00,F
03E0:  MOVF   00,W
03E2:  MOVLB  2
03E4:  MOVWF  x8E
03E6:  MOVLB  0
03E8:  MOVFF  28C,FEA
03EC:  MOVFF  28B,FE9
03F0:  MOVFF  28E,FEF
....................         Value->BYTES.BYTE_4 = (*ptr >> 3);      // Copy SIDH<7:3> to EID<29:25>  
03F4:  MOVLW  03
03F6:  MOVLB  2
03F8:  ADDWF  x89,W
03FA:  MOVWF  01
03FC:  MOVLW  00
03FE:  ADDWFC x8A,W
0400:  MOVWF  03
0402:  MOVF   01,W
0404:  MOVWF  x8B
0406:  MOVLB  0
0408:  MOVFF  03,28C
040C:  MOVLB  2
040E:  MOVF   x84,W
0410:  MOVWF  FE9
0412:  MOVLB  0
0414:  MOVFF  285,FEA
0418:  RRCF   FEF,W
041A:  MOVWF  00
041C:  RRCF   00,F
041E:  RRCF   00,F
0420:  MOVLW  1F
0422:  ANDWF  00,F
0424:  MOVF   00,W
0426:  MOVLB  2
0428:  MOVWF  x8E
042A:  MOVLB  0
042C:  MOVFF  28C,FEA
0430:  MOVFF  28B,FE9
0434:  MOVFF  28E,FEF
....................         ptr++;                          		// Point to SIDL  
0438:  MOVLB  2
043A:  INCF   x84,F
043C:  BTFSC  FD8.2
043E:  INCF   x85,F
....................         Value->BYTES.BYTE_3 |= (*ptr & 0x03);   // Copy SIDH<1:0> to EID<17:16>  
0440:  MOVLW  02
0442:  ADDWF  x89,W
0444:  MOVWF  01
0446:  MOVLW  00
0448:  ADDWFC x8A,W
044A:  MOVWF  03
044C:  MOVF   01,W
044E:  MOVWF  x8B
0450:  MOVLB  0
0452:  MOVFF  03,28C
0456:  MOVFF  03,FEA
045A:  MOVFF  28B,FE9
045E:  MOVFF  FEF,28D
0462:  MOVLB  2
0464:  MOVF   x84,W
0466:  MOVWF  FE9
0468:  MOVLB  0
046A:  MOVFF  285,FEA
046E:  MOVF   FEF,W
0470:  ANDLW  03
0472:  MOVLB  2
0474:  IORWF  x8D,W
0476:  MOVWF  x8F
0478:  MOVLB  0
047A:  MOVFF  28C,FEA
047E:  MOVFF  28B,FE9
0482:  MOVFF  28F,FEF
....................         // Bug-Fix NKR 11/20/00  
....................         Value->BYTES.BYTE_3 |= ((*ptr & 0xe0) >> 3);  // Copy SIDL<7:6> to EID<20:18>  
0486:  MOVLW  02
0488:  MOVLB  2
048A:  ADDWF  x89,W
048C:  MOVWF  01
048E:  MOVLW  00
0490:  ADDWFC x8A,W
0492:  MOVWF  03
0494:  MOVF   01,W
0496:  MOVWF  x8B
0498:  MOVLB  0
049A:  MOVFF  03,28C
049E:  MOVFF  03,FEA
04A2:  MOVFF  28B,FE9
04A6:  MOVFF  FEF,28D
04AA:  MOVLB  2
04AC:  MOVF   x84,W
04AE:  MOVWF  FE9
04B0:  MOVLB  0
04B2:  MOVFF  285,FEA
04B6:  MOVF   FEF,W
04B8:  ANDLW  E0
04BA:  MOVWF  00
04BC:  RRCF   00,F
04BE:  RRCF   00,F
04C0:  RRCF   00,F
04C2:  MOVLW  1F
04C4:  ANDWF  00,F
04C6:  MOVF   00,W
04C8:  MOVLB  2
04CA:  IORWF  x8D,W
04CC:  MOVWF  x90
04CE:  MOVLB  0
04D0:  MOVFF  28C,FEA
04D4:  MOVFF  28B,FE9
04D8:  MOVFF  290,FEF
....................         ptr++;                          		// Point to EIDH  
04DC:  MOVLB  2
04DE:  INCF   x84,F
04E0:  BTFSC  FD8.2
04E2:  INCF   x85,F
....................         Value->BYTES.BYTE_2 = *ptr;             // Copy EIDH<15:8> to EID<15:8>  
04E4:  MOVLW  01
04E6:  ADDWF  x89,W
04E8:  MOVWF  01
04EA:  MOVLW  00
04EC:  ADDWFC x8A,W
04EE:  MOVWF  03
04F0:  MOVF   01,W
04F2:  MOVWF  x8B
04F4:  MOVLB  0
04F6:  MOVFF  03,28C
04FA:  MOVLB  2
04FC:  MOVF   x84,W
04FE:  MOVWF  FE9
0500:  MOVLB  0
0502:  MOVFF  285,FEA
0506:  MOVF   FEF,W
0508:  MOVLB  2
050A:  MOVWF  x8D
050C:  MOVLB  0
050E:  MOVFF  28C,FEA
0512:  MOVFF  28B,FE9
0516:  MOVFF  28D,FEF
....................         ptr++;                                  // Point to EIDL  
051A:  MOVLB  2
051C:  INCF   x84,F
051E:  BTFSC  FD8.2
0520:  INCF   x85,F
....................         Value->BYTES.BYTE_1 = *ptr;             // Copy EIDH<7:0> to EID<7:0>  
0522:  MOVF   x89,W
0524:  MOVWF  01
0526:  MOVF   x8A,W
0528:  MOVWF  03
052A:  MOVF   01,W
052C:  MOVWF  x8B
052E:  MOVLB  0
0530:  MOVFF  03,28C
0534:  MOVLB  2
0536:  MOVF   x84,W
0538:  MOVWF  FE9
053A:  MOVLB  0
053C:  MOVFF  285,FEA
0540:  MOVF   FEF,W
0542:  MOVLB  2
0544:  MOVWF  x8D
0546:  MOVLB  0
0548:  MOVFF  28C,FEA
054C:  MOVFF  28B,FE9
0550:  MOVFF  28D,FEF
0554:  MOVLB  2
....................     }  
.................... }  
0556:  MOVLB  0
0558:  RETLW  00
....................   
....................   
....................   
.................... /*********************************************************************  
....................  * Function:        void CANSetMask(CAN_MASK code,  
....................  *                                  int32 val,  
....................  *                                  BYTE type)  
....................  *  
....................  * PreCondition:    MCU must be in Configuration mode.  If not, all  
....................  *                  values will be ignored.  
....................  *  
....................  * Input:           code    - One of CAN_MASK value  
....................  *                  val     - Actual mask register value.  
....................  *                  type    - Type of message to filter either  
....................  *                            CAN_CONFIG_XTD_MSG or CAN_CONFIG_STD_MSG  
....................  *  
....................  * Output:          Given value is bit adjusted to appropriate buffer  
....................  *                  mask registers.  
....................  *  
....................  * Side Effects:    None  
....................  *  
....................  ********************************************************************/  
....................  void CANSetMask(CAN_MASK code,  
....................                  int32 val,  
....................                  BYTE type)  
....................  {  
....................      BYTE *ptr;  
....................   
....................     // Select appropriate starting address based on given CAN_MASK  
....................     // value.  
....................     if ( code == CAN_MASK_B1 )  
....................         ptr = (BYTE*)&RXM0SIDH;  
*
1FC4:  MOVLB  2
1FC6:  MOVF   x18,F
1FC8:  BTFSS  FD8.2
1FCA:  GOTO   1FDA
1FCE:  MOVLW  0F
1FD0:  MOVWF  x1F
1FD2:  MOVLW  18
1FD4:  MOVWF  x1E
....................     else  
....................         ptr = (BYTE*)&RXM1SIDH;  
1FD6:  GOTO   1FE2
1FDA:  MOVLW  0F
1FDC:  MOVWF  x1F
1FDE:  MOVLW  1C
1FE0:  MOVWF  x1E
....................   
....................     // Convert given 32-bit id value into corresponding register values.  
....................     CANIDToRegs(ptr, val, type);  
1FE2:  MOVLB  0
1FE4:  MOVFF  21F,23D
1FE8:  MOVFF  21E,23C
1FEC:  MOVFF  21C,241
1FF0:  MOVFF  21B,240
1FF4:  MOVFF  21A,23F
1FF8:  MOVFF  219,23E
1FFC:  MOVFF  21D,242
2000:  CALL   1DA2
.................... }  
2004:  RETLW  00
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  * Function:        void CANSetFilter(CAN_FILTER code,  
....................  *                                   int32 val,  
....................  *                                   CAN_CONFIG type)  
....................  *  
....................  * PreCondition:    MCU must be in Configuration mode.  If not, all  
....................  *                  values will be ignored.  
....................  *  
....................  *  
....................  Input:             code    - One of CAN_FILTER value  
....................  *                  val     - Actual filter register value.  
....................  *                  type    - Type of message to filter either  
....................  *                            CAN_CONFIG_XTD_MSG or CAN_CONFIG_STD_MSG  
....................  *  
....................  * Output:          Given value is bit adjusted to appropriate buffer  
....................  *                  filter registers.  
....................  *  
....................  * Side Effects:    None  
....................  ********************************************************************/  
....................  void CANSetFilter(CAN_FILTER code,  
....................                     int32 val,  
....................                     BYTE type)  
....................  {  
....................     BYTE *ptr;  
....................   
....................     // Select appropriate starting address based on given CAN_FILTER  
....................     // code.  
....................     switch(code)  
....................     {  
2006:  MOVLB  2
2008:  MOVF   x18,W
200A:  MOVWF  00
200C:  MOVF   00,F
200E:  MOVLB  0
2010:  BTFSC  FD8.2
2012:  GOTO   2042
2016:  MOVLW  01
2018:  SUBWF  00,W
201A:  BTFSC  FD8.2
201C:  GOTO   204E
2020:  MOVLW  02
2022:  SUBWF  00,W
2024:  BTFSC  FD8.2
2026:  GOTO   205C
202A:  MOVLW  03
202C:  SUBWF  00,W
202E:  BTFSC  FD8.2
2030:  GOTO   206A
2034:  MOVLW  04
2036:  SUBWF  00,W
2038:  BTFSC  FD8.2
203A:  GOTO   2078
203E:  GOTO   2088
....................     case CAN_FILTER_B1_F1:  
....................         ptr = (BYTE*)&RXF0SIDH;  
2042:  MOVLW  0F
2044:  MOVLB  2
2046:  MOVWF  x1F
2048:  CLRF   x1E
....................         break;  
204A:  GOTO   2096
....................   
....................     case CAN_FILTER_B1_F2:  
....................         ptr = (BYTE*)&RXF1SIDH;  
204E:  MOVLW  0F
2050:  MOVLB  2
2052:  MOVWF  x1F
2054:  MOVLW  04
2056:  MOVWF  x1E
....................         break;  
2058:  GOTO   2096
....................   
....................     case CAN_FILTER_B2_F1:  
....................         ptr = (BYTE*)&RXF2SIDH;  
205C:  MOVLW  0F
205E:  MOVLB  2
2060:  MOVWF  x1F
2062:  MOVLW  08
2064:  MOVWF  x1E
....................         break;  
2066:  GOTO   2096
....................   
....................     case CAN_FILTER_B2_F2:  
....................         ptr = (BYTE*)&RXF3SIDH;  
206A:  MOVLW  0F
206C:  MOVLB  2
206E:  MOVWF  x1F
2070:  MOVLW  0C
2072:  MOVWF  x1E
....................         break;  
2074:  GOTO   2096
....................   
....................     case CAN_FILTER_B2_F3:  
....................         ptr = (BYTE*)&RXF4SIDH;  
2078:  MOVLW  0F
207A:  MOVLB  2
207C:  MOVWF  x1F
207E:  MOVLW  10
2080:  MOVWF  x1E
....................         break;  
2082:  GOTO   2096
2086:  MOVLB  0
....................   
....................     default:  
....................         ptr = (BYTE*)&RXF5SIDH;  
2088:  MOVLW  0F
208A:  MOVLB  2
208C:  MOVWF  x1F
208E:  MOVLW  14
2090:  MOVWF  x1E
....................         break;  
2092:  GOTO   2096
....................     }  
....................   
....................     // Convert 32-bit value into register values.  
....................     CANIDToRegs(ptr, val, type);  
2096:  MOVLB  0
2098:  MOVFF  21F,23D
209C:  MOVFF  21E,23C
20A0:  MOVFF  21C,241
20A4:  MOVFF  21B,240
20A8:  MOVFF  21A,23F
20AC:  MOVFF  219,23E
20B0:  MOVFF  21D,242
20B4:  CALL   1DA2
....................   
.................... }  
20B8:  RETLW  00
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  * Function:        BOOLEAN CANSendMessage(int32 id,  
....................  *                                  BYTE *Data,  
....................  *                                  BYTE DataLen,  
....................  *                                  CAN_TX_MSG_FLAGS MsgFlags)  
....................  *  
....................  * PreCondition:    None  
....................  *  
....................  * Input:           id          - CAN message identifier.  
....................  *                                Only 11 or 29 bits may be used  
....................  *                                depending on standard or extended  
....................  *                                message type.  
....................  *                  Data        - Data bytes of upto 8 bytes in length  
....................  *                  DataLen     - Data length from 1 thru 8.  
....................  *                  MsgFlags    - One or more CAN_TX_MSG_FLAGS values ANDed  
....................  *                                together  
....................  *  
....................  * Output:          If at least one empty transmit buffer is found,  
....................  *                  given message is queued to be transmitted. If none  
....................  *                  found within 50 miliseconds a FALSE value is returned.  
....................  *  
....................  * Side Effects:    None  
....................  *  
....................  ********************************************************************/  
.................... BOOLEAN CANSendMessage(int32 id,  
....................                      BYTE* Data,  
....................                      BYTE DataLen,  
....................                      CAN_TX_MSG_FLAGS MsgFlags)  
.................... {  
....................     BYTE i;  
....................     BYTE *ptr;  
....................   
.................... 	// Return FALSE if a TX buffer is not available within 50ms.  
.................... 	i=0;  
*
2576:  MOVLB  2
2578:  CLRF   x39
.................... 	while ((TXB0CON_TXREQ & TXB1CON_TXREQ & TXB2CON_TXREQ) == 1)  
.................... 	{  
257A:  MOVLW  00
257C:  MOVLB  F
257E:  BTFSC  x40.3
2580:  MOVLW  01
2582:  MOVLB  2
2584:  MOVWF  x3C
2586:  MOVLW  00
2588:  MOVLB  F
258A:  BTFSC  x30.3
258C:  MOVLW  01
258E:  MOVLB  2
2590:  ANDWF  x3C,W
2592:  MOVWF  x3D
2594:  MOVLW  00
2596:  MOVLB  F
2598:  BTFSC  x20.3
259A:  MOVLW  01
259C:  MOVLB  2
259E:  ANDWF  x3D,W
25A0:  SUBLW  01
25A2:  BTFSS  FD8.2
25A4:  GOTO   25CC
.................... 		delay_ms(1);			// Delay 1 millisecond  
25A8:  MOVLW  01
25AA:  MOVWF  x3C
25AC:  MOVLB  0
25AE:  CALL   07F4
.................... 		if (++i >= 50)  
.................... 			return FALSE;  
25B2:  MOVLB  2
25B4:  INCF   x39,F
25B6:  MOVF   x39,W
25B8:  SUBLW  31
25BA:  BTFSC  FD8.0
25BC:  GOTO   25C8
25C0:  MOVLW  00
25C2:  MOVWF  01
25C4:  GOTO   26F8
.................... 	}  
25C8:  GOTO   257A
....................   
.................... 	// Find the first empty transmitter.  
....................     if ( TXB0CON_TXREQ == 0 )  
....................     {  
25CC:  MOVLW  00
25CE:  MOVLB  F
25D0:  BTFSC  x40.3
25D2:  MOVLW  01
25D4:  XORLW  00
25D6:  BTFSS  FD8.2
25D8:  GOTO   25E6
....................         // TxBuffer0 is empty.  Set WIN bits to point to TXB0  
....................         CANCON &= 0b11110001;  
25DC:  MOVLW  F1
25DE:  ANDWF  F6F,F
....................         CANCON |= 0b00001000;  
25E0:  BSF    F6F.3
....................     }  
....................     else if ( TXB1CON_TXREQ == 0 )  
25E2:  GOTO   2624
....................     {  
25E6:  MOVLW  00
25E8:  BTFSC  x30.3
25EA:  MOVLW  01
25EC:  XORLW  00
25EE:  BTFSS  FD8.2
25F0:  GOTO   2600
....................         // TxBuffer1 is empty. Set WIN bits to point to TXB1  
....................         CANCON &= 0b11110001;  
25F4:  MOVLW  F1
25F6:  ANDWF  F6F,F
....................         CANCON |= 0b00000110;  
25F8:  MOVLW  06
25FA:  IORWF  F6F,F
....................     }  
....................     else if ( TXB2CON_TXREQ == 0 )  
25FC:  GOTO   2624
....................     {  
2600:  MOVLW  00
2602:  BTFSC  x20.3
2604:  MOVLW  01
2606:  XORLW  00
2608:  BTFSS  FD8.2
260A:  GOTO   2618
....................         // TxBuffer2 is empty. Set WIN bits to point to TXB2  
....................         CANCON &= 0b11110001;  
260E:  MOVLW  F1
2610:  ANDWF  F6F,F
....................         CANCON |= 0b00000100;  
2612:  BSF    F6F.2
....................     }  
....................     else  
....................         // None of the transmit buffers were empty.  
....................         return FALSE;  
2614:  GOTO   2624
2618:  MOVLW  00
261A:  MOVWF  01
261C:  MOVLB  2
261E:  GOTO   26F8
2622:  MOVLB  F
....................   
....................     /*  
....................      * Now that WIN has remapped RXB0 to empty buffer, simply  
....................      * populate RXB0 buffer, which is really accessing one of the TX buffers  
....................      */  
....................   
....................     // Set transmit priority.  
....................     RXB0CON = MsgFlags & CAN_TX_PRIORITY_BITS;  
2624:  MOVLB  2
2626:  MOVF   x38,W
2628:  ANDLW  03
262A:  MOVWF  F60
....................   
....................     // Populate Extended identifier information only if it is  
....................     // desired.  
....................     if ( !(MsgFlags & CAN_TX_FRAME_BIT) )  
....................         CANIDToRegs((BYTE*)&RXB0SIDH, id, CAN_CONFIG_XTD_MSG);  
262C:  BTFSC  x38.3
262E:  GOTO   265E
2632:  MOVLW  0F
2634:  MOVWF  x3D
2636:  MOVLW  61
2638:  MOVWF  x3C
263A:  MOVLB  0
263C:  MOVFF  234,241
2640:  MOVFF  233,240
2644:  MOVFF  232,23F
2648:  MOVFF  231,23E
264C:  MOVLW  F7
264E:  MOVLB  2
2650:  MOVWF  x42
2652:  MOVLB  0
2654:  CALL   1DA2
....................     else  
....................         CANIDToRegs((BYTE*)&RXB0SIDH, id, CAN_CONFIG_STD_MSG);  
2658:  GOTO   2684
265C:  MOVLB  2
265E:  MOVLW  0F
2660:  MOVWF  x3D
2662:  MOVLW  61
2664:  MOVWF  x3C
2666:  MOVLB  0
2668:  MOVFF  234,241
266C:  MOVFF  233,240
2670:  MOVFF  232,23F
2674:  MOVFF  231,23E
2678:  MOVLW  FF
267A:  MOVLB  2
267C:  MOVWF  x42
267E:  MOVLB  0
2680:  CALL   1DA2
....................   
....................     RXB0DLC = DataLen;  
2684:  MOVFF  237,F65
....................   
....................     if ( !(MsgFlags & CAN_TX_RTR_BIT) )  
....................         RXB0DLC |= 0b01000000;  
2688:  MOVLB  2
268A:  BTFSC  x38.6
268C:  GOTO   2692
2690:  BSF    F65.6
....................   
....................     // Populate data values.  
....................     ptr = (BYTE*)&RXB0D0;  
2692:  MOVLW  0F
2694:  MOVWF  x3B
2696:  MOVLW  66
2698:  MOVWF  x3A
....................     for ( i = 0; i < DataLen; i++ )  
269A:  CLRF   x39
269C:  MOVF   x37,W
269E:  SUBWF  x39,W
26A0:  BTFSC  FD8.0
26A2:  GOTO   26EE
....................         ptr[i] = Data[i];  
26A6:  CLRF   03
26A8:  MOVF   x39,W
26AA:  ADDWF  x3A,W
26AC:  MOVWF  01
26AE:  MOVF   x3B,W
26B0:  ADDWFC 03,F
26B2:  MOVF   01,W
26B4:  MOVWF  x3C
26B6:  MOVLB  0
26B8:  MOVFF  03,23D
26BC:  CLRF   03
26BE:  MOVLB  2
26C0:  MOVF   x39,W
26C2:  ADDWF  x35,W
26C4:  MOVWF  FE9
26C6:  MOVF   x36,W
26C8:  ADDWFC 03,W
26CA:  MOVWF  FEA
26CC:  MOVF   FEF,W
26CE:  CLRF   03
26D0:  MOVWF  x3E
26D2:  MOVLB  0
26D4:  MOVFF  23D,FEA
26D8:  MOVFF  23C,FE9
26DC:  MOVFF  03,FEC
26E0:  MOVF   FED,F
26E2:  MOVFF  23E,FEF
26E6:  MOVLB  2
26E8:  INCF   x39,F
26EA:  GOTO   269C
....................   
....................     /*  
....................      * Mark this buffer as ready to start transmit.  
....................      * We are not using C bit field structure because RXB0 registers  
....................      * are remapped to one of the empty transmit buffers and their  
....................      * bit3 is not same as RXB0CON bit3.  To avoid confusion, in-line  
....................      * assembly is used to directly set bit 3 of corresponding TXBnCON  
....................      * register.  
....................      */  
....................   
....................      #asm  
....................      bsf RXB0CON, 3  
26EE:  BSF    F60.3
....................      #endasm  
....................       
.................... /*  
....................      * Restore CAN buffer mapping so that subsequent access to RXB0  
....................      * buffers are to the real RXB0 buffer.  
....................      */  
....................     CANCON &= 0b11110001;  
26F0:  MOVLW  F1
26F2:  ANDWF  F6F,F
....................   
....................     return TRUE;  
26F4:  MOVLW  01
26F6:  MOVWF  01
.................... }  
26F8:  MOVLB  0
26FA:  RETLW  00
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  * Function:        BOOLEAN CANReceiveMessage(int32 *id,  
....................  *                                  BYTE *Data,  
....................  *                                  BYTE DataLen,  
....................  *                                  CAN_RX_MSG_FLAGS MsgFlags)  
....................  *  
....................  * PreCondition:    None  
....................  *  
....................  * Input:           None  
....................  *  
....................  * Output:          id          - CAN message identifier.  
....................  *                  Data        - Data bytes of upto 8 bytes in length  
....................  *                  DataLen     - Data length from 1 thru 8.  
....................  *                  MsgFlags    - One or CAN_RX_MSG_FLAGS values ANDed  
....................  *                                together  
....................  *  
....................  * Output:          If at least one full receive buffer is found,  
....................  *                  it is extrated and returned.  
....................  *                  If none found FALSE value is returned.  
....................  *  
....................  * Side Effects:    None  
....................  *  
....................  ********************************************************************/  
.................... BOOLEAN CANReceiveMessage(int32 *id,  
....................                         BYTE *Data,  
....................                         BYTE *DataLen,  
....................                         CAN_RX_MSG_FLAGS *MsgFlags)  
.................... {  
....................     BYTE i;  
....................     BYTE *ptr;  
....................     BOOLEAN lbIsItBuffer0;  
....................   
....................     // Start with no error or flags set.  
....................     *MsgFlags = 0x0;  
*
055A:  MOVLB  2
055C:  MOVF   x7E,W
055E:  MOVWF  FE9
0560:  MOVLB  0
0562:  MOVFF  27F,FEA
0566:  CLRF   FEF
....................   
....................     // Find which buffer is ready.  
....................     if ( RXB0CON_RXFUL )  
....................     {  
0568:  BTFSS  F60.7
056A:  GOTO   05CC
....................         // RXBuffer0 is full.  
....................         CANCON &= 0b11110001;  
056E:  MOVLW  F1
0570:  ANDWF  F6F,F
....................   
....................         lbIsItBuffer0 = TRUE;  
0572:  MOVLB  2
0574:  BSF    x83.0
....................   
....................         // Clear the received flag.  
....................         PIR3_RXB0IF = 0;  
0576:  BCF    FA4.0
....................   
....................         // Record and forget any previous overflow  
....................         if ( COMSTAT_RX0OVFL )  
....................         {  
0578:  BTFSS  F74.7
057A:  GOTO   0596
....................             *MsgFlags |= CAN_RX_OVERFLOW;  
057E:  MOVLB  0
0580:  MOVLB  2
0582:  MOVF   x7E,W
0584:  MOVWF  FE9
0586:  MOVLB  0
0588:  MOVFF  27F,FEA
058C:  MOVF   FEF,W
058E:  IORLW  08
0590:  MOVWF  FEF
....................             COMSTAT_RX0OVFL = 0;  
0592:  BCF    F74.7
0594:  MOVLB  2
....................         }  
....................   
....................         if ( RXB0CON_RX0DBEN )  
....................         {  
0596:  BTFSS  F60.2
0598:  GOTO   05C6
....................             *MsgFlags |= RXB0CON & CAN_RX_FILTER_BITS;  
059C:  MOVLB  0
059E:  MOVLB  2
05A0:  MOVF   x7E,W
05A2:  MOVWF  FE9
05A4:  MOVLB  0
05A6:  MOVFF  27F,FEA
05AA:  MOVF   F60,W
05AC:  ANDLW  07
05AE:  IORWF  FEF,W
05B0:  MOVWF  FEF
....................             *MsgFlags &= 0x01;  
05B2:  MOVLB  2
05B4:  MOVF   x7E,W
05B6:  MOVWF  FE9
05B8:  MOVLB  0
05BA:  MOVFF  27F,FEA
05BE:  MOVF   FEF,W
05C0:  ANDLW  01
05C2:  MOVWF  FEF
05C4:  MOVLB  2
....................         }  
....................     }  
....................     else if ( RXB1CON_RXFUL )  
05C6:  GOTO   0658
05CA:  MOVLB  0
....................     {  
05CC:  MOVLB  F
05CE:  BTFSS  x50.7
05D0:  GOTO   064C
....................         // RXBuffer1 is full  
....................         CANCON &= 0b11110001;  
05D4:  MOVLW  F1
05D6:  ANDWF  F6F,F
....................         CANCON |= 0b00001010;  
05D8:  MOVLW  0A
05DA:  IORWF  F6F,F
....................   
....................         lbIsItBuffer0 = FALSE;  
05DC:  MOVLB  2
05DE:  BCF    x83.0
....................   
....................         // Clear the received flag.  
....................         PIR3_RXB1IF = 0;  
05E0:  BCF    FA4.1
....................   
....................         // Record and forget any previous overflow  
....................         if ( COMSTAT_RX1OVFL )  
....................         {  
05E2:  BTFSS  F74.6
05E4:  GOTO   0600
....................             *MsgFlags |= CAN_RX_OVERFLOW;  
05E8:  MOVLB  0
05EA:  MOVLB  2
05EC:  MOVF   x7E,W
05EE:  MOVWF  FE9
05F0:  MOVLB  0
05F2:  MOVFF  27F,FEA
05F6:  MOVF   FEF,W
05F8:  IORLW  08
05FA:  MOVWF  FEF
....................             COMSTAT_RX1OVFL = 0;  
05FC:  BCF    F74.6
05FE:  MOVLB  2
....................         }  
....................   
....................         *MsgFlags |= RXB1CON & CAN_RX_FILTER_BITS;  
0600:  MOVLB  0
0602:  MOVLB  2
0604:  MOVF   x7E,W
0606:  MOVWF  FE9
0608:  MOVLB  0
060A:  MOVFF  27F,FEA
060E:  MOVLB  F
0610:  MOVF   x50,W
0612:  ANDLW  07
0614:  IORWF  FEF,W
0616:  MOVWF  FEF
....................         if ( *MsgFlags < 0x02 )  
....................             *MsgFlags |= CAN_RX_DBL_BUFFERED;  
0618:  MOVLB  0
061A:  MOVFF  27F,03
061E:  MOVLB  2
0620:  MOVF   x7E,W
0622:  MOVWF  FE9
0624:  MOVLB  0
0626:  MOVFF  27F,FEA
062A:  MOVF   FEF,W
062C:  SUBLW  01
062E:  BTFSS  FD8.0
0630:  GOTO   0646
0634:  MOVLB  2
0636:  MOVF   x7E,W
0638:  MOVWF  FE9
063A:  MOVLB  0
063C:  MOVFF  27F,FEA
0640:  MOVF   FEF,W
0642:  IORLW  80
0644:  MOVWF  FEF
....................     }  
....................     else  
....................         return FALSE;  
0646:  GOTO   0656
064A:  MOVLB  F
064C:  MOVLW  00
064E:  MOVWF  01
0650:  GOTO   078E
0654:  MOVLB  0
0656:  MOVLB  2
....................   
....................     // Retrieve message length.  
....................     *DataLen = RXB0DLC & 0b00001111;  
0658:  MOVLB  0
065A:  MOVLB  2
065C:  MOVF   x7C,W
065E:  MOVWF  FE9
0660:  MOVLB  0
0662:  MOVFF  27D,FEA
0666:  MOVF   F65,W
0668:  ANDLW  0F
066A:  MOVWF  FEF
....................   
....................     // Determine whether this was RTR or not.  
....................     if ( RXB0DLC_RTR )  
....................         *MsgFlags |= CAN_RX_RTR_FRAME;  
066C:  BTFSS  F65.6
066E:  GOTO   0684
0672:  MOVLB  2
0674:  MOVF   x7E,W
0676:  MOVWF  FE9
0678:  MOVLB  0
067A:  MOVFF  27F,FEA
067E:  MOVF   FEF,W
0680:  IORLW  40
0682:  MOVWF  FEF
....................   
....................     // Retrieve EIDX bytes only if this is extended message  
....................     if ( RXB0SIDL_EXID )  
....................     {  
0684:  BTFSS  F62.3
0686:  GOTO   06C0
....................         *MsgFlags |= CAN_RX_XTD_FRAME;  
068A:  MOVLB  2
068C:  MOVF   x7E,W
068E:  MOVWF  FE9
0690:  MOVLB  0
0692:  MOVFF  27F,FEA
0696:  MOVF   FEF,W
0698:  IORLW  20
069A:  MOVWF  FEF
....................   
....................         RegsToCANID((BYTE*)&RXB0SIDH, id, CAN_CONFIG_XTD_MSG);  
069C:  MOVLW  0F
069E:  MOVLB  2
06A0:  MOVWF  x85
06A2:  MOVLW  61
06A4:  MOVWF  x84
06A6:  MOVLB  0
06A8:  MOVFF  279,287
06AC:  MOVFF  278,286
06B0:  MOVLW  F7
06B2:  MOVLB  2
06B4:  MOVWF  x88
06B6:  MOVLB  0
06B8:  CALL   02B0
....................     }  
....................     else  
....................         RegsToCANID((BYTE*)&RXB0SIDH, id, CAN_CONFIG_STD_MSG);  
06BC:  GOTO   06E0
06C0:  MOVLW  0F
06C2:  MOVLB  2
06C4:  MOVWF  x85
06C6:  MOVLW  61
06C8:  MOVWF  x84
06CA:  MOVLB  0
06CC:  MOVFF  279,287
06D0:  MOVFF  278,286
06D4:  MOVLW  FF
06D6:  MOVLB  2
06D8:  MOVWF  x88
06DA:  MOVLB  0
06DC:  CALL   02B0
....................   
....................     // Get message data itself  
.................... 	if (Data)   // check if caller's pointer is null before copying out the message  
.................... 	{  
06E0:  MOVLB  2
06E2:  MOVF   x7A,W
06E4:  IORWF  x7B,W
06E6:  BTFSC  FD8.2
06E8:  GOTO   0754
....................         ptr = (BYTE*)&RXB0D0;  
06EC:  MOVLW  0F
06EE:  MOVWF  x82
06F0:  MOVLW  66
06F2:  MOVWF  x81
....................         for ( i = 0; i < *DataLen; i++ )  
06F4:  CLRF   x80
06F6:  MOVLB  0
06F8:  MOVFF  27D,03
06FC:  MOVLB  2
06FE:  MOVF   x7C,W
0700:  MOVWF  FE9
0702:  MOVLB  0
0704:  MOVFF  27D,FEA
0708:  MOVF   FEF,W
070A:  MOVLB  2
070C:  SUBWF  x80,W
070E:  BTFSC  FD8.0
0710:  GOTO   0754
....................             Data[i] = ptr[i];  
0714:  CLRF   03
0716:  MOVF   x80,W
0718:  ADDWF  x7A,W
071A:  MOVWF  01
071C:  MOVF   x7B,W
071E:  ADDWFC 03,F
0720:  MOVF   01,W
0722:  MOVWF  x84
0724:  MOVLB  0
0726:  MOVFF  03,285
072A:  CLRF   03
072C:  MOVLB  2
072E:  MOVF   x80,W
0730:  ADDWF  x81,W
0732:  MOVWF  FE9
0734:  MOVF   x82,W
0736:  ADDWFC 03,W
0738:  MOVWF  FEA
073A:  MOVF   FEF,W
073C:  MOVWF  x86
073E:  MOVLB  0
0740:  MOVFF  285,FEA
0744:  MOVFF  284,FE9
0748:  MOVFF  286,FEF
074C:  MOVLB  2
074E:  INCF   x80,F
0750:  GOTO   06F6
.................... 	}  
....................   
....................     // Restore default RXB0 mapping.  
....................     CANCON &= 0b11110001;  
0754:  MOVLW  F1
0756:  ANDWF  F6F,F
....................   
....................     // Record and Clear any previous invalid message bit flag.  
....................     if ( PIR3_IRXIF )  
....................     {  
0758:  BTFSS  FA4.7
075A:  GOTO   0776
....................         *MsgFlags |= CAN_RX_INVALID_MSG;  
075E:  MOVLB  0
0760:  MOVLB  2
0762:  MOVF   x7E,W
0764:  MOVWF  FE9
0766:  MOVLB  0
0768:  MOVFF  27F,FEA
076C:  MOVF   FEF,W
076E:  IORLW  10
0770:  MOVWF  FEF
....................         PIR3_IRXIF = 0;  
0772:  BCF    FA4.7
0774:  MOVLB  2
....................     }  
....................   
....................     if ( lbIsItBuffer0 )  
....................         RXB0CON_RXFUL = 0;  
0776:  BTFSS  x83.0
0778:  GOTO   0782
077C:  BCF    F60.7
....................     else  
....................         RXB1CON_RXFUL = 0;  
077E:  GOTO   0788
0782:  MOVLB  F
0784:  BCF    x50.7
0786:  MOVLB  2
....................   
....................     return TRUE;  
0788:  MOVLW  01
078A:  MOVWF  01
078C:  MOVLB  F
.................... }  
078E:  MOVLB  0
0790:  RETLW  00
....................   
....................   
....................   
....................  
.................... #include "Vehicle.c" 
....................  //------------------------------------------------------------------------------  
.................... // File: Vehicle  
.................... //  
.................... // Purpose: Vehicle communication and parsing routines.  
.................... //  
.................... // TBD - bit_test() takes too much ROM, might be able to bit mask and save space.  
.................... //  
.................... // Change History:  
.................... // Date		Author		Description  
.................... //          Lafreniere	Created  
.................... //------------------------------------------------------------------------------  
.................... #include "Vehicle.h" 
....................  //------------------------------------------------------------------------------  
.................... // File: Vehicle  
.................... //  
.................... // Purpose: Vehicle communication and parsing routines.   
.................... //  
.................... // Change History:  
.................... // Date		Author		Description  
.................... //          Lafreniere	Created  
.................... //------------------------------------------------------------------------------  
.................... #ifndef VEHICLE_H  
.................... #define VEHICLE_H  
....................   
.................... void VehSendRecv();  
....................   
.................... #endif  
....................  
.................... #include "Globals.h" 
....................  //------------------------------------------------------------------------------  
.................... // File: Globals  
.................... //  
.................... // Purpose: Project global variables.  
.................... //  
.................... // Change History:  
.................... // Date		Author		Description  
.................... //          Lafreniere	Created  
.................... //------------------------------------------------------------------------------  
.................... #ifndef GLOBALS_H  
.................... #define GLOBALS_H  
....................   
.................... #include "Const.h"  
.................... #include "Timer.h"  
....................                    
.................... typedef struct   
.................... {  
....................     int8 comType : 3;  
....................     int8 firstResp : 1;  
.................... 	int8 forceInitCAN : 1;  
....................     int8 canModeChanged : 1;  // true when mode changes (e.g. 250kb to 500kb, or SI to EI)  
....................     int8 adapterLocked : 1;  
.................... 	int8 enableLLineXmit : 1; 		// transmit at 10.4 on both K and L lines (default is K line only)  
.................... 	int8 enableIso9600Baud : 1;		// transmit ISO at 9600 if true, false means 10.4k (default is 10.4k)  
.................... 	int8 enableIso5msByteDelay : 1; // true means 5mS between each byte sent to vehicle, false no delay (default is true)  
.................... 	int8 enableIsoChecksum : 1;		// add checksum byte to ISO messages if true, no byte added if false (default is true)  
.................... } Flags;  
....................   
.................... int8 gDevid1;  
.................... int8 gDevid2;  
....................   
.................... Flags gFlags = { MODE_ISO, FALSE };  
.................... int8 gError = ERR_NONE;  
.................... int8 gErrorExtraData1 = 0;  
.................... int8 gErrorExtraData2 = 0;  
.................... int8 gErrorExtraData3 = 0;  
....................   
.................... int8 gHostBuf[HOST_RECV_MSG_SIZE];  
.................... //*** #locate gHostBuf=0x2d  // pic18f248 should not require ram to be managed  
.................... int8 gHostBufCnt = 0;  
.................... int16 gHostRecvTimeout = 0;  
....................   
.................... int8 gVehicleBuf[VEHICLE_MAX_MSGS][VEHICLE_MSG_SIZE];  
.................... //*** #locate gVehicleBuf=0xa0  
....................   
.................... int8 gVehicleBufCnt = 0;  
....................   
.................... int8 gCurrentCmd = 0;   // current command sent from host  
.................... int8 gLastCmd = 0;      // last command sent from host  
....................   
.................... int32 gP2can = HST_FIFTY_MS;  
....................   
.................... // decyption variables  
.................... int16  gLfsr;  
.................... //int8 gLast;  
....................   
.................... #endif  
....................  
.................... #include "Const.h" 
....................  //------------------------------------------------------------------------------  
.................... // File: Const  
.................... //  
.................... // Purpose: Project constants.  
.................... //  
.................... // Change History:  
.................... // Date		Author		Description  
.................... //          Lafreniere	Created  
.................... //------------------------------------------------------------------------------  
.................... #ifndef CONST_H  
.................... #define CONST_H  
....................   
.................... #ifdef DEBUG  
....................     #define TRACE(char) Trace(char);  
.................... #else  
....................     #define TRACE(char)   
.................... #endif  
....................   
.................... // software revision  
.................... #define SOFTWARE_REV            0x08  
....................   
.................... #define MAX_ECU				8 	// per ISO 15675-4 7.3.3. max ECUs is 8  
....................   
.................... #define DEVID1_ADDR 0x3FFFFEL  
.................... #define DEVID2_ADDR 0x3FFFFFL   
....................   
.................... // The old 18F248 and the new 18F2480 have some differences, mostly in the analog  
.................... // to digital converter. Using _DEVID2 check the processor version.   
.................... #define VER_18F248				0x08  
.................... //#define VER_18F2480 					  
....................   
.................... // destination address  
.................... #define DESTINATION_ADDR        0x2d  
....................   
.................... // from host msg byte positions  
.................... #define IDX_HOST_DESTINATION        0  
.................... #define IDX_HOST_COMMAND            1  
.................... #define IDX_HOST_BYTE_COUNT         2  
.................... #define IDX_HOST_START_DATA         3  
.................... #define IDX_HOST_CHECKSUM           14  
....................   
.................... // to host msg byte positions  
.................... #define IDX_VEHICLE_DESTINATION     0  
.................... #define IDX_VEHICLE_COMMAND         1  
.................... #define IDX_VEHICLE_CHECKSUM        13  
....................   
.................... // max size of all messages  
.................... #define HOST_RECV_MSG_SIZE          15      // from host size including all non-OBD II bytes  
.................... #define HOST_SEND_MSG_SIZE          14      // to host size  
.................... #define VEHICLE_MSG_SIZE            12      // to/from max vehicle size, not as sent to host (RSP byte not included)   
.................... #define VEHICLE_MAX_MSGS            32      // number of VEHICLE_MSG_SIZE we can store in RAM  
....................   
.................... // error codes returned to host  
.................... #define ERR_NONE                        0x00   // ERR_NONE must be 0!  
.................... #define ERR_NOT_IMPLEMENTED             0x01  
.................... #define ERR_BAD_CHECKSUM                0x02  
.................... #define ERR_ISO_NO_SYNC                 0x03  
.................... #define ERR_ISO_INCORRECT_INV_ADDR      0x04  
.................... #define ERR_ISO_NO_RESPONSE             0x05  
.................... #define ERR_J1850_NO_RESPONSE           0x07  
.................... #define ERR_ISO_BAD_CHECKSUM            0x08  
.................... #define ERR_J1850_BAD_CRC               0x09      
.................... #define ERR_KWP_BAUD_TOO_SLOW           0x0b    // not used  
.................... #define ERR_KWP_NO_RESPONSE             0x0c    // not used  
.................... #define ERR_KWP_INCORRECT_SYNC          0x0d    // not used  
.................... #define ERR_ISO_NOT_ENABLED             0x10    // not used  
.................... #define ERR_J1850_VPW_NOT_ENABLED       0x11    // not used  
.................... #define ERR_J1850_PWM_NOT_ENABLED       0x12    // not used  
.................... #define ERR_KWP_NOT_ENABLED             0x13    // not used  
.................... #define ERR_VW_PASS_THRU_NOT_ENABLED    0x14    // not used  
.................... #define ERR_CAN_NO_RESPONSE             0x15	// COMSTAT CAN register returned as extra data  
.................... #define ERR_CAN_RX_OVERFLOW             0x16  
.................... #define ERR_CAN_TX_BUFFER_UNAVAIL       0x18  
.................... #define ERR_CAN_RX_MESSAGE_LEN_WRONG    0x19  
.................... #define ERR_CAN_ERROR_INTERRUPT			0x1A	// COMSTAT CAN register returned as extra data  
.................... #define ERR_CAN_INVALID_MSG_INTERRUPT   0x1B    // TXBnCON CAN register returned as extra data 1, 2 and 3  
.................... #define ERR_ISO_INV_ADDR_NOT_RECEIVED	0x1F  
.................... #define ERR_ISO_SYNC_BYTE_NOT_RECEIVED	0x20  
....................   
.................... #define ERR_WRONG_DESTINATION           0x80      
.................... #define ERR_BYTE_COUNT_TOO_LARGE        0x81  
.................... #define ERR_J1850_FRAMING_ERROR         0x82  
.................... #define ERR_J1850_MSG_OVERFLOW          0x83   
.................... #define ERR_ISO_NO_KEYBYTE              0x84  
.................... #define ERR_ADAPTER_LOCKED              0x85  
.................... #define ERR_INVALID_NON_VOLATILE_SECTOR 0x86  
.................... #define ERR_NON_VOLATILE_SECTOR_LOCKED  0x87  
....................   
.................... // host-to-adapter commands  
.................... #define CMD_ISO_WITH_5_BAUD             0x01  
.................... #define CMD_VPW                         0x02  
.................... #define CMD_PWM                         0x04  
.................... #define CMD_CAN_SI_250KB                0x08      
.................... #define CMD_ISO                         0x10  
.................... #define CMD_VW_PASS_THRU_WITH_5_BAUD    0x20    // not used  
.................... #define CMD_VW_PASS_THRU_WITHOUT_5_BAUD 0x40    // not used  
.................... #define CMD_PWM_WITH_IFR                0x80  
.................... #define CMD_ISO_1ST_RESPONSE            0x81  
.................... #define CMD_VPW_1ST_RESPONSE            0x82  
.................... #define CMD_ATOD_CONVERSION             0x83    // not used  
.................... #define CMD_PWM_1ST_RESPONSE            0x84  
.................... #define CMD_KWP_WITH_5_BAUD             0x85  
.................... #define CMD_KWP_REPORT_KW1_KW2          0x86    // not used  
.................... #define CMD_KWP_FAST_INIT               0x87  
.................... #define CMD_KWP                         0x88  
.................... #define CMD_KWP_1ST_RESPONSE            0x89  
.................... #define CMD_CAN_SI_500KB                0x90  
.................... #define CMD_CAN_EI_250KB                0x91  
.................... #define CMD_CAN_EI_500KB                0x92  
.................... #define CMD_CAN_SI_250KB_1ST            0x93  
.................... #define CMD_CAN_SI_500KB_1ST            0x94  
.................... #define CMD_CAN_EI_250KB_1ST            0x95  
.................... #define CMD_CAN_EI_500KB_1ST            0x96  
.................... #define CMD_CAN_SET_STD_MASK_FILTER		0x97  
.................... #define CMD_CAN_SET_XTD_MASK_FILTER		0x98  
.................... #define CMD_CAN_SET_P2_CAN_TIMEOUT		0x99  
.................... #define CMD_CAN_SI_250KB_FBGO			0x9A	// FBGO = fast bus get off  
.................... #define CMD_CAN_SI_500KB_FBGO			0x9B	// FBGO = fast bus get off  
.................... #define CMD_CAN_EI_250KB_FBGO			0x9C	// FBGO = fast bus get off  
.................... #define CMD_CAN_EI_500KB_FBGO			0x9D	// FBGO = fast bus get off  
.................... #define CMD_CAN_SI_250KB_LISTEN			0x9E	  
.................... #define CMD_CAN_SI_500KB_LISTEN			0x9F	  
.................... #define CMD_CAN_EI_250KB_LISTEN			0xA0	  
.................... #define CMD_CAN_EI_500KB_LISTEN			0xA1  
.................... #define CMD_CAN_SI_250KB_NO_RESPONSE	0xA2	  
.................... #define CMD_CAN_SI_500KB_NO_RESPONSE	0xA3	  
.................... #define CMD_CAN_EI_250KB_NO_RESPONSE	0xA4	  
.................... #define CMD_CAN_EI_500KB_NO_RESPONSE	0xA5  
.................... #define CMD_ISO_NO_RESPONSE				0xA6  
.................... #define CMD_ISO_ENABLE_L_LINE_XMIT		0xA9  
.................... #define CMD_ISO_SET_9600_BAUD			0xAB  
.................... #define CMD_ISO_CHECKSUM_ENABLE			0xAC  
.................... #define CMD_ISO_5MS_BYTE_DELAY_ENABLE	0xAD  
.................... #define CMD_UNLOCK_ADAPTER              0xB0	  
.................... #define CMD_READ_EEPROM					0xB9  
.................... #define CMD_WRITE_EEPROM				0xBA  
.................... #define CMD_KWP_FAST_INIT_9600			0xC4  
.................... #define CMD_READ_BATTERY_VOLTAGE		0xF0  
....................   
.................... // adapter-to-host commands  
.................... #define CMD_ERROR                       0x80  
.................... #define CMD_ISO_MSG                     0x81  
.................... #define CMD_VPW_MSG                     0x82  
.................... #define CMD_PWM_MSG                     0x84  
.................... #define CMD_CAN_MSG                     0x88  
.................... #define CMD_KWP_MSG                     0x01  
.................... #define CMD_LOCAL_DATA					0x40  
....................   
.................... // transmit modes (must fit in 3-bits!)  
.................... #define MODE_ISO                 0x00  
.................... #define MODE_VPW                 0x01  
.................... #define MODE_PWM                 0x02  
.................... #define MODE_KWP                 0x03  
.................... #define MODE_CAN                 0x04  
....................   
.................... // interface capabilites (i.e. what com modes does the adapter support)  
.................... #define CAP_ISO         0x01  
.................... #define CAP_VPW         0x02  
.................... #define CAP_PWM         0x04  
.................... #define CAP_KWP         0x08  
.................... #define CAP_CAN         0x10  
.................... #define CAP_DUAL_CAN	0x20  
.................... #define DASH_DYNO_VER	0x40  
.................... #ifdef DASH_DYNO  
.................... #define CAP_INTERFACE   (CAP_ISO | CAP_VPW | CAP_PWM | CAP_KWP | CAP_CAN | DASH_DYNO_VER)  
.................... #else  
.................... #define CAP_INTERFACE   (CAP_ISO | CAP_VPW | CAP_PWM | CAP_KWP | CAP_CAN)  
.................... #endif  
....................   
.................... #endif   
....................  
.................... #include "Timer.h" 
....................  //------------------------------------------------------------------------------  
.................... // File: Timer  
.................... //  
.................... // Purpose: High speed timer (HST) routines.   
.................... //  
.................... // Change History:  
.................... // Date		Author		Description  
.................... //          Lafreniere	Created  
.................... //------------------------------------------------------------------------------  
.................... #ifndef TIMER_H  
.................... #define TIMER_H  
....................   
.................... #define TIMER1_TIMEOUT          0     // 1.6uS per tick with div set to 8  
.................... #define MS_TO_TICKS(mS) 		((mS * 10000) / 16)	  // 1.6uS per tick  
....................   
.................... // max 16-bit number  
.................... #define HST_TWO_MS              1250  
.................... #define HST_TEN_MS              6250  
.................... #define HST_TWENTY_FIVE_MS      15625  
.................... #define HST_FIFTY_MS            31250  
.................... #define HST_FIVE_HUNDRED_MS		312500	// NOTE: this number exceeds 16-bit timer and must be used with Int32  
.................... #define HST_ONE_S				625000	// NOTE: this number exceeds 16-bit timer and must be used with Int32  
....................   
.................... typedef int16 HstTimer; //TBD DEBUG  
.................... //typedef int32 HstTimer;  
....................               
.................... HstTimer HstGetTicks(void) { return get_timer1(); }  
.................... BOOLEAN HstTestTimer(HstTimer timer, HstTimer ticks);  
.................... BOOLEAN HstTestTimerRetrig(HstTimer *timer, HstTimer ticks);  
.................... HstTimer HstElapsedTime(HstTimer timer);  
....................   
.................... #endif  
....................  
.................... #include "Util.h" 
....................  //------------------------------------------------------------------------------  
.................... // File: Util  
.................... //  
.................... // Purpose: Misc utility routines.   
.................... //  
.................... // Change History:  
.................... // Date		Author		Description  
.................... //          Lafreniere	Created  
.................... //------------------------------------------------------------------------------  
.................... #ifndef UTIL_H  
.................... #define UTIL_H  
....................   
.................... // starting address for the 4-byte EEPOM write protect table  
.................... #define EEPROM_WRITE_PROTECT_TABLE_ADDR 	252  
....................   
.................... // the logical sector size is arbitrary and has nothing to do with the PIC hardware  
.................... #define EEPROM_SECTOR_SIZE 	8  
....................   
.................... void ReadEeprom();  
.................... void ReadEepromLocal(int8 sector);  
.................... void WriteEeprom();  
.................... int8 IsEepromSectorWriteProtected(int8 sector);  
.................... int32 ReadEepromSectorWriteProtectTable();  
.................... void WriteEerpomSectorWriteProtectTable(int32 writeProtectBits);  
.................... void init_ports();  
.................... void Bus_If_Init(void);  
.................... void DecryptBlock(int8 *outbfr, int8 *inbfr);  
.................... int8 IsCmdCAN(int8 cmd);  
.................... int8 IsCmdLocal(int8 cmd);  
.................... int8 IsCmdFBGO(int8 cmd);  
.................... int8 IsCmdListen(int8 cmd);  
.................... int8 IsCmdNoResponse(int8 cmd);  
.................... int8 IsCmdFirstResp(int8 cmd);  
.................... int8 IsCmdStandardId(int8 cmd);  
.................... int8 IsCmd250kb(int8 cmd);  
.................... int8 checksum(int8* pMsg, int8 size);  
.................... int8 crc8(int8* buffer, int8 count);  
.................... int32 StrToInt32(int8* str);  
.................... int8 TraceStr(int8* pMsg, int8 size);  
.................... int8 Trace(int8 msg);  
....................   
.................... #endif  
....................  
.................... #include "PWM-02.h" 
....................  #ifndef PWM_H  
.................... #define PWM_H  
....................   
.................... int8 PWMSend(int16* TxBufferPntr, int8 PWMTxCnt, int8 timeout);  
.................... int8 PWMRecv(int16* RxBufferPntr, int8* RxCntPntr, int8 timeout);  
....................   
.................... #endif  
....................  
.................... #include "VPW-02.h" 
....................  #ifndef VPW_H  
.................... #define VPW_H  
....................   
.................... int8 VPWSend(int16* TxBufferPntr, int8 VPWTxCnt, int8 timeout);  
.................... int8 VPWRecv(int16* RxBufferPntr, int8* RxCntPntr, int8 timeout);  
....................   
.................... #endif  
....................  
.................... #include "CAN18XX8.h" 
....................  /*********************************************************************  
....................  *              PIC18CXX8 CAN C Library Header File  
....................  *********************************************************************  
....................  * FileName:        CAN18CXX8.h  
....................  * Dependencies:    None  
....................  * Date:            09/06/00  
....................  * Processor:       PIC18CXX8  
....................  * Complier:        MPLAB 5.11.00  
....................  * Company:         Microchip Technology, Inc.  
....................  *  
....................  *  
....................  * Software License Agreement  
....................  *  
....................  * The software supplied herewith by Microchip Technology Incorporated  
....................  * (the Company) for its PICmicro Microcontroller is intended and  
....................  * supplied to you, the Companys customer, for use solely and  
....................  * exclusively on Microchip PICmicro Microcontroller products. The  
....................  * software is owned by the Company and/or its supplier, and is  
....................  * protected under applicable copyright laws. All rights are reserved.  
....................  *  Any use in violation of the foregoing restrictions may subject the  
....................  * user to criminal sanctions under applicable laws, as well as to  
....................  * civil liability for the breach of the terms and conditions of this  
....................  * license.  
....................  *  
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,  
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED  
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,  
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR  
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.  
....................  *  
....................  * Author               Date    Comment  
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
....................  * Nilesh Rajbharti     9/6/00  Original        (Rev 1.0)  
....................  * Nilesh Rajbharti     12/1/00 Fixed bugs.  
....................  *                              (CANRegsToID, CANReceiveMessage,  
....................  *                               CANSetMask + Added  
....................  *                               CAN_CONFIG_DBL_BUFFER_ON/OFF option)  
....................  * Nilesh Rajbharti     6/8/01  Renamed CAN_CONFIG_DBL_BUFFERED to  
....................  *                              CAN_RX_DBL_BUFFERED  
....................  *  
....................  * Bernie Lafreniere	8/16/03 Start porting driver to run on CCS C with  
....................  *								the PIC18F248 processor.  
....................  *  
....................  *********************************************************************/  
.................... #ifndef CAN18XX8_H          // To avoid duplicate inclusion  
.................... #define CAN18XX8_H  
....................   
.................... #bit RXB0CON_RX0DBEN    = RXB0CON.2	// PIC18XX8 CAN register.bit mapping  
.................... #bit RXB0CON_RXFUL      = RXB0CON.7  
.................... #bit RXB1CON_RXFUL      = RXB1CON.7  
.................... #bit TXB0CON_TXREQ      = TXB0CON.3  
....................   
.................... #bit TXB1CON_TXPRI0     = TXB1CON.0  
.................... #bit TXB1CON_TXPRI1     = TXB1CON.1  
.................... #bit TXB1CON_TXREQ      = TXB1CON.3  
.................... #bit TXB1CON_TXERR      = TXB1CON.4  
.................... #bit TXB1CON_TXLARB     = TXB1CON.5  
.................... #bit TXB1CON_TXABT      = TXB1CON.6  
....................   
.................... #bit TXB2CON_TXPRI0     = TXB2CON.0  
.................... #bit TXB2CON_TXPRI1     = TXB2CON.1  
.................... #bit TXB2CON_TXREQ      = TXB2CON.3  
.................... #bit TXB2CON_TXERR      = TXB2CON.4  
.................... #bit TXB2CON_TXLARB     = TXB2CON.5  
.................... #bit TXB2CON_TXABT      = TXB2CON.6  
....................   
.................... #bit BRGCON2_SAM        = BRGCON2.6  
.................... #bit BRGCON2_SEG2PHTS   = BRGCON2.7  
.................... #bit BRGCON3_WAKFIL     = BRGCON3.6  
.................... #bit PIR3_RXB0IF        = PIR3.0  
.................... #bit PIR3_RXB1IF        = PIR3.1  
.................... #bit PIR3_IRXIF         = PIR3.7  
.................... #bit COMSTAT_TXB0       = COMSTAT.5  
.................... #bit COMSTAT_TXBP       = COMSTAT.4  
.................... #bit COMSTAT_RXBP       = COMSTAT.3  
.................... #bit COMSTAT_RX1OVFL    = COMSTAT.6  
.................... #bit COMSTAT_RX0OVFL    = COMSTAT.7  
.................... #bit RXB0DLC_RTR        = RXB0DLC.6  
.................... #bit RXB0SIDL_EXID      = RXB0SIDL.3  
.................... #bit CANCON_ABAT        = CANCON.4  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  *  
....................  * union CAN_MESSAGE_ID  
....................  *  
....................  * This union provides abstract data type for CAN message id.  
....................  * It is used for both 11-bit and 29-bit message identifiers.  
....................  * There are multiple union members to be able to access individual  
....................  * parts of it.  
....................  *  
....................  ********************************************************************/  
....................  // Parse-out 29-bit or 11-bit (saved in 32-bit number)  
.................... typedef union _CAN_MESSAGE_ID  
.................... {  
....................     int32 ID;  
....................   
....................     struct  
....................     {  
....................         struct  
....................         {  
....................             int8 SIDL:3;        // SIDL<5:7>  
....................             int8 SIDH:5;        // SIDH<0:4>  
....................         } BYTE1;  
....................         struct  
....................         {  
....................             int8 SIDHU:3;       // SIDH<5:7>  
....................             int8 EIDL_LN:5;     // EIDL<0:4>  
....................         } BYTE2;  
....................         struct  
....................         {  
....................             int8 EIDL_UN:3;     // EIDL<5:7>  
....................             int8 EIDH_LN:5;     // EIDH<0:4>  
....................         } BYTE3;  
....................         struct  
....................         {  
....................             int8 EIDH_UN:3;     // EIDH<5:7>  
....................             int8 EIDHU:2;       // SIDL<0:1>  
....................             int8 PAD:3;			// bcl added name "PAD" to make CCS happy  
....................         } BYTE4;  
....................     } ID_VALS;  
....................   
....................     // This is to allow individual byte access within message id.  
....................     struct  
....................     {  
....................         BYTE BYTE_1;  
....................         BYTE BYTE_2;  
....................         BYTE BYTE_3;  
....................         BYTE BYTE_4;  
....................     } BYTES;  
.................... } CAN_MESSAGE_ID;  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  *  
....................  * enum CAN_TX_MSG_FLAGS  
....................  *  
....................  * This enumeration values define flags related to transmission of a  
....................  * CAN message.  There could be more than one this flag  
....................  * ANDed together to form multiple flags.  
....................  *  
....................  *********************************************************************/  
....................  typedef enum CAN_TX_MSG_FLAGS  
....................  {  
....................     CAN_TX_PRIORITY_BITS= 0b00000011,  
....................     CAN_TX_PRIORITY_0   = 0b11111100,   // XXXXXX00  
....................     CAN_TX_PRIORITY_1   = 0b11111101,   // XXXXXX01  
....................     CAN_TX_PRIORITY_2   = 0b11111110,   // XXXXXX10  
....................     CAN_TX_PRIORITY_3   = 0b11111111,   // XXXXXX11  
....................   
....................     CAN_TX_FRAME_BIT    = 0b00001000,  
....................     CAN_TX_STD_FRAME    = 0b11111111,   // XXXXX1XX  
....................     CAN_TX_XTD_FRAME    = 0b11110111,   // XXXXX0XX  
....................   
....................     CAN_TX_RTR_BIT      = 0b01000000,  
....................     CAN_TX_NO_RTR_FRAME = 0b11111111,   // X1XXXXXX  
....................     CAN_TX_RTR_FRAME    = 0b10111111    // X0XXXXXX  
.................... };  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  *  
....................  * enum CAN_RX_MSG_FLAGS  
....................  *  
....................  * These enumeration values define flags related to reception of a CAN  
....................  * message.  There could be more than one these flags  
....................  * ANDed together to form multiple flags.  
....................  * If a particular bit is set, corresponding meaning is TRUE or else  
....................  * it will be FALSE.  
....................  *  
....................  * e.g.  
....................  *      if (MsgFlag & CAN_RX_OVERFLOW)  
....................  *      {  
....................  *          // Receiver overflow has occured.  We have lost previous  
....................  *          // message.  
....................  *          ...  
....................  *      }  
....................  *  
....................  ********************************************************************/  
.................... typedef enum CAN_RX_MSG_FLAGS  
.................... {  
....................     CAN_RX_FILTER_BITS  = 0b00000111,   // Use this to access filter  
....................                                         // bits  
....................     CAN_RX_FILTER_1     = 0b00000000,  
....................     CAN_RX_FILTER_2     = 0b00000001,  
....................     CAN_RX_FILTER_3     = 0b00000010,  
....................     CAN_RX_FILTER_4     = 0b00000011,  
....................     CAN_RX_FILTER_5     = 0b00000100,  
....................     CAN_RX_FILTER_6     = 0b00000101,  
....................   
....................     CAN_RX_OVERFLOW     = 0b00001000,   // Set if Overflowed else  
....................                                         // cleared  
....................   
....................     CAN_RX_INVALID_MSG  = 0b00010000,   // Set if invalid else  
....................                                         // cleared  
....................   
....................     CAN_RX_XTD_FRAME    = 0b00100000,   // Set if XTD message else  
....................                                         // cleared  
....................   
....................     CAN_RX_RTR_FRAME    = 0b01000000,   // Set if RTR message else  
....................                                         // cleared  
....................   
....................     CAN_RX_DBL_BUFFERED = 0b10000000    // Set if this message was  
....................                                         // hardware double-buffered  
.................... };  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
....................   
.................... /*********************************************************************  
....................  *  
....................  * enum CAN_MASK  
....................  *  
....................  * These enumeration values define mask codes.  Routine CANSetMask()  
....................  * requires this code as one of its arguments.  These enumerations  
....................  * must be used by itself i.e. it cannot be ANDed to form multiple  
....................  * values.  
....................  *  
....................  ********************************************************************/  
.................... typedef enum CAN_MASK  
.................... {  
....................      CAN_MASK_B1,  
....................      CAN_MASK_B2  
.................... };  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  *  
....................  * enum CAN_FILTER  
....................  *  
....................  * These enumeration values define filter codes.  Routine CANSetFilter  
....................  * requires this code as one of its arguments.  These enumerations  
....................  * must be used by itself  
....................  * i.e. it cannot be ANDed to form multiple values.  
....................  *  
....................  ********************************************************************/  
.................... typedef enum CAN_FILTER  
.................... {  
....................     CAN_FILTER_B1_F1,  
....................     CAN_FILTER_B1_F2,  
....................     CAN_FILTER_B2_F1,  
....................     CAN_FILTER_B2_F2,  
....................     CAN_FILTER_B2_F3,  
....................     CAN_FILTER_B2_F4  
.................... };  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  *  
....................  * enum CAN_OP_MODE  
....................  *  
....................  * This enumeration values define codes related to CAN module  
....................  * operation mode. CANSetOperationMode() routine requires this code.  
....................  * These values must be used by itself  
....................  * i.e. it cannot be ANDed to form * multiple values.  
....................  *  
....................  ********************************************************************/  
.................... typedef enum CAN_OP_MODE  
.................... {  
....................     CAN_OP_MODE_BITS    = 0b11100000,   // Use this to access opmode  
....................                                         // bits  
....................     CAN_OP_MODE_NORMAL  = 0b00000000,  
....................     CAN_OP_MODE_SLEEP   = 0b00100000,  
....................     CAN_OP_MODE_LOOP    = 0b01000000,  
....................     CAN_OP_MODE_LISTEN  = 0b01100000,  
....................     CAN_OP_MODE_CONFIG  = 0b10000000  
.................... };  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  *  
....................  * enum CAN_CONFIG_FLAGS  
....................  *  
....................  * These enumeration values define flags related to configuring the CAN  
....................  * module. Routines CANInitialize() and CANSetBaudRate() use these  
....................  * codes. One or more of these values may be ANDed to form multiple  
....................  * flags.  
....................  *  
....................  ********************************************************************/  
.................... //typedef enum CAN_CONFIG_FLAGS  
.................... //{  
.................... #define    CAN_CONFIG_DEFAULT           0b11111111,   // 11111111  
....................   
.................... #define    CAN_CONFIG_PHSEG2_PRG_BIT    0b00000001  
.................... #define    CAN_CONFIG_PHSEG2_PRG_ON     0b11111111   // XXXXXXX1  
.................... #define    CAN_CONFIG_PHSEG2_PRG_OFF    0b11111110   // XXXXXXX0  
....................   
.................... #define    CAN_CONFIG_LINE_FILTER_BIT   0b00000010  
.................... #define    CAN_CONFIG_LINE_FILTER_ON    0b11111111   // XXXXXX1X  
.................... #define    CAN_CONFIG_LINE_FILTER_OFF   0b11111101   // XXXXXX0X  
....................   
.................... #define    CAN_CONFIG_SAMPLE_BIT        0b00000100  
.................... #define    CAN_CONFIG_SAMPLE_ONCE       0b11111111   // XXXXX1XX  
.................... #define    CAN_CONFIG_SAMPLE_THRICE     0b11111011   // XXXXX0XX  
....................   
.................... #define    CAN_CONFIG_MSG_TYPE_BIT      0b00001000  
.................... #define    CAN_CONFIG_STD_MSG           0b11111111   // XXXX1XXX  
.................... #define    CAN_CONFIG_XTD_MSG           0b11110111   // XXXX0XXX  
....................   
.................... #define    CAN_CONFIG_DBL_BUFFER_BIT    0b00010000  
.................... #define    CAN_CONFIG_DBL_BUFFER_ON     0b11111111   // XXX1XXXX  
.................... #define    CAN_CONFIG_DBL_BUFFER_OFF    0b11101111   // XXX0XXXX  
....................   
.................... #define    CAN_CONFIG_MSG_BITS          0b01100000  
.................... #define    CAN_CONFIG_ALL_MSG           0b11111111   // X11XXXXX  
.................... #define    CAN_CONFIG_VALID_XTD_MSG     0b11011111   // X10XXXXX  
.................... #define    CAN_CONFIG_VALID_STD_MSG     0b10111111   // X01XXXXX  
.................... #define    CAN_CONFIG_ALL_VALID_MSG     0b10011111    // X00XXXXX  
.................... //};  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  * Function:        void CANInitialize( BYTE SJW,  
....................  *                                      BYTE BRP,  
....................  *                                      BYTE PHSEG1,  
....................  *                                      BYTE PHSEG2,  
....................  *                                      BYTE PROPSEG,  
....................  *                                      BYTE config)  
....................  *  
....................  * PreCondition:    MCU must be in Configuration mode or else these  
....................  *                  values will be ignored.  
....................  *  
....................  * Input:           SJW     - SJW value as defined in 18CXX8 datasheet  
....................  *                              (Must be between 1 thru 4)  
....................  *                  BRP     - BRP value as defined in 18CXX8 datasheet  
....................  *                              (Must be between 1 thru 64)  
....................  *                  PHSEG1  - PHSEG1 value as defined in 18CXX8  
....................  *                            datasheet  
....................  *                              (Must be between 1 thru 8)  
....................  *                  PHSEG2  - PHSEG2 value as defined in 18CXX8  
....................  *                            datasheet  
....................  *                              (Must be between 1 thru 8)  
....................  *                  PROPSEG - PROPSEG value as defined in 18CXX8  
....................  *                            datasheet  
....................  *                              (Must be between 1 thru 8)  
....................  *                  flags   - Value of type enum CAN_CONFIG_FLAGS  
....................  *  
....................  * Output:          CAN bit rate is set.  
....................  *                  All masks registers are set '0'  
....................  *                  to allow all messages.  
....................  *                  Filter registers are set according to flag value.  
....................  *                  If (config & CAN_CONFIG_VALID_XTD_MSG)  
....................  *                      Set all filters to XTD_MSG  
....................  *                  Else if (config & CONFIG_VALID_STD_MSG)  
....................  *                      Set all filters to STD_MSG  
....................  *                  Else  
....................  *                      Set half of the filters to STD while rests to  
....................  *                      XTD_MSG.  
....................  *  
....................  * Side Effects:    All pending transmissions are aborted.  
....................  ********************************************************************/  
.................... void CANInitialize(BYTE SJW,  
....................                     BYTE BRP,  
....................                     BYTE PHSEG1,  
....................                     BYTE PHSEG2,  
....................                     BYTE PROPSEG,  
....................                     BYTE config);  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
....................   
.................... /*********************************************************************  
....................  * Function:        void CANSetOperationMode(CAN_OP_MODE mode)  
....................  *  
....................  * PreCondition:    None  
....................  *  
....................  * Input:           mode    - Operation mode code  
....................  *                            must be of type enum CAN_OP_MODES  
....................  *  
....................  * Output:          MCU is set to requested mode  
....................  *  
....................  * Side Effects:    None  
....................  *  
....................  * Note:            This is a blocking call.  It will not return until  
....................  *                  requested mode is set.  
....................  ********************************************************************/  
.................... void CANSetOperationMode(CAN_OP_MODE mode);  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
....................   
.................... /*********************************************************************  
....................  * Macro:           void CANSetOperationModeNoWait(CAN_OP_MODE mode)  
....................  *  
....................  * PreCondition:    None  
....................  *  
....................  * Input:           mode    - Operation mode code  
....................  *                            must be of type enum CAN_OP_MODES  
....................  *  
....................  * Output:          MCU is set to requested mode  
....................  *  
....................  * Side Effects:    None  
....................  *  
....................  * Note:            This is a non-blocking call.  
....................  *                  It does not verify that  
....................  *                  CAN module is switched to requested mode or not.  
....................  *                  Caller must use CANGetOperationMode() to verify  
....................  *                  correct operation mode before performing mode  
....................  *                  specific operation.  
....................  *  
....................  ********************************************************************/  
.................... #define CANSetOperationModeNoWait(mode) (CANCON = mode)  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  * Macro:           CAN_OP_MODE CANSetOperationMode()  
....................  *  
....................  * PreCondition:    None  
....................  *  
....................  * Input:           None  
....................  *  
....................  * Output:          Current operational mode of CAN module is returned  
....................  *  
....................  * Side Effects:    None  
....................  *  
....................  ********************************************************************/  
.................... #define CANGetOperationMode() (CANCON & CAN_OP_MODE_BITS)  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  * Function:        void CANSetBaudRate(BYTE SJW,  
....................  *                                      BYTE BRP,  
....................  *                                      BYTE PHSEG1,  
....................  *                                      BYTE PHSEG2,  
....................  *                                      BYTE PROPSEG,  
....................  *                                      BYTE flags)  
....................  *  
....................  * PreCondition:    MCU must be in Configuration mode or else these  
....................  *                  values will be ignored.  
....................  *  
....................  * Input:           SJW     - SJW value as defined in 18CXX8 datasheet  
....................  *                              (Must be between 1 thru 4)  
....................  *                  BRP     - BRP value as defined in 18CXX8 datasheet  
....................  *                              (Must be between 1 thru 64)  
....................  *                  PHSEG1  - PHSEG1 value as defined in 18CXX8  
....................  *                            datasheet  
....................  *                              (Must be between 1 thru 8)  
....................  *                  PHSEG2  - PHSEG2 value as defined in 18CXX8  
....................  *                            datasheet  
....................  *                              (Must be between 1 thru 8)  
....................  *                  PROPSEG - PROPSEG value as defined in 18CXX8  
....................  *                            datasheet  
....................  *                              (Must be between 1 thru 8)  
....................  *                  flags   - Value of type enum CAN_CONFIG_FLAGS  
....................  *  
....................  * Output:          CAN bit rate is set as per given values.  
....................  *  
....................  * Side Effects:    None  
....................  *  
....................  ********************************************************************/  
.................... void CANSetBaudRate (BYTE SJW,  
....................                      BYTE BRP,  
....................                      BYTE PHSEG1,  
....................                      BYTE PHSEG2,  
....................                      BYTE PROPSEG,  
....................                      BYTE flags);  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  * Function:        void CANSetMask(enum CAN_MASK code,  
....................  *                                  int32 val,  
....................  *                                  BYTE type)  
....................  *  
....................  * PreCondition:    MCU must be in Configuration mode.  If not, all  
....................  *                  values  
....................  *                  will be ignored.  
....................  *  
....................  * Input:           code    - One of CAN_MASK value  
....................  *                  val     - Actual mask register value.  
....................  *                  type    - Type of message to filter either  
....................  *                            CAN_CONFIG_XTD_MSG or CAN_CONFIG_STD_MSG  
....................  *  
....................  * Output:          Given value is bit adjusted to appropriate buffer  
....................  *                  mask registers.  
....................  *  
....................  * Side Effects:    None  
....................  ********************************************************************/  
.................... void CANSetMask (CAN_MASK code,  
....................                 int32 val,  
....................                 BYTE type);  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  * Function:        void CANSetFilter(enum CAN_FILTER code,  
....................  *                                    int32 val,  
....................  *                                    BYTE type)  
....................  *  
....................  * PreCondition:    MCU must be in Configuration mode.  If not, all  
....................  *                  values will be ignored.  
....................  *  
....................  * Input:           code    - One of CAN_FILTER value  
....................  *                  val     - Actual filter register value.  
....................  *                  type    - Type of message to filter either  
....................  *                            CAN_CONFIG_XTD_MSG or CAN_CONFIG_STD_MSG  
....................  *  
....................  * Output:          Given value is bit adjusted to appropriate buffer  
....................  *                  filter registers.  
....................  *  
....................  * Side Effects:    None  
....................  ********************************************************************/  
.................... void CANSetFilter ( CAN_FILTER code,  
....................                     int32 val,  
....................                     BYTE type);  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  * Function:        BOOL CANSendMessage(int32 id,  
....................  *                                  BYTE *Data,  
....................  *                                  BYTE DataLen,  
....................  *                                  enum CAN_TX_MSG_FLAGS MsgFlags)  
....................  *  
....................  * PreCondition:    None  
....................  *  
....................  * Input:           id          - CAN message identifier.  
....................  *                                Only 11 or 29 bits may be used  
....................  *                                depending on standard or extended  
....................  *                                message type.  
....................  *                  Data        - Data bytes of upto 8 bytes in length  
....................  *                  DataLen     - Data length from 1 thru 8.  
....................  *                  MsgFlags    - One or CAN_TX_MSG_FLAGS values ANDed  
....................  *                                together  
....................  *  
....................  * Output:          If at least one empty transmit buffer is found,  
....................  *                  given message is queued to be transmitted. If none  
....................  *                  found FALSE value is returned.  
....................  *  
....................  * Side Effects:    None  
....................  *  
....................  ********************************************************************/  
.................... BOOLEAN CANSendMessage (int32 id,  
....................                      BYTE *Data,  
....................                      BYTE DataLen,  
....................                      CAN_TX_MSG_FLAGS MsgFlags);  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  * Function:        BOOL CANReceiveMessage(int32 *id,  
....................  *                                  BYTE *Data,  
....................  *                                  BYTE *DataLen,  
....................  *                                  enum CAN_RX_MSG_FLAGS *MsgFlags)  
....................  *  
....................  * PreCondition:    None  
....................  *  
....................  * Input:           None  
....................  *  
....................  * Output:          id          - CAN message identifier.  
....................  *                  Data        - Data bytes of upto 8 bytes in length  
....................  *                  DataLen     - Data length from 1 thru 8.  
....................  *                  MsgFlags    - One or CAN_RX_MSG_FLAGS values ANDed  
....................  *                                together  
....................  *  
....................  * Output:          If at least one full receive buffer is found,  
....................  *                  it is extrated and returned. If none found FALSE  
....................  *                  value is returned.  
....................  *  
....................  * Side Effects:    None  
....................  *  
....................  ********************************************************************/  
.................... BOOLEAN CANReceiveMessage(int32* id,  
....................                         BYTE *Data,  
....................                         BYTE *DataLen,  
....................                         CAN_RX_MSG_FLAGS *MsgFlags);  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  * Macro:           BYTE CANGetTxErrorCount()  
....................  *  
....................  * PreCondition:    None  
....................  *  
....................  * Input:           None  
....................  *  
....................  * Output:          Current transmit error count as defined by  
....................  *                  CAN specifications.  
....................  *  
....................  * Side Effects:    None  
....................  *  
....................  ********************************************************************/  
.................... #define CANGetTxErrorCount()    (TXERRCNT)  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  * Macro:           BYTE CANGetRxErrorCount()  
....................  *  
....................  * PreCondition:    None  
....................  *  
....................  * Input:           None  
....................  *  
....................  * Output:          Current receive error count as defined by  
....................  *                  CAN specifications.  
....................  *  
....................  * Side Effects:    None  
....................  *  
....................  ********************************************************************/  
.................... #define CANGetRxErrorCount()    (RXERRCNT)  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  * Macro:           BOOL CANIsBusOff()  
....................  *  
....................  * PreCondition:    None  
....................  *  
....................  * Input:           None  
....................  *  
....................  * Output:          TRUE if CAN Module is off due to excessive error  
....................  *                  FALSE is it is not off.  
....................  *  
....................  * Side Effects:    None  
....................  *  
....................  ********************************************************************/  
.................... #define CANIsBusOff()           (COMSTAT_TXB0)  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  * Macro:           BOOL CANIsTxPassive()  
....................  *  
....................  * PreCondition:    None  
....................  *  
....................  * Input:           None  
....................  *  
....................  * Output:          TRUE if CAN transmit module is error passive as  
....................  *                  defined by CAN specifications.  
....................  *  
....................  * Side Effects:    None  
....................  *  
....................  ********************************************************************/  
.................... #define CANIsTxPassive()        (COMSTAT_TXBP)  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  * Macro:           BYTE CANIsRxPassive()  
....................  *  
....................  * PreCondition:    None  
....................  *  
....................  * Input:           None  
....................  *  
....................  * Output:          TRUE if CAN receive module is error active as  
....................  *                  defined by CAN specifications.  
....................  *  
....................  * Side Effects:    None  
....................  *  
....................  ********************************************************************/  
.................... #define CANIsRxPassive()        (COMSTAT_RXBP)  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  * Macro:           void CANAbortAll()  
....................  *  
....................  * PreCondition:    None  
....................  *  
....................  * Input:           None  
....................  *  
....................  * Output:          None  
....................  *  
....................  * Side Effects:    None  
....................  *  
....................  ********************************************************************/  
.................... #define CANAbortAll()           (CANCON_ABAT = 1)  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  * Macro:           BOOL  CANIsRxReady()  
....................  *  
....................  * PreCondition:    None  
....................  *  
....................  * Input:           None  
....................  *  
....................  * Output:          TRUE if at least one of the CAN receive buffer is  
....................  *                  empty FALSE if none receive buffers are empty.  
....................  *  
....................  * Side Effects:    None  
....................  *  
....................  ********************************************************************/  
.................... #define CANIsRxReady()          (RXB0CON_RXFUL || RXB1CON_RXFUL)  
....................   
.................... //////////////////////////////////////////////////////////////////////  
....................   
.................... /*********************************************************************  
....................  * Macro:           BOOL CANIsTxReady()  
....................  *  
....................  * PreCondition:    None  
....................  *  
....................  * Input:           None  
....................  *  
....................  * Output:          TRUE if at least one CAN transmit buffer is empty  
....................  *                  FALSE if all CAN transmit buffers are full  
....................  *  
....................  * Side Effects:    None  
....................  *  
....................  ********************************************************************/  
.................... #define CANIsTxReady()          (!TXB0CON_TXREQ || \  
....................                                  !TXB1CON_TXREQ || \  
....................                                  !TXB2CON_TXREQ )  
....................   
.................... #endif      // CAN18XX8_H  
....................   
....................  
.................... #include "CAN.h" 
....................  //------------------------------------------------------------------------------  
.................... // File: CAN  
.................... //  
.................... // Purpose: CAN communication and parsing routines.   
.................... //  
.................... // Change History:  
.................... // Date		Author		Description  
.................... //          Lafreniere	Created  
.................... //------------------------------------------------------------------------------  
.................... #ifndef CAN_H  
.................... #define CAN_H  
....................   
.................... void VehSendCAN();  
.................... void VehRecvCAN();  
.................... void CanEmptyRxBuffer();  
.................... void CanSetMaskFilter();  
.................... void CanSetP2CanTimeout();  
.................... void CanDisable();  
....................   
.................... #endif 
....................   
.................... //#use rs232(baud=9600,xmit=PIN_B7,rcv=PIN_B5,parity=n,bits=8,stream=ISO_K_LINE_STREAM)  // laptop test only  
.................... #use rs232(baud=10400,xmit=PIN_B6,rcv=PIN_B5,invert,parity=n,bits=8,stream=ISO_K_LINE_STREAM)  
*
1528:  MOVLW  08
152A:  MOVWF  00
152C:  BSF    F93.5
152E:  BTFSS  F81.5
1530:  GOTO   152E
1534:  MOVLB  2
1536:  CLRF   x3E
1538:  BSF    00.7
153A:  GOTO   1562
153E:  BCF    00.7
1540:  GOTO   1562
1544:  BCF    FD8.0
1546:  BTFSS  F81.5
1548:  BSF    FD8.0
154A:  RRCF   x3E,F
154C:  BSF    00.6
154E:  GOTO   1562
1552:  BCF    00.6
1554:  DECFSZ 00,F
1556:  GOTO   1544
155A:  MOVF   x3E,W
155C:  MOVWF  01
155E:  GOTO   1580
1562:  MOVLW  9A
1564:  BTFSC  00.7
1566:  MOVLW  2A
1568:  MOVWF  01
156A:  DECFSZ 01,F
156C:  GOTO   156A
1570:  BTFSC  00.7
1572:  GOTO   153E
1576:  BTFSC  00.6
1578:  GOTO   1552
157C:  GOTO   1544
1580:  MOVLB  0
1582:  GOTO   15FA (RETURN)
*
167C:  BCF    F93.6
167E:  BSF    F8A.6
1680:  MOVLW  08
1682:  MOVWF  01
1684:  NOP   
1686:  NOP   
1688:  NOP   
168A:  BSF    01.7
168C:  GOTO   16BA
1690:  BCF    01.7
1692:  MOVLB  2
1694:  RRCF   x16,F
1696:  MOVLB  0
1698:  BTFSC  FD8.0
169A:  BCF    F8A.6
169C:  BTFSS  FD8.0
169E:  BSF    F8A.6
16A0:  BSF    01.6
16A2:  GOTO   16BA
16A6:  BCF    01.6
16A8:  DECFSZ 01,F
16AA:  GOTO   1692
16AE:  NOP   
16B0:  NOP   
16B2:  NOP   
16B4:  BCF    F8A.6
16B6:  GOTO   16BA
16BA:  MOVLW  9A
16BC:  MOVWF  FE9
16BE:  DECFSZ FE9,F
16C0:  GOTO   16BE
16C4:  BTFSC  01.7
16C6:  GOTO   1690
16CA:  BTFSC  01.6
16CC:  GOTO   16A6
16D0:  GOTO   16F6 (RETURN)
.................... #use rs232(baud=9600,xmit=PIN_B6,rcv=PIN_B5,invert,parity=n,bits=8,stream=ISO_K_9600_LINE_STREAM)  
*
14C8:  MOVLW  08
14CA:  MOVWF  00
14CC:  BSF    F93.5
14CE:  BTFSS  F81.5
14D0:  GOTO   14CE
14D4:  MOVLB  2
14D6:  CLRF   x3E
14D8:  BSF    00.7
14DA:  GOTO   1502
14DE:  BCF    00.7
14E0:  GOTO   1502
14E4:  BCF    FD8.0
14E6:  BTFSS  F81.5
14E8:  BSF    FD8.0
14EA:  RRCF   x3E,F
14EC:  BSF    00.6
14EE:  GOTO   1502
14F2:  BCF    00.6
14F4:  DECFSZ 00,F
14F6:  GOTO   14E4
14FA:  MOVF   x3E,W
14FC:  MOVWF  01
14FE:  GOTO   1522
1502:  MOVLW  A7
1504:  BTFSC  00.7
1506:  MOVLW  2D
1508:  MOVWF  01
150A:  DECFSZ 01,F
150C:  GOTO   150A
1510:  NOP   
1512:  BTFSC  00.7
1514:  GOTO   14DE
1518:  BTFSC  00.6
151A:  GOTO   14F2
151E:  GOTO   14E4
1522:  MOVLB  0
1524:  GOTO   15E8 (RETURN)
*
1622:  BCF    F93.6
1624:  BSF    F8A.6
1626:  MOVLW  08
1628:  MOVWF  01
162A:  NOP   
162C:  NOP   
162E:  NOP   
1630:  BSF    01.7
1632:  GOTO   1660
1636:  BCF    01.7
1638:  MOVLB  2
163A:  RRCF   x16,F
163C:  MOVLB  0
163E:  BTFSC  FD8.0
1640:  BCF    F8A.6
1642:  BTFSS  FD8.0
1644:  BSF    F8A.6
1646:  BSF    01.6
1648:  GOTO   1660
164C:  BCF    01.6
164E:  DECFSZ 01,F
1650:  GOTO   1638
1654:  NOP   
1656:  NOP   
1658:  NOP   
165A:  BCF    F8A.6
165C:  GOTO   1660
1660:  MOVLW  A7
1662:  MOVWF  FE9
1664:  DECFSZ FE9,F
1666:  GOTO   1664
166A:  NOP   
166C:  BTFSC  01.7
166E:  GOTO   1636
1672:  BTFSC  01.6
1674:  GOTO   164C
1678:  GOTO   16EA (RETURN)
.................... #use rs232(baud=10400,xmit=PIN_B7,invert,parity=n,bits=8,stream=ISO_L_LINE_STREAM)  
*
1858:  BCF    F93.7
185A:  BSF    F8A.7
185C:  MOVLW  08
185E:  MOVWF  01
1860:  NOP   
1862:  NOP   
1864:  NOP   
1866:  BSF    01.7
1868:  GOTO   1896
186C:  BCF    01.7
186E:  MOVLB  2
1870:  RRCF   x14,F
1872:  MOVLB  0
1874:  BTFSC  FD8.0
1876:  BCF    F8A.7
1878:  BTFSS  FD8.0
187A:  BSF    F8A.7
187C:  BSF    01.6
187E:  GOTO   1896
1882:  BCF    01.6
1884:  DECFSZ 01,F
1886:  GOTO   186E
188A:  NOP   
188C:  NOP   
188E:  NOP   
1890:  BCF    F8A.7
1892:  GOTO   1896
1896:  MOVLW  9A
1898:  MOVWF  FE9
189A:  DECFSZ FE9,F
189C:  GOTO   189A
18A0:  BTFSC  01.7
18A2:  GOTO   186C
18A6:  BTFSC  01.6
18A8:  GOTO   1882
18AC:  GOTO   18E0 (RETURN)
.................... #use rs232(baud=9600,xmit=PIN_B7,invert,parity=n,bits=8,stream=ISO_L_9600_LINE_STREAM)  
*
17FE:  BCF    F93.7
1800:  BSF    F8A.7
1802:  MOVLW  08
1804:  MOVWF  01
1806:  NOP   
1808:  NOP   
180A:  NOP   
180C:  BSF    01.7
180E:  GOTO   183C
1812:  BCF    01.7
1814:  MOVLB  2
1816:  RRCF   x14,F
1818:  MOVLB  0
181A:  BTFSC  FD8.0
181C:  BCF    F8A.7
181E:  BTFSS  FD8.0
1820:  BSF    F8A.7
1822:  BSF    01.6
1824:  GOTO   183C
1828:  BCF    01.6
182A:  DECFSZ 01,F
182C:  GOTO   1814
1830:  NOP   
1832:  NOP   
1834:  NOP   
1836:  BCF    F8A.7
1838:  GOTO   183C
183C:  MOVLW  A7
183E:  MOVWF  FE9
1840:  DECFSZ FE9,F
1842:  GOTO   1840
1846:  NOP   
1848:  BTFSC  01.7
184A:  GOTO   1812
184E:  BTFSC  01.6
1850:  GOTO   1828
1854:  GOTO   18D4 (RETURN)
....................   
.................... void VehInitISO(int8 addr);  
.................... void VehSendISO();  
.................... void VehRecvISO();  
.................... void VehSendJ1850(int8 type);  
.................... void VehRecvJ1850(int8 type);  
.................... void CheckSendRecvErr(int8 err);  
.................... void CheckCRC(int8* msgSizes);  
.................... void VehSend5BPS(int8 byte);  
.................... void VehFastInit();  
.................... void VehReadBatteryVoltage();  
.................... void VehSetLLineXmitEnable();  
.................... void VehSetIsoChecksumEnable();  
.................... void VehSetIso9600BaudEnable();  
.................... void VehSetIso5msByteDelayEnable();  
.................... int8 timed_getc(int8* timedOut, int16 timeout);  
.................... void VehSendKLine(int8 b);  
.................... void VehSendLLine(int8 b);  
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: VehSendRecv  
.................... // Description: Send host query and receive vehicle response.   
.................... // Parameters:   
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void VehSendRecv()  
.................... {  
....................     gVehicleBufCnt = 0;  
*
3396:  CLRF   21
....................   
.................... 	// turn off CAN module if current command is not a CAN command  
.................... 	if (CANGetOperationMode() != CAN_OP_MODE_SLEEP)  
.................... 	{  
3398:  MOVF   F6F,W
339A:  ANDLW  E0
339C:  SUBLW  20
339E:  BTFSC  FD8.2
33A0:  GOTO   33C4
.................... 		if (!IsCmdCAN(gCurrentCmd))  
33A4:  CLRF   15
33A6:  BTFSC  FF2.7
33A8:  BSF    15.7
33AA:  BCF    FF2.7
.................... 			CanDisable();  
33AC:  MOVFF  22,278
33B0:  CALL   01CE
33B4:  BTFSC  15.7
33B6:  BSF    FF2.7
33B8:  MOVF   01,F
33BA:  BTFSS  FD8.2
33BC:  GOTO   33C4
33C0:  CALL   0128
.................... 	}  
....................   
....................     if (IsCmdFirstResp(gCurrentCmd))  
....................         gFlags.firstResp = TRUE;  
33C4:  MOVFF  22,210
33C8:  GOTO   0A86
33CC:  MOVF   01,F
33CE:  BTFSC  FD8.2
33D0:  GOTO   33DA
33D4:  BSF    18.3
....................     else  
....................         gFlags.firstResp = FALSE;  
33D6:  GOTO   33DC
33DA:  BCF    18.3
....................   
....................     // send message to vehicle based on host command type  
....................     if (gCurrentCmd == CMD_VPW ||  
....................         gCurrentCmd == CMD_VPW_1ST_RESPONSE)  
....................     {  
33DC:  MOVF   22,W
33DE:  SUBLW  02
33E0:  BTFSC  FD8.2
33E2:  GOTO   33F0
33E6:  MOVF   22,W
33E8:  SUBLW  82
33EA:  BTFSS  FD8.2
33EC:  GOTO   341C
....................         gFlags.comType = MODE_VPW;  
33F0:  MOVLW  F8
33F2:  ANDWF  18,W
33F4:  IORLW  01
33F6:  MOVWF  18
....................         VehSendJ1850(MODE_VPW);  
33F8:  MOVLW  01
33FA:  MOVLB  2
33FC:  MOVWF  x10
33FE:  MOVLB  0
3400:  CALL   0E32
....................         if (gError == ERR_NONE)  
....................             VehRecvJ1850(MODE_VPW);  
3404:  MOVF   1A,F
3406:  BTFSS  FD8.2
3408:  GOTO   3418
340C:  MOVLW  01
340E:  MOVLB  2
3410:  MOVWF  x10
3412:  MOVLB  0
3414:  CALL   1222
....................     }  
....................     else if (gCurrentCmd == CMD_PWM ||  
3418:  GOTO   3664
....................         gCurrentCmd == CMD_PWM_WITH_IFR ||  
....................         gCurrentCmd == CMD_PWM_1ST_RESPONSE)  
....................     {  
341C:  MOVF   22,W
341E:  SUBLW  04
3420:  BTFSC  FD8.2
3422:  GOTO   343A
3426:  MOVF   22,W
3428:  SUBLW  80
342A:  BTFSC  FD8.2
342C:  GOTO   343A
3430:  MOVF   22,W
3432:  SUBLW  84
3434:  BTFSS  FD8.2
3436:  GOTO   3466
....................         gFlags.comType = MODE_PWM;  
343A:  MOVLW  F8
343C:  ANDWF  18,W
343E:  IORLW  02
3440:  MOVWF  18
....................         VehSendJ1850(MODE_PWM);  
3442:  MOVLW  02
3444:  MOVLB  2
3446:  MOVWF  x10
3448:  MOVLB  0
344A:  CALL   0E32
....................         if (gError == ERR_NONE)  
....................             VehRecvJ1850(MODE_PWM);  
344E:  MOVF   1A,F
3450:  BTFSS  FD8.2
3452:  GOTO   3462
3456:  MOVLW  02
3458:  MOVLB  2
345A:  MOVWF  x10
345C:  MOVLB  0
345E:  CALL   1222
....................     }  
....................     else if (gCurrentCmd == CMD_ISO_WITH_5_BAUD ||  
3462:  GOTO   3664
....................         gCurrentCmd == CMD_KWP_WITH_5_BAUD)  
....................     {  
3466:  DECFSZ 22,W
3468:  GOTO   3470
346C:  GOTO   347A
3470:  MOVF   22,W
3472:  SUBLW  85
3474:  BTFSS  FD8.2
3476:  GOTO   34BA
....................         // if ISO, use 0x33 for 5BPS addr, otherwise use target addr. ISO 14230  
....................         // says use 0x33 also, but for future expansion get value from target addr  
....................         if (gCurrentCmd == CMD_ISO_WITH_5_BAUD)  
....................         {  
347A:  DECFSZ 22,W
347C:  GOTO   3496
....................             gFlags.comType = MODE_ISO;  
3480:  MOVLW  F8
3482:  ANDWF  18,W
3484:  MOVWF  18
....................             VehInitISO(0x33);  
3486:  MOVLW  33
3488:  MOVLB  2
348A:  MOVWF  x10
348C:  MOVLB  0
348E:  CALL   16F8
....................         }  
....................         else  
....................         {  
3492:  GOTO   34A6
....................             gFlags.comType = MODE_KWP;  
3496:  MOVLW  F8
3498:  ANDWF  18,W
349A:  IORLW  03
349C:  MOVWF  18
....................             VehInitISO(gHostBuf[IDX_HOST_START_DATA+1]);  
349E:  MOVFF  36,210
34A2:  CALL   16F8
....................         }  
....................   
....................         if (gError == ERR_NONE)  
....................         {  
34A6:  MOVF   1A,F
34A8:  BTFSS  FD8.2
34AA:  GOTO   34B6
....................             VehSendISO();  
34AE:  CALL   18E2
....................             VehRecvISO();  
34B2:  CALL   19D8
....................         }  
....................     }  
....................     else if (gCurrentCmd == CMD_ISO ||  
34B6:  GOTO   3664
....................         gCurrentCmd == CMD_ISO_1ST_RESPONSE ||  
....................         gCurrentCmd == CMD_KWP ||  
....................         gCurrentCmd == CMD_KWP_1ST_RESPONSE ||  
.................... 		gCurrentCmd == CMD_ISO_NO_RESPONSE)  
....................     {  
34BA:  MOVF   22,W
34BC:  SUBLW  10
34BE:  BTFSC  FD8.2
34C0:  GOTO   34EC
34C4:  MOVF   22,W
34C6:  SUBLW  81
34C8:  BTFSC  FD8.2
34CA:  GOTO   34EC
34CE:  MOVF   22,W
34D0:  SUBLW  88
34D2:  BTFSC  FD8.2
34D4:  GOTO   34EC
34D8:  MOVF   22,W
34DA:  SUBLW  89
34DC:  BTFSC  FD8.2
34DE:  GOTO   34EC
34E2:  MOVF   22,W
34E4:  SUBLW  A6
34E6:  BTFSS  FD8.2
34E8:  GOTO   3528
....................         if (gCurrentCmd == CMD_ISO ||  
....................             gCurrentCmd == CMD_ISO_1ST_RESPONSE)  
....................             gFlags.comType = MODE_ISO;  
34EC:  MOVF   22,W
34EE:  SUBLW  10
34F0:  BTFSC  FD8.2
34F2:  GOTO   3500
34F6:  MOVF   22,W
34F8:  SUBLW  81
34FA:  BTFSS  FD8.2
34FC:  GOTO   350A
3500:  MOVLW  F8
3502:  ANDWF  18,W
3504:  MOVWF  18
....................         else  
....................             gFlags.comType = MODE_KWP;  
3506:  GOTO   3512
350A:  MOVLW  F8
350C:  ANDWF  18,W
350E:  IORLW  03
3510:  MOVWF  18
....................         VehSendISO();  
3512:  CALL   18E2
.................... 		if (gCurrentCmd != CMD_ISO_NO_RESPONSE)  
....................         	VehRecvISO();  
3516:  MOVF   22,W
3518:  SUBLW  A6
351A:  BTFSC  FD8.2
351C:  GOTO   3524
3520:  CALL   19D8
....................     }  
....................     else if (gCurrentCmd == CMD_KWP_FAST_INIT ||  
3524:  GOTO   3664
.................... 			 gCurrentCmd == CMD_KWP_FAST_INIT_9600)  
....................     {  
3528:  MOVF   22,W
352A:  SUBLW  87
352C:  BTFSC  FD8.2
352E:  GOTO   353C
3532:  MOVF   22,W
3534:  SUBLW  C4
3536:  BTFSS  FD8.2
3538:  GOTO   3554
....................         gFlags.comType = MODE_KWP;  
353C:  MOVLW  F8
353E:  ANDWF  18,W
3540:  IORLW  03
3542:  MOVWF  18
....................         VehFastInit();  
3544:  GOTO   1BD6
....................         VehSendISO();  
3548:  CALL   18E2
....................         VehRecvISO();  
354C:  CALL   19D8
....................     }  
....................     else if (IsCmdCAN(gCurrentCmd))  
3550:  GOTO   3664
3554:  CLRF   15
3556:  BTFSC  FF2.7
3558:  BSF    15.7
355A:  BCF    FF2.7
....................     {  
355C:  MOVFF  22,278
3560:  CALL   01CE
3564:  BTFSC  15.7
3566:  BSF    FF2.7
3568:  MOVF   01,F
356A:  BTFSC  FD8.2
356C:  GOTO   35A4
.................... 		// disable CAN RX interrupts while Send/Recv on CAN  
.................... 		disable_interrupts(INT_CANRX1);  
3570:  BCF    FA3.1
.................... 		disable_interrupts(INT_CANRX0);  
3572:  BCF    FA3.0
....................         gFlags.comType = MODE_CAN;  
3574:  MOVLW  F8
3576:  ANDWF  18,W
3578:  IORLW  04
357A:  MOVWF  18
....................         VehSendCAN();  
357C:  GOTO   277A
....................         if (gError == ERR_NONE && IsCmdNoResponse(gCurrentCmd) == 0)  
.................... 		    VehRecvCAN();  
3580:  MOVF   1A,F
3582:  BTFSS  FD8.2
3584:  GOTO   359C
3588:  MOVFF  22,210
358C:  GOTO   27D8
3590:  MOVF   01,F
3592:  BTFSS  FD8.2
3594:  GOTO   359C
3598:  GOTO   28AA
....................   
.................... 		enable_interrupts(INT_CANRX1);  
359C:  BSF    FA3.1
.................... 		enable_interrupts(INT_CANRX0);  
359E:  BSF    FA3.0
.................... 	}  
.................... 	else if (gCurrentCmd == CMD_CAN_SET_STD_MASK_FILTER ||  
35A0:  GOTO   3664
.................... 			 gCurrentCmd == CMD_CAN_SET_XTD_MASK_FILTER)  
.................... 		CanSetMaskFilter();  
35A4:  MOVF   22,W
35A6:  SUBLW  97
35A8:  BTFSC  FD8.2
35AA:  GOTO   35B8
35AE:  MOVF   22,W
35B0:  SUBLW  98
35B2:  BTFSS  FD8.2
35B4:  GOTO   35C0
35B8:  GOTO   2E7C
.................... 	else if (gCurrentCmd == CMD_CAN_SET_P2_CAN_TIMEOUT)  
35BC:  GOTO   3664
.................... 		CanSetP2CanTimeout();  
35C0:  MOVF   22,W
35C2:  SUBLW  99
35C4:  BTFSS  FD8.2
35C6:  GOTO   35D2
35CA:  GOTO   2F76
.................... 	else if (gCurrentCmd == CMD_READ_BATTERY_VOLTAGE)  
35CE:  GOTO   3664
.................... 		VehReadBatteryVoltage();  
35D2:  MOVF   22,W
35D4:  SUBLW  F0
35D6:  BTFSS  FD8.2
35D8:  GOTO   35E4
35DC:  GOTO   2FFA
.................... 	else if (gCurrentCmd == CMD_ISO_CHECKSUM_ENABLE)  
35E0:  GOTO   3664
.................... 		VehSetIsoChecksumEnable();  
35E4:  MOVF   22,W
35E6:  SUBLW  AC
35E8:  BTFSS  FD8.2
35EA:  GOTO   35F6
35EE:  GOTO   3058
.................... 	else if (gCurrentCmd == CMD_ISO_5MS_BYTE_DELAY_ENABLE)  
35F2:  GOTO   3664
.................... 		VehSetIso5msByteDelayEnable();  
35F6:  MOVF   22,W
35F8:  SUBLW  AD
35FA:  BTFSS  FD8.2
35FC:  GOTO   3608
3600:  GOTO   306C
.................... 	else if (gCurrentCmd == CMD_ISO_ENABLE_L_LINE_XMIT)  
3604:  GOTO   3664
.................... 		VehSetLLineXmitEnable();  
3608:  MOVF   22,W
360A:  SUBLW  A9
360C:  BTFSS  FD8.2
360E:  GOTO   361A
3612:  GOTO   3080
.................... 	else if (gCurrentCmd == CMD_ISO_SET_9600_BAUD)  
3616:  GOTO   3664
.................... 		VehSetIso9600BaudEnable();  
361A:  MOVF   22,W
361C:  SUBLW  AB
361E:  BTFSS  FD8.2
3620:  GOTO   362C
3624:  GOTO   3094
.................... 	else if (gCurrentCmd == CMD_READ_EEPROM)  
3628:  GOTO   3664
.................... 		ReadEeprom();  
362C:  MOVF   22,W
362E:  SUBLW  B9
3630:  BTFSS  FD8.2
3632:  GOTO   363E
3636:  GOTO   318E
.................... 	else if (gCurrentCmd == CMD_WRITE_EEPROM)  
363A:  GOTO   3664
.................... 		WriteEeprom();  
363E:  MOVF   22,W
3640:  SUBLW  BA
3642:  BTFSS  FD8.2
3644:  GOTO   3650
3648:  GOTO   327A
....................     else if (gCurrentCmd == CMD_UNLOCK_ADAPTER)  
364C:  GOTO   3664
....................         gFlags.adapterLocked = FALSE;  
3650:  MOVF   22,W
3652:  SUBLW  B0
3654:  BTFSS  FD8.2
3656:  GOTO   3660
365A:  BCF    18.6
....................     else  
....................         gError = ERR_NOT_IMPLEMENTED;  
365C:  GOTO   3664
3660:  MOVLW  01
3662:  MOVWF  1A
.................... }  
3664:  GOTO   3A6A (RETURN)
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: VehSendISO  
.................... // Description: Send a query using ISO.  
.................... // Parameters:   
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void VehSendISO()  
.................... {  
.................... 	int8 i;  
....................   
....................     // send the data out the ISO RS-232 port  
....................     for (i=0; i<gHostBuf[IDX_HOST_BYTE_COUNT]; i++)  
*
18E2:  MOVLB  2
18E4:  CLRF   x10
18E6:  MOVF   34,W
18E8:  SUBWF  x10,W
18EA:  BTFSC  FD8.0
18EC:  GOTO   1950
....................     {  
.................... 		VehSendKLine(gHostBuf[i+3]);  
18F0:  MOVLW  03
18F2:  ADDWF  x10,W
18F4:  CLRF   03
18F6:  ADDLW  32
18F8:  MOVWF  FE9
18FA:  MOVLW  00
18FC:  ADDWFC 03,W
18FE:  MOVWF  FEA
1900:  MOVLB  0
1902:  MOVFF  FEF,212
1906:  MOVFF  212,215
190A:  CALL   16D4
.................... 		VehSendLLine(gHostBuf[i+3]);  
190E:  MOVLW  03
1910:  MOVLB  2
1912:  ADDWF  x10,W
1914:  CLRF   03
1916:  ADDLW  32
1918:  MOVWF  FE9
191A:  MOVLW  00
191C:  ADDWFC 03,W
191E:  MOVWF  FEA
1920:  MOVLB  0
1922:  MOVFF  FEF,212
1926:  MOVFF  212,213
192A:  CALL   18B0
.................... 		if (gFlags.enableIso5msByteDelay == TRUE)  
.................... 	        delay_ms(5);   // satisfy P4 timing per ISO 9141 (spec says 5mS)  
192E:  MOVLW  00
1930:  BTFSC  19.1
1932:  MOVLW  01
1934:  SUBLW  01
1936:  BTFSS  FD8.2
1938:  GOTO   1948
193C:  MOVLW  05
193E:  MOVLB  2
1940:  MOVWF  x3C
1942:  MOVLB  0
1944:  CALL   07F4
....................     }  
1948:  MOVLB  2
194A:  INCF   x10,F
194C:  GOTO   18E6
....................   
....................      
.................... 	if (gFlags.enableIsoChecksum == TRUE)  
.................... 	{   
1950:  MOVLW  00
1952:  BTFSC  19.2
1954:  MOVLW  01
1956:  SUBLW  01
1958:  BTFSS  FD8.2
195A:  GOTO   1984
.................... 		// calc and send message checksum  
....................     	i = checksum(&gHostBuf[3], gHostBuf[IDX_HOST_BYTE_COUNT]);  
195E:  CLRF   x40
1960:  MOVLW  35
1962:  MOVWF  x3F
1964:  MOVLB  0
1966:  MOVFF  34,241
196A:  CALL   09CC
196E:  MOVFF  01,210
.................... 		VehSendKLine(i);  
1972:  MOVFF  210,215
1976:  CALL   16D4
.................... 		VehSendLLine(i);  
197A:  MOVFF  210,213
197E:  CALL   18B0
1982:  MOVLB  2
.................... 	}  
.................... }  
1984:  MOVLB  0
1986:  RETLW  00
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: VehSendKLine  
.................... // Description: Send 1 byte out the ISO K line.  
.................... // Parameters:   
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void VehSendKLine(int8 b)  
.................... {  
.................... 	if (gFlags.enableIso9600Baud == TRUE)  
.................... 		fputc(b, ISO_K_9600_LINE_STREAM);  
*
16D4:  MOVLW  00
16D6:  BTFSC  19.0
16D8:  MOVLW  01
16DA:  SUBLW  01
16DC:  BTFSS  FD8.2
16DE:  GOTO   16EE
16E2:  MOVFF  215,216
16E6:  GOTO   1622
.................... 	else  
.................... 	    fputc(b, ISO_K_LINE_STREAM);  
16EA:  GOTO   16F6
16EE:  MOVFF  215,216
16F2:  GOTO   167C
.................... }  
16F6:  RETLW  00
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: VehSendLLine  
.................... // Description: Send 1 byte out the ISO L line.  
.................... // Parameters:   
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void VehSendLLine(int8 b)  
.................... {  
.................... 	if (gFlags.enableLLineXmit == TRUE)  
.................... 	{  
*
18B0:  MOVLW  00
18B2:  BTFSC  18.7
18B4:  MOVLW  01
18B6:  SUBLW  01
18B8:  BTFSS  FD8.2
18BA:  GOTO   18E0
.................... 		if (gFlags.enableIso9600Baud == TRUE)  
.................... 			fputc(b, ISO_L_9600_LINE_STREAM);  
18BE:  MOVLW  00
18C0:  BTFSC  19.0
18C2:  MOVLW  01
18C4:  SUBLW  01
18C6:  BTFSS  FD8.2
18C8:  GOTO   18D8
18CC:  MOVFF  213,214
18D0:  GOTO   17FE
.................... 		else  
.................... 			fputc(b, ISO_L_LINE_STREAM);  
18D4:  GOTO   18E0
18D8:  MOVFF  213,214
18DC:  GOTO   1858
.................... 	}  
.................... }  
18E0:  RETLW  00
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: VehRecvISO  
.................... // Description: Receive one or more messages using ISO.  
.................... // Parameters:   
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void VehRecvISO()  
.................... {  
....................     int8 charTimeout;  
....................     int8 cnt;     
....................     HstTimer recvTimer;  
....................     int8 msgSize[VEHICLE_MAX_MSGS];  
....................   
....................     recvTimer = HstGetTicks();  
*
19D8:  CALL   00B6
19DC:  MOVFF  02,213
19E0:  MOVFF  01,212
....................   
....................     // get all ISO messages. 50mS of no data terminates the receive  
....................     do   
....................     {  
....................         // is there a char coming in the RS-232 port?? 
....................         if (kbhit())  
....................         {  
19E4:  BTFSS  F81.5
19E6:  GOTO   1AC2
....................             // get one entire ISO OBD II message. once first char arrives,   
....................             // each char will be max 20mS apart  
....................             for (cnt=0; cnt<VEHICLE_MSG_SIZE; cnt++)  
19EA:  MOVLB  2
19EC:  CLRF   x11
19EE:  MOVF   x11,W
19F0:  SUBLW  0B
19F2:  BTFSS  FD8.0
19F4:  GOTO   1A70
....................             {  
....................                 gVehicleBuf[gVehicleBufCnt][cnt] = timed_getc(&charTimeout, 2000);  
19F8:  CLRF   x43
19FA:  MOVLB  0
19FC:  MOVFF  21,242
1A00:  MOVLB  2
1A02:  CLRF   x45
1A04:  MOVLW  0C
1A06:  MOVWF  x44
1A08:  MOVLB  0
1A0A:  CALL   0EC6
1A0E:  MOVFF  02,235
1A12:  MOVFF  01,234
1A16:  MOVLB  2
1A18:  MOVF   x11,W
1A1A:  ADDWF  01,W
1A1C:  MOVWF  01
1A1E:  MOVLW  00
1A20:  ADDWFC 02,W
1A22:  MOVWF  03
1A24:  MOVF   01,W
1A26:  ADDLW  41
1A28:  MOVWF  01
1A2A:  MOVLW  00
1A2C:  ADDWFC 03,F
1A2E:  MOVF   01,W
1A30:  MOVWF  x36
1A32:  MOVLB  0
1A34:  MOVFF  03,237
1A38:  MOVLW  02
1A3A:  MOVLB  2
1A3C:  MOVWF  x39
1A3E:  MOVLW  10
1A40:  MOVWF  x38
1A42:  MOVLW  07
1A44:  MOVWF  x3B
1A46:  MOVLW  D0
1A48:  MOVWF  x3A
1A4A:  MOVLB  0
1A4C:  CALL   1586
1A50:  MOVFF  237,FEA
1A54:  MOVFF  236,FE9
1A58:  MOVFF  01,FEF
....................                 if (charTimeout)  
....................                     break;  
1A5C:  MOVLB  2
1A5E:  MOVF   x10,F
1A60:  BTFSC  FD8.2
1A62:  GOTO   1A6A
1A66:  GOTO   1A70
....................             }  
1A6A:  INCF   x11,F
1A6C:  GOTO   19EE
....................   
....................             // if no chars arrived and not a single buffer filled  
....................             if (cnt == 0 && gVehicleBufCnt == 0)  
....................             {  
1A70:  MOVF   x11,F
1A72:  BTFSS  FD8.2
1A74:  GOTO   1A88
1A78:  MOVF   21,F
1A7A:  BTFSS  FD8.2
1A7C:  GOTO   1A88
....................                 gError = ERR_ISO_NO_RESPONSE;  
1A80:  MOVLW  05
1A82:  MOVWF  1A
....................                 return;  
1A84:  GOTO   1BD2
....................             }  
....................   
....................             // Message filter: if message is not a response for scan tool, ignore it.   
....................             // Mode byte bit 6 = 0 are requests, bit 6 = 1 are responses  
.................... 			// This filter is not necessary, and could interfere with KWP fast init messages  
....................             //if (gVehicleBuf[gVehicleBufCnt][3] != (gHostBuf[6] | 0x40))  
....................             //    continue;  
....................   
....................             // successfully obtained a message (checksum not checked yet)  
....................             msgSize[gVehicleBufCnt] = cnt;  
1A88:  CLRF   03
1A8A:  MOVF   21,W
1A8C:  ADDLW  14
1A8E:  MOVWF  FE9
1A90:  MOVLW  02
1A92:  ADDWFC 03,W
1A94:  MOVWF  FEA
1A96:  MOVLB  0
1A98:  MOVFF  211,FEF
....................             if (++gVehicleBufCnt >= VEHICLE_MAX_MSGS)  
....................                 break;  
1A9C:  INCF   21,F
1A9E:  MOVF   21,W
1AA0:  SUBLW  1F
1AA2:  BTFSC  FD8.0
1AA4:  GOTO   1AAC
1AA8:  GOTO   1AE2
....................   
....................             // if host only wants one response message  
....................             if (gFlags.firstResp)  
....................                 break;  
1AAC:  BTFSS  18.3
1AAE:  GOTO   1AB6
1AB2:  GOTO   1AE2
....................   
....................             // reset timer for next message  
....................             recvTimer = HstGetTicks();  
1AB6:  CALL   00B6
1ABA:  MOVFF  02,213
1ABE:  MOVFF  01,212
....................         }  
....................     } while (!HstTestTimer(recvTimer, HST_FIFTY_MS));  
....................   
....................     if (gVehicleBufCnt == 0)  
1AC2:  MOVFF  213,235
1AC6:  MOVFF  212,234
1ACA:  MOVLW  7A
1ACC:  MOVLB  2
1ACE:  MOVWF  x37
1AD0:  MOVLW  12
1AD2:  MOVWF  x36
1AD4:  MOVLB  0
1AD6:  CALL   1988
1ADA:  MOVF   01,F
1ADC:  BTFSC  FD8.2
1ADE:  GOTO   19E4
....................     {  
1AE2:  MOVF   21,F
1AE4:  BTFSS  FD8.2
1AE6:  GOTO   1AF6
....................         gError = ERR_ISO_NO_RESPONSE;  
1AEA:  MOVLW  05
1AEC:  MOVWF  1A
....................         return;  
1AEE:  MOVLB  2
1AF0:  GOTO   1BD2
1AF4:  MOVLB  0
....................     }  
....................   
.................... 	if (gFlags.enableIsoChecksum == TRUE)  
.................... 	{  
1AF6:  MOVLW  00
1AF8:  BTFSC  19.2
1AFA:  MOVLW  01
1AFC:  SUBLW  01
1AFE:  BTFSS  FD8.2
1B00:  GOTO   1BD0
.................... 		// error check each received message using checksum  
....................     	for (cnt=0; cnt<gVehicleBufCnt; cnt++)  
1B04:  MOVLB  2
1B06:  CLRF   x11
1B08:  MOVF   21,W
1B0A:  SUBWF  x11,W
1B0C:  BTFSC  FD8.0
1B0E:  GOTO   1BCE
.................... 	    {         
....................     	    // does received checksum match what was sent??         
....................         	if (gVehicleBuf[cnt][msgSize[cnt]-1] !=   
.................... 	            checksum(&gVehicleBuf[cnt][0], msgSize[cnt]-1))  
....................     	    {  
1B12:  CLRF   x43
1B14:  MOVLB  0
1B16:  MOVFF  211,242
1B1A:  MOVLB  2
1B1C:  CLRF   x45
1B1E:  MOVLW  0C
1B20:  MOVWF  x44
1B22:  MOVLB  0
1B24:  CALL   0EC6
1B28:  MOVFF  02,235
1B2C:  MOVFF  01,234
1B30:  CLRF   03
1B32:  MOVLB  2
1B34:  MOVF   x11,W
1B36:  ADDLW  14
1B38:  MOVWF  FE9
1B3A:  MOVLW  02
1B3C:  ADDWFC 03,W
1B3E:  MOVWF  FEA
1B40:  MOVLW  01
1B42:  SUBWF  FEF,W
1B44:  ADDWF  01,W
1B46:  MOVWF  01
1B48:  MOVLW  00
1B4A:  ADDWFC 02,W
1B4C:  MOVWF  03
1B4E:  MOVF   01,W
1B50:  ADDLW  41
1B52:  MOVWF  FE9
1B54:  MOVLW  00
1B56:  ADDWFC 03,W
1B58:  MOVWF  FEA
1B5A:  MOVLB  0
1B5C:  MOVFF  FEF,238
1B60:  MOVLB  2
1B62:  CLRF   x43
1B64:  MOVLB  0
1B66:  MOVFF  211,242
1B6A:  MOVLB  2
1B6C:  CLRF   x45
1B6E:  MOVLW  0C
1B70:  MOVWF  x44
1B72:  MOVLB  0
1B74:  CALL   0EC6
1B78:  MOVFF  02,23A
1B7C:  MOVFF  01,239
1B80:  MOVLW  41
1B82:  MOVLB  2
1B84:  ADDWF  01,W
1B86:  MOVWF  x3B
1B88:  MOVLW  00
1B8A:  ADDWFC 02,W
1B8C:  MOVWF  x3C
1B8E:  CLRF   03
1B90:  MOVF   x11,W
1B92:  ADDLW  14
1B94:  MOVWF  FE9
1B96:  MOVLW  02
1B98:  ADDWFC 03,W
1B9A:  MOVWF  FEA
1B9C:  MOVLW  01
1B9E:  SUBWF  FEF,W
1BA0:  MOVWF  x3E
1BA2:  MOVLB  0
1BA4:  MOVFF  23C,240
1BA8:  MOVFF  23B,23F
1BAC:  MOVFF  23E,241
1BB0:  CALL   09CC
1BB4:  MOVF   01,W
1BB6:  MOVLB  2
1BB8:  SUBWF  x38,W
1BBA:  BTFSC  FD8.2
1BBC:  GOTO   1BC8
.................... 	            gError = ERR_ISO_BAD_CHECKSUM;  
1BC0:  MOVLW  08
1BC2:  MOVWF  1A
....................     	        return;  
1BC4:  GOTO   1BD2
.................... 	        }  
.................... 	    }  
1BC8:  INCF   x11,F
1BCA:  GOTO   1B08
1BCE:  MOVLB  0
1BD0:  MOVLB  2
.................... 	}  
.................... }  
1BD2:  MOVLB  0
1BD4:  RETLW  00
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: VehInitISO  
.................... // Description: Performs the ISO initialization sequence.   
.................... // Parameters: addr - 5BPS ISO initialization address.   
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void VehInitISO(int8 addr)  
.................... {  
....................     int8 b, i, timeout;	  
....................   
....................     VehSend5BPS(addr);  
*
16F8:  MOVFF  210,214
16FC:  GOTO   1440
.................... 	gErrorExtraData1 = addr;  
1700:  MOVFF  210,1B
....................   
....................     // get sychronization byte  
....................     b = timed_getc(&timeout, 30000);  
1704:  MOVLW  02
1706:  MOVLB  2
1708:  MOVWF  x39
170A:  MOVLW  13
170C:  MOVWF  x38
170E:  MOVLW  75
1710:  MOVWF  x3B
1712:  MOVLW  30
1714:  MOVWF  x3A
1716:  MOVLB  0
1718:  CALL   1586
171C:  MOVFF  01,211
.................... 	if (timeout == TRUE)  
.................... 	{  
1720:  MOVLB  2
1722:  DECFSZ x13,W
1724:  GOTO   1730
.................... 		gError = ERR_ISO_SYNC_BYTE_NOT_RECEIVED;  
1728:  MOVLW  20
172A:  MOVWF  1A
.................... 		return;  
172C:  GOTO   17FA
.................... 	}    
....................     if (b != 0x55)    
....................     {  
1730:  MOVF   x11,W
1732:  SUBLW  55
1734:  BTFSC  FD8.2
1736:  GOTO   174A
....................         gError = ERR_ISO_NO_SYNC;  
173A:  MOVLW  03
173C:  MOVWF  1A
.................... 		gErrorExtraData2 = b;  
173E:  MOVLB  0
1740:  MOVFF  211,1C
....................         return;  
1744:  MOVLB  2
1746:  GOTO   17FA
....................     }  
....................   
....................     // get two keywords bytes (allow any key bytes)  
....................     for (i=0; i<2; i++)  
174A:  CLRF   x12
174C:  MOVF   x12,W
174E:  SUBLW  01
1750:  BTFSS  FD8.0
1752:  GOTO   1788
....................     {  
....................         b = timed_getc(&timeout, 2000);  
1756:  MOVLW  02
1758:  MOVWF  x39
175A:  MOVLW  13
175C:  MOVWF  x38
175E:  MOVLW  07
1760:  MOVWF  x3B
1762:  MOVLW  D0
1764:  MOVWF  x3A
1766:  MOVLB  0
1768:  CALL   1586
176C:  MOVFF  01,211
....................         if (timeout)  
....................         {  
1770:  MOVLB  2
1772:  MOVF   x13,F
1774:  BTFSC  FD8.2
1776:  GOTO   1782
....................             gError = ERR_ISO_NO_KEYBYTE;      
177A:  MOVLW  84
177C:  MOVWF  1A
....................             return;  
177E:  GOTO   17FA
....................         }  
....................     }  
1782:  INCF   x12,F
1784:  GOTO   174C
....................   
....................     delay_ms(35);  // satisfy W4 per ISO 9141		  
1788:  MOVLW  23
178A:  MOVWF  x3C
178C:  MOVLB  0
178E:  CALL   07F4
....................   
....................     // send inv second keyword  
.................... 	VehSendKLine(~b);  
1792:  MOVLB  2
1794:  MOVF   x11,W
1796:  MOVWF  x14
1798:  COMF   x14,F
179A:  MOVLB  0
179C:  MOVFF  214,215
17A0:  CALL   16D4
.................... 	gErrorExtraData2 = b;  
17A4:  MOVFF  211,1C
....................   
....................     // get address  
....................     b = timed_getc(&timeout, 5000);  
17A8:  MOVLW  02
17AA:  MOVLB  2
17AC:  MOVWF  x39
17AE:  MOVLW  13
17B0:  MOVWF  x38
17B2:  MOVWF  x3B
17B4:  MOVLW  88
17B6:  MOVWF  x3A
17B8:  MOVLB  0
17BA:  CALL   1586
17BE:  MOVFF  01,211
.................... 	if (timeout == TRUE)  
.................... 	{  
17C2:  MOVLB  2
17C4:  DECFSZ x13,W
17C6:  GOTO   17D2
.................... 		gError = ERR_ISO_INV_ADDR_NOT_RECEIVED;  
17CA:  MOVLW  1F
17CC:  MOVWF  1A
.................... 		return;  
17CE:  GOTO   17FA
.................... 	}        
....................     if (b != ~addr)         
....................     {  
17D2:  MOVF   x10,W
17D4:  XORLW  FF
17D6:  SUBWF  x11,W
17D8:  BTFSC  FD8.2
17DA:  GOTO   17EE
....................         gError = ERR_ISO_INCORRECT_INV_ADDR;  
17DE:  MOVLW  04
17E0:  MOVWF  1A
.................... 		gErrorExtraData2 = b;  
17E2:  MOVLB  0
17E4:  MOVFF  211,1C
....................         return;  
17E8:  MOVLB  2
17EA:  GOTO   17FA
....................     }  
....................   
....................     delay_ms(60);   // satisfy P3 timing per ISO 9141 (55ms really, don't shave too close)  
17EE:  MOVLW  3C
17F0:  MOVWF  x3C
17F2:  MOVLB  0
17F4:  CALL   07F4
17F8:  MOVLB  2
.................... }  
17FA:  MOVLB  0
17FC:  RETLW  00
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: VehSendJ1850  
.................... // Description: Send a message using J1850.   
.................... // Parameters: type - VPW or PWM.   
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void VehSendJ1850(int8 type)  
.................... {  
....................     int8 err;  
....................       
....................     // tack on the CRC to end of message  
....................     gHostBuf[IDX_HOST_START_DATA + gHostBuf[IDX_HOST_BYTE_COUNT]] =  
....................         crc8(&gHostBuf[IDX_HOST_START_DATA], gHostBuf[IDX_HOST_BYTE_COUNT]);  
*
0E32:  MOVLW  03
0E34:  ADDWF  34,W
0E36:  CLRF   03
0E38:  ADDLW  32
0E3A:  MOVWF  01
0E3C:  MOVLW  00
0E3E:  ADDWFC 03,F
0E40:  MOVF   01,W
0E42:  MOVLB  2
0E44:  MOVWF  x13
0E46:  MOVLB  0
0E48:  MOVFF  03,214
0E4C:  MOVLB  2
0E4E:  CLRF   x49
0E50:  MOVLW  35
0E52:  MOVWF  x48
0E54:  MOVLB  0
0E56:  MOVFF  34,24A
0E5A:  CALL   0AF2
0E5E:  MOVFF  214,FEA
0E62:  MOVFF  213,FE9
0E66:  MOVFF  01,FEF
....................   
....................     // send J1850 message to vehicle (max 100mS timeout to get on bus)  
....................     if (type == MODE_VPW)  
....................         err = VPWSend(&gHostBuf[IDX_HOST_START_DATA], gHostBuf[IDX_HOST_BYTE_COUNT]+1, 50);  
0E6A:  MOVLB  2
0E6C:  DECFSZ x10,W
0E6E:  GOTO   0E9A
0E72:  MOVLW  01
0E74:  ADDWF  34,W
0E76:  MOVWF  x12
0E78:  CLRF   x14
0E7A:  MOVLW  35
0E7C:  MOVWF  x13
0E7E:  MOVLB  0
0E80:  MOVFF  212,215
0E84:  MOVLW  32
0E86:  MOVLB  2
0E88:  MOVWF  x16
0E8A:  MOVLB  0
0E8C:  GOTO   0B72
0E90:  MOVFF  01,211
....................     else    
....................         err = PWMSend(&gHostBuf[IDX_HOST_START_DATA], gHostBuf[IDX_HOST_BYTE_COUNT]+1, 50);  
0E94:  GOTO   0EBC
0E98:  MOVLB  2
0E9A:  MOVLW  01
0E9C:  ADDWF  34,W
0E9E:  MOVWF  x12
0EA0:  CLRF   x14
0EA2:  MOVLW  35
0EA4:  MOVWF  x13
0EA6:  MOVLB  0
0EA8:  MOVFF  212,215
0EAC:  MOVLW  32
0EAE:  MOVLB  2
0EB0:  MOVWF  x16
0EB2:  MOVLB  0
0EB4:  GOTO   0CCA
0EB8:  MOVFF  01,211
....................           
....................     CheckSendRecvErr(err);  
0EBC:  MOVFF  211,23A
0EC0:  CALL   0E06
.................... }  
0EC4:  RETLW  00
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: VehRecvJ1850  
.................... // Description: Recv a message using J1850. If 1st response, this routine should   
.................... //  exit on the first message. If not 1st response, this routine should exit  
.................... //  after VEHICLE_MAX_MSGS received or a recv timeout occurs.    
.................... //  Note: The VPWRecv and PWMRecv funcs must pass in a buffer located in bank 0.   
.................... // Parameters: type - VPW or PWM.   
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void VehRecvJ1850(int8 type)  
.................... {  
....................     int8 cpyCnt, err, size;  
....................     int8 msgSizes[VEHICLE_MAX_MSGS];  
....................     int32 totalRecvTimeout;  
....................     int16 recvTimeout;  
....................       
....................     totalRecvTimeout = 0;  
*
1222:  MOVLB  2
1224:  CLRF   x37
1226:  CLRF   x36
1228:  CLRF   x35
122A:  CLRF   x34
....................     recvTimeout = HstGetTicks();  
122C:  MOVLB  0
122E:  CALL   00B6
1232:  MOVFF  02,239
1236:  MOVFF  01,238
....................   
....................     gVehicleBufCnt = 0;  
123A:  CLRF   21
....................     while (1)  
....................     {  
....................         // get message from vehicle. Per J2190 if no response in 100mS, then timeout  
....................         if (type == MODE_VPW)  
....................             err = VPWRecv(&gVehicleBuf[gVehicleBufCnt][0], &size, 50);  // 50 * 2mS = 100mS timeout  
123C:  MOVLB  2
123E:  DECFSZ x10,W
1240:  GOTO   1298
1244:  CLRF   x43
1246:  MOVLB  0
1248:  MOVFF  21,242
124C:  MOVLB  2
124E:  CLRF   x45
1250:  MOVLW  0C
1252:  MOVWF  x44
1254:  MOVLB  0
1256:  CALL   0EC6
125A:  MOVFF  02,23B
125E:  MOVFF  01,23A
1262:  MOVLW  41
1264:  MOVLB  2
1266:  ADDWF  01,W
1268:  MOVWF  x3C
126A:  MOVLW  00
126C:  ADDWFC 02,W
126E:  MOVWF  x3D
1270:  MOVLB  0
1272:  MOVFF  23D,23F
1276:  MOVFF  23C,23E
127A:  MOVLW  02
127C:  MOVLB  2
127E:  MOVWF  x41
1280:  MOVLW  13
1282:  MOVWF  x40
1284:  MOVLW  32
1286:  MOVWF  x42
1288:  MOVLB  0
128A:  GOTO   0EEC
128E:  MOVFF  01,212
....................         else  
....................             err = PWMRecv(&gVehicleBuf[gVehicleBufCnt][0], &size, 50);  
1292:  GOTO   12E6
1296:  MOVLB  2
1298:  CLRF   x43
129A:  MOVLB  0
129C:  MOVFF  21,242
12A0:  MOVLB  2
12A2:  CLRF   x45
12A4:  MOVLW  0C
12A6:  MOVWF  x44
12A8:  MOVLB  0
12AA:  CALL   0EC6
12AE:  MOVFF  02,23B
12B2:  MOVFF  01,23A
12B6:  MOVLW  41
12B8:  MOVLB  2
12BA:  ADDWF  01,W
12BC:  MOVWF  x3C
12BE:  MOVLW  00
12C0:  ADDWFC 02,W
12C2:  MOVWF  x3D
12C4:  MOVLB  0
12C6:  MOVFF  23D,23F
12CA:  MOVFF  23C,23E
12CE:  MOVLW  02
12D0:  MOVLB  2
12D2:  MOVWF  x41
12D4:  MOVLW  13
12D6:  MOVWF  x40
12D8:  MOVLW  32
12DA:  MOVWF  x42
12DC:  MOVLB  0
12DE:  GOTO   1014
12E2:  MOVFF  01,212
....................               
....................         // has 150mS passed since VPWRecv/PWMRecv call?? 
.................... 		// each msg 100mS appart is the spec, but some vehicles take longer. This check allows for more waiting time.  
....................         totalRecvTimeout += (int32)HstElapsedTime(recvTimeout);  
12E6:  MOVFF  239,23B
12EA:  MOVFF  238,23A
12EE:  CALL   1128
12F2:  MOVFF  01,00
12F6:  MOVFF  02,01
12FA:  CLRF   02
12FC:  CLRF   03
12FE:  MOVF   00,W
1300:  MOVLB  2
1302:  ADDWF  x34,F
1304:  MOVF   01,W
1306:  ADDWFC x35,F
1308:  MOVF   02,W
130A:  ADDWFC x36,F
130C:  MOVF   03,W
130E:  ADDWFC x37,F
....................         if (totalRecvTimeout > 93750)      // 150mS in 1.6uS ticks.   
....................         {  
1310:  MOVF   x37,F
1312:  BTFSS  FD8.2
1314:  GOTO   1346
1318:  MOVF   x36,W
131A:  SUBLW  00
131C:  BTFSC  FD8.0
131E:  GOTO   134E
1322:  XORLW  FF
1324:  BTFSS  FD8.2
1326:  GOTO   1346
132A:  MOVF   x35,W
132C:  SUBLW  6D
132E:  BTFSC  FD8.0
1330:  GOTO   134E
1334:  XORLW  FF
1336:  BTFSS  FD8.2
1338:  GOTO   1346
133C:  MOVF   x34,W
133E:  SUBLW  36
1340:  BTFSC  FD8.0
1342:  GOTO   134E
....................             gError = ERR_J1850_NO_RESPONSE;  
1346:  MOVLW  07
1348:  MOVWF  1A
....................             break;  
134A:  GOTO   141C
....................         }  
....................         recvTimeout = HstGetTicks();  
134E:  MOVLB  0
1350:  CALL   00B6
1354:  MOVFF  02,239
1358:  MOVFF  01,238
....................           
....................         // if no bus activity (i.e. no response) then try again  
....................         if (bit_test(err, 5))  
....................             continue;  
135C:  MOVLB  2
135E:  BTFSS  x12.5
1360:  GOTO   136C
1364:  MOVLB  0
1366:  GOTO   123C
136A:  MOVLB  2
....................   
....................         CheckSendRecvErr(err);  
136C:  MOVLB  0
136E:  MOVFF  212,23A
1372:  CALL   0E06
....................         if (gError)  
....................             break;  
1376:  MOVF   1A,F
1378:  BTFSC  FD8.2
137A:  GOTO   1386
137E:  MOVLB  2
1380:  GOTO   141C
1384:  MOVLB  0
....................               
....................         // Message filter: if message is not a response for scan tool, ignore it.   
....................         // Mode byte bit 6 = 0 are requests, bit 6 = 1 are responses  
....................         if (gVehicleBuf[gVehicleBufCnt][3] != (gHostBuf[6] | 0x40))  
....................             continue;  
1386:  MOVLB  2
1388:  CLRF   x43
138A:  MOVLB  0
138C:  MOVFF  21,242
1390:  MOVLB  2
1392:  CLRF   x45
1394:  MOVLW  0C
1396:  MOVWF  x44
1398:  MOVLB  0
139A:  CALL   0EC6
139E:  MOVFF  02,23B
13A2:  MOVFF  01,23A
13A6:  MOVLW  03
13A8:  MOVLB  2
13AA:  ADDWF  01,W
13AC:  MOVWF  01
13AE:  MOVLW  00
13B0:  ADDWFC 02,W
13B2:  MOVWF  03
13B4:  MOVF   01,W
13B6:  ADDLW  41
13B8:  MOVWF  FE9
13BA:  MOVLW  00
13BC:  ADDWFC 03,W
13BE:  MOVWF  FEA
13C0:  MOVLB  0
13C2:  MOVFF  FEF,23C
13C6:  MOVF   38,W
13C8:  IORLW  40
13CA:  MOVLB  2
13CC:  SUBWF  x3C,W
13CE:  BTFSC  FD8.2
13D0:  GOTO   13DC
13D4:  MOVLB  0
13D6:  GOTO   123C
13DA:  MOVLB  2
....................           
....................         // successfully obtained a message (CRC not checked yet)  
....................         msgSizes[gVehicleBufCnt] = size;  
13DC:  CLRF   03
13DE:  MOVF   21,W
13E0:  ADDLW  14
13E2:  MOVWF  FE9
13E4:  MOVLW  02
13E6:  ADDWFC 03,W
13E8:  MOVWF  FEA
13EA:  MOVLB  0
13EC:  MOVFF  213,FEF
....................   
.................... 		// valid msg for scan tool received, so reset total timeout. Each message arriving can be 100mS appart.  
....................     	totalRecvTimeout = 0;  
13F0:  MOVLB  2
13F2:  CLRF   x37
13F4:  CLRF   x36
13F6:  CLRF   x35
13F8:  CLRF   x34
.................... 	  
....................         if (++gVehicleBufCnt >= VEHICLE_MAX_MSGS)  
....................             break;  
13FA:  INCF   21,F
13FC:  MOVF   21,W
13FE:  SUBLW  1F
1400:  BTFSC  FD8.0
1402:  GOTO   140A
1406:  GOTO   141C
....................   
....................         // if host wanted only 1 response, then break early  
....................         if (gFlags.firstResp)  
....................             break;  
140A:  BTFSS  18.3
140C:  GOTO   1414
1410:  GOTO   141C
....................     }  
1414:  MOVLB  0
1416:  GOTO   123C
141A:  MOVLB  2
....................   
....................     // if vehicle obtained at least 1 message then timed out, that is okay  
....................     if (gVehicleBufCnt && gError == ERR_J1850_NO_RESPONSE)  
....................         gError = ERR_NONE;  
141C:  MOVF   21,F
141E:  BTFSC  FD8.2
1420:  GOTO   1430
1424:  MOVF   1A,W
1426:  SUBLW  07
1428:  BTFSS  FD8.2
142A:  GOTO   1430
142E:  CLRF   1A
....................   
....................     // check the CRC of the incoming messages  
....................     CheckCRC(msgSizes);	  
1430:  MOVLW  02
1432:  MOVWF  x3B
1434:  MOVLW  14
1436:  MOVWF  x3A
1438:  MOVLB  0
143A:  GOTO   1152
.................... }  
143E:  RETLW  00
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: CheckSendRecvErr  
.................... // Description: Test for VPW and PWM send/recv errors.   
.................... // Parameters: err - error byte returned from either PWMSend, PWMRecv, VPWSend,  
.................... //  VPWRecv.  
.................... //  Sets the global error byte to error is detected.  
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void CheckSendRecvErr(int8 err)  
.................... {  
....................     // test for recv errors  
....................     if (bit_test(err, 1))  
....................         gError = ERR_J1850_FRAMING_ERROR;  
*
0E06:  MOVLB  2
0E08:  BTFSS  x3A.1
0E0A:  GOTO   0E16
0E0E:  MOVLW  82
0E10:  MOVWF  1A
....................     else if (bit_test(err, 5))  
0E12:  GOTO   0E2E
....................         gError = ERR_J1850_NO_RESPONSE;  
0E16:  BTFSS  x3A.5
0E18:  GOTO   0E24
0E1C:  MOVLW  07
0E1E:  MOVWF  1A
....................     else if (bit_test(err, 4))  
0E20:  GOTO   0E2E
....................         gError = ERR_J1850_MSG_OVERFLOW;  
0E24:  BTFSS  x3A.4
0E26:  GOTO   0E2E
0E2A:  MOVLW  83
0E2C:  MOVWF  1A
.................... }  
0E2E:  MOVLB  0
0E30:  RETLW  00
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: CheckCRC  
.................... // Description: Check J1850 CRC on incoming messages. Sets global error flag  
.................... //  if error found.    
.................... // Parameters: msgSize - an array of message sizes. Array can't exceed   
.................... //  VEHICLE_MAX_MSGS.  
.................... // Output Parameters:  
.................... // Return Values:   
.................... //-----------------------------------------------------------------------------  
.................... void CheckCRC(int8* msgSizes)  
.................... {  
....................     int8 cnt;  
....................       
....................     // error check each received message using checksum  
....................     for (cnt=0; cnt<gVehicleBufCnt; cnt++)  
*
1152:  MOVLB  2
1154:  CLRF   x3C
1156:  MOVF   21,W
1158:  SUBWF  x3C,W
115A:  BTFSC  FD8.0
115C:  GOTO   121C
....................     {         
....................         // does received checksum match what was sent??         
....................         if (gVehicleBuf[cnt][msgSizes[cnt]-1] !=   
....................             crc8(&gVehicleBuf[cnt][0], msgSizes[cnt]-1))  
....................         {  
1160:  CLRF   x43
1162:  MOVLB  0
1164:  MOVFF  23C,242
1168:  MOVLB  2
116A:  CLRF   x45
116C:  MOVLW  0C
116E:  MOVWF  x44
1170:  MOVLB  0
1172:  CALL   0EC6
1176:  MOVFF  02,23E
117A:  MOVFF  01,23D
117E:  CLRF   03
1180:  MOVLB  2
1182:  MOVF   x3C,W
1184:  ADDWF  x3A,W
1186:  MOVWF  FE9
1188:  MOVF   x3B,W
118A:  ADDWFC 03,W
118C:  MOVWF  FEA
118E:  MOVLW  01
1190:  SUBWF  FEF,W
1192:  ADDWF  01,W
1194:  MOVWF  01
1196:  MOVLW  00
1198:  ADDWFC 02,W
119A:  MOVWF  03
119C:  MOVF   01,W
119E:  ADDLW  41
11A0:  MOVWF  FE9
11A2:  MOVLW  00
11A4:  ADDWFC 03,W
11A6:  MOVWF  FEA
11A8:  MOVLB  0
11AA:  MOVFF  FEF,241
11AE:  MOVLB  2
11B0:  CLRF   x43
11B2:  MOVLB  0
11B4:  MOVFF  23C,242
11B8:  MOVLB  2
11BA:  CLRF   x45
11BC:  MOVLW  0C
11BE:  MOVWF  x44
11C0:  MOVLB  0
11C2:  CALL   0EC6
11C6:  MOVFF  02,243
11CA:  MOVFF  01,242
11CE:  MOVLW  41
11D0:  MOVLB  2
11D2:  ADDWF  01,W
11D4:  MOVWF  x44
11D6:  MOVLW  00
11D8:  ADDWFC 02,W
11DA:  MOVWF  x45
11DC:  CLRF   03
11DE:  MOVF   x3C,W
11E0:  ADDWF  x3A,W
11E2:  MOVWF  FE9
11E4:  MOVF   x3B,W
11E6:  ADDWFC 03,W
11E8:  MOVWF  FEA
11EA:  MOVLW  01
11EC:  SUBWF  FEF,W
11EE:  MOVWF  x47
11F0:  MOVLB  0
11F2:  MOVFF  245,249
11F6:  MOVFF  244,248
11FA:  MOVFF  247,24A
11FE:  CALL   0AF2
1202:  MOVF   01,W
1204:  MOVLB  2
1206:  SUBWF  x41,W
1208:  BTFSC  FD8.2
120A:  GOTO   1216
....................             gError = ERR_J1850_BAD_CRC;  
120E:  MOVLW  09
1210:  MOVWF  1A
....................             return;  
1212:  GOTO   121C
....................         }  
....................     }  
1216:  INCF   x3C,F
1218:  GOTO   1156
.................... }  
121C:  MOVLB  0
121E:  GOTO   143E (RETURN)
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: VehSend5BPS  
.................... // Description: Sends one address byte out on the ISO K and L lines at at rate  
.................... //  of 5 BPS.  
.................... //  NOTE: Logic values are inverted (i.e. 1 = low and 0 = high) by the scan tool  
.................... //  hardaware.  
.................... // Parameters: byte - target address byte to send.  
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void VehSend5BPS(int8 byte)  
.................... {  
....................     int8 bit;  
....................   
....................     // TBD - KWP time W5 delay here?? 
....................     // ensure ISO 9141 time W0 of 2mS satisfied  
....................     output_bit(PIN_B6, 0);    
*
1440:  BCF    F8A.6
1442:  BCF    F93.6
....................     output_bit(PIN_B7, 0);  
1444:  BCF    F8A.7
1446:  BCF    F93.7
....................     delay_ms(2);  
1448:  MOVLW  02
144A:  MOVLB  2
144C:  MOVWF  x3C
144E:  MOVLB  0
1450:  CALL   07F4
....................   
....................     // send out one address byte at 5 BPS  
....................     // start bit  
....................     output_bit(PIN_B6, 1);  
1454:  BSF    F8A.6
1456:  BCF    F93.6
....................     output_bit(PIN_B7, 1);  
1458:  BSF    F8A.7
145A:  BCF    F93.7
....................     delay_ms(200);  
145C:  MOVLW  C8
145E:  MOVLB  2
1460:  MOVWF  x3C
1462:  MOVLB  0
1464:  CALL   07F4
....................   
....................     // send byte starting with LSB  
....................     for (bit=0; bit<8; bit++)  
1468:  MOVLB  2
146A:  CLRF   x15
146C:  MOVF   x15,W
146E:  SUBLW  07
1470:  BTFSS  FD8.0
1472:  GOTO   14B2
....................     {  
....................         if (bit_test(byte, 0))  
....................         {  
1476:  BTFSS  x14.0
1478:  GOTO   1494
....................             output_bit(PIN_B6, 0);  
147C:  BCF    F8A.6
147E:  BCF    F93.6
....................             output_bit(PIN_B7, 0);  
1480:  BCF    F8A.7
1482:  BCF    F93.7
....................             delay_ms(200);  
1484:  MOVLW  C8
1486:  MOVWF  x3C
1488:  MOVLB  0
148A:  CALL   07F4
....................         }  
....................         else  
....................         {  
148E:  GOTO   14A6
1492:  MOVLB  2
....................             output_bit(PIN_B6, 1);  
1494:  BSF    F8A.6
1496:  BCF    F93.6
....................             output_bit(PIN_B7, 1);  
1498:  BSF    F8A.7
149A:  BCF    F93.7
....................             delay_ms(200);  
149C:  MOVLW  C8
149E:  MOVWF  x3C
14A0:  MOVLB  0
14A2:  CALL   07F4
....................         }  
....................         // go to next bit  
....................         byte = byte >> 1;  
14A6:  BCF    FD8.0
14A8:  MOVLB  2
14AA:  RRCF   x14,F
....................     }   
14AC:  INCF   x15,F
14AE:  GOTO   146C
....................   
....................     // stop bit  
....................     output_bit(PIN_B6, 0);  
14B2:  BCF    F8A.6
14B4:  BCF    F93.6
....................     output_bit(PIN_B7, 0);  
14B6:  BCF    F8A.7
14B8:  BCF    F93.7
....................     delay_ms(200);  
14BA:  MOVLW  C8
14BC:  MOVWF  x3C
14BE:  MOVLB  0
14C0:  CALL   07F4
.................... }  
14C4:  GOTO   1700 (RETURN)
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: VehFastInit  
.................... // Description: Perform the KWP fast initalization on K and L lines.   
.................... //  NOTE: Logic values are inverted (i.e. 1 = low and 0 = high) by the scan tool  
.................... //  hardaware.  
.................... // Parameters:  
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void VehFastInit()  
.................... {  
....................     //TBD - W5 delay here?? 
....................   
....................     // TiniL from 14230-2 spec  
....................     output_bit(PIN_B6, 1);  
*
1BD6:  BSF    F8A.6
1BD8:  BCF    F93.6
....................     output_bit(PIN_B7, 1);  
1BDA:  BSF    F8A.7
1BDC:  BCF    F93.7
.................... 	if (gCurrentCmd == CMD_KWP_FAST_INIT_9600)  
.................... 	{  
1BDE:  MOVF   22,W
1BE0:  SUBLW  C4
1BE2:  BTFSS  FD8.2
1BE4:  GOTO   1BFA
.................... 		gFlags.enableIso9600Baud = TRUE;  
1BE8:  BSF    19.0
....................     	delay_ms(35);  
1BEA:  MOVLW  23
1BEC:  MOVLB  2
1BEE:  MOVWF  x3C
1BF0:  MOVLB  0
1BF2:  CALL   07F4
.................... 	}  
.................... 	else  
.................... 	{  
1BF6:  GOTO   1C08
.................... 		gFlags.enableIso9600Baud = FALSE;  
1BFA:  BCF    19.0
....................     	delay_ms(25);  
1BFC:  MOVLW  19
1BFE:  MOVLB  2
1C00:  MOVWF  x3C
1C02:  MOVLB  0
1C04:  CALL   07F4
.................... 	}  
....................   
....................     // TiniH from 14230-2 spec  
....................     output_bit(PIN_B6, 0);  
1C08:  BCF    F8A.6
1C0A:  BCF    F93.6
....................     output_bit(PIN_B7, 0);  
1C0C:  BCF    F8A.7
1C0E:  BCF    F93.7
.................... 	if (gCurrentCmd == CMD_KWP_FAST_INIT_9600)  
.................... 		delay_ms(15);  
1C10:  MOVF   22,W
1C12:  SUBLW  C4
1C14:  BTFSS  FD8.2
1C16:  GOTO   1C2A
1C1A:  MOVLW  0F
1C1C:  MOVLB  2
1C1E:  MOVWF  x3C
1C20:  MOVLB  0
1C22:  CALL   07F4
.................... 	else  
....................     	delay_ms(25);  
1C26:  GOTO   1C36
1C2A:  MOVLW  19
1C2C:  MOVLB  2
1C2E:  MOVWF  x3C
1C30:  MOVLB  0
1C32:  CALL   07F4
....................   
....................     // TBD - toggle low here?? 
.................... }  
1C36:  GOTO   3548 (RETURN)
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: VehSetIso5msByteDelayEnable  
.................... // Description: ISO 9141 states the interbyte message timing to the vehicle  
.................... //	must be 5mS. When enabled, the 5mS between each byte is inserted, when   
.................... //	disabled no delay is inserted and the data is sent as fast as possible.  
.................... // Parameters:  
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void VehSetIso5msByteDelayEnable()  
.................... {  
.................... 	if (gHostBuf[2] == 0)  
.................... 		gFlags.enableIso5msByteDelay = FALSE;  
*
306C:  MOVF   34,F
306E:  BTFSS  FD8.2
3070:  GOTO   307A
3074:  BCF    19.1
.................... 	else  
.................... 		gFlags.enableIso5msByteDelay = TRUE;  
3076:  GOTO   307C
307A:  BSF    19.1
.................... }  
307C:  GOTO   3604 (RETURN)
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: VehSetLLineXmitEnable  
.................... // Description: Sets the L line transmit either true of false.   
.................... // Parameters:  
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void VehSetLLineXmitEnable()  
.................... {  
.................... 	if (gHostBuf[2] == 0)  
.................... 		gFlags.enableLLineXmit = FALSE;  
3080:  MOVF   34,F
3082:  BTFSS  FD8.2
3084:  GOTO   308E
3088:  BCF    18.7
.................... 	else  
.................... 		gFlags.enableLLineXmit = TRUE;  
308A:  GOTO   3090
308E:  BSF    18.7
.................... }  
3090:  GOTO   3616 (RETURN)
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: VehIsoSet9600BaudEnable  
.................... // Description: Sets ISO baud rate to 9600 or 10.4k   
.................... // Parameters:  
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void VehSetIso9600BaudEnable()  
.................... {  
.................... 	if (gHostBuf[2] == 0)  
.................... 		gFlags.enableIso9600Baud = FALSE;  
3094:  MOVF   34,F
3096:  BTFSS  FD8.2
3098:  GOTO   30A2
309C:  BCF    19.0
.................... 	else  
.................... 		gFlags.enableIso9600Baud = TRUE;  
309E:  GOTO   30A4
30A2:  BSF    19.0
.................... }  
30A4:  GOTO   3628 (RETURN)
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: VehSetIsoChecksumEnable  
.................... // Description: Sets adding ISO checksum to the end of each messsage, or to  
.................... //	not add the checksum byte.   
.................... // Parameters:  
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void VehSetIsoChecksumEnable()  
.................... {  
.................... 	if (gHostBuf[2] == 0)  
.................... 		gFlags.enableIsoChecksum = FALSE;  
*
3058:  MOVF   34,F
305A:  BTFSS  FD8.2
305C:  GOTO   3066
3060:  BCF    19.2
.................... 	else  
.................... 		gFlags.enableIsoChecksum = TRUE;  
3062:  GOTO   3068
3066:  BSF    19.2
.................... }  
3068:  GOTO   35F2 (RETURN)
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: VehReadBatteryVoltage  
.................... // Description: Read the battery voltage via the A/D converter. A/D is assumed  
.................... //	to be already setup and on the right channel before this function is called.  
.................... // Parameters:  
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void VehReadBatteryVoltage()  
.................... {  
.................... 	int16 voltage;  
.................... 	  
.................... 	if (gDevid2 == VER_18F248)  
.................... 	{	  
*
2FFA:  MOVF   17,W
2FFC:  SUBLW  08
2FFE:  BTFSS  FD8.2
3000:  GOTO   3044
.................... 		// on old 18F248 part, we can use the CCS compiler built in function  
.................... 		set_adc_channel(0);  
3004:  MOVLW  00
3006:  MOVWF  01
3008:  MOVF   FC2,W
300A:  ANDLW  C7
300C:  IORWF  01,W
300E:  MOVWF  FC2
.................... 		delay_us(10);  
3010:  MOVLW  10
3012:  MOVWF  00
3014:  DECFSZ 00,F
3016:  BRA    3014
3018:  NOP   
.................... 		voltage = read_adc();  
301A:  BSF    FC2.2
301C:  BTFSC  FC2.2
301E:  GOTO   301C
3022:  MOVF   FC4,W
3024:  MOVWF  03
3026:  MOVF   FC3,W
3028:  MOVLB  2
302A:  MOVWF  x10
302C:  MOVLB  0
302E:  MOVFF  03,211
.................... 		  
.................... 		// put A/D reading into buffer for transmission to host  
.................... 		gVehicleBuf[0][0] = (int8)(voltage >> 8);  
3032:  MOVLB  2
3034:  MOVF   x11,W
3036:  CLRF   03
3038:  MOVWF  41
.................... 		gVehicleBuf[0][1] = (int8)voltage;  
303A:  MOVLB  0
303C:  MOVFF  210,42
.................... 	}  
.................... 	else  
.................... 	{  
3040:  GOTO   3054
.................... 		// on new 18F2480 part, the register/bit locations changed so must do manually  
.................... 		  
.................... 		// start ADC conversion  
.................... 		bit_set(ADCON0, 1);  
3044:  BSF    FC2.1
.................... 		  
.................... 		// wait for conversion to complete  
.................... 		while (bit_test(ADCON0, 1));  
3046:  BTFSC  FC2.1
3048:  GOTO   3046
.................... 		  
.................... 		// read A/D reading into buffer for transmission to host  
.................... 		gVehicleBuf[0][0] = ADRESH;  
304C:  MOVFF  FC4,41
.................... 		gVehicleBuf[0][1] = ADRESL;  
3050:  MOVFF  FC3,42
.................... 	}	  
.................... }  
3054:  GOTO   35E0 (RETURN)
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: timed_getc  
.................... // Description: Get a character from the ISO UART using a timeout. If a   
.................... //  character doesn't arrive in the timeout specified the function returns.  
.................... //  NOTE: timeout units of measure is 10's of uS. (e.g. 100 = 1000uS)  
.................... // Parameters: timedOut - TRUE if routine timed out with no char, FALSE otherwise.  
.................... //  timeout - the timeout to wait for the char in 10's of uS.  
.................... // Output Parameters:  
.................... // Return Values: The received character. Valid only if timedOut is FALSE.  
.................... //------------------------------------------------------------------------------  
.................... int8 timed_getc(BOOLEAN* timedOut, int16 timeout)   
.................... {  
....................     int16 time;  
....................   
....................     *timedOut = FALSE;  
*
1586:  MOVLB  2
1588:  MOVF   x38,W
158A:  MOVWF  FE9
158C:  MOVLB  0
158E:  MOVFF  239,FEA
1592:  CLRF   FEF
....................     time=0;  
1594:  MOVLB  2
1596:  CLRF   x3D
1598:  CLRF   x3C
....................   
....................     // wait up to timeout for a character to arrive  
....................     while(!kbhit()&&(++time<timeout))     
....................         delay_us(10);  
159A:  BTFSC  F81.5
159C:  GOTO   15CE
15A0:  INCF   x3C,F
15A2:  BTFSC  FD8.2
15A4:  INCF   x3D,F
15A6:  MOVF   x3D,W
15A8:  SUBWF  x3B,W
15AA:  BTFSS  FD8.0
15AC:  GOTO   15CE
15B0:  BTFSS  FD8.2
15B2:  GOTO   15C0
15B6:  MOVF   x3A,W
15B8:  SUBWF  x3C,W
15BA:  BTFSC  FD8.0
15BC:  GOTO   15CE
15C0:  MOVLW  10
15C2:  MOVWF  00
15C4:  DECFSZ 00,F
15C6:  BRA    15C4
15C8:  NOP   
15CA:  GOTO   159A
....................   
....................     if(kbhit())  
.................... 	{  
15CE:  BTFSS  F81.5
15D0:  GOTO   1606
.................... 		if (gFlags.enableIso9600Baud == TRUE)  
.................... 	        return(fgetc(ISO_K_9600_LINE_STREAM));  
15D4:  MOVLW  00
15D6:  BTFSC  19.0
15D8:  MOVLW  01
15DA:  SUBLW  01
15DC:  BTFSS  FD8.2
15DE:  GOTO   15F4
15E2:  MOVLB  0
15E4:  GOTO   14C8
15E8:  MOVF   01,W
15EA:  GOTO   1620
.................... 		else  
.................... 			return(fgetc(ISO_K_LINE_STREAM));  
15EE:  GOTO   1600
15F2:  MOVLB  2
15F4:  MOVLB  0
15F6:  GOTO   1528
15FA:  MOVF   01,W
15FC:  GOTO   1620
.................... 	}  
....................     else  
....................     {  
1600:  GOTO   1620
1604:  MOVLB  2
....................         *timedOut=TRUE;  
1606:  MOVLB  0
1608:  MOVLB  2
160A:  MOVF   x38,W
160C:  MOVWF  FE9
160E:  MOVLB  0
1610:  MOVFF  239,FEA
1614:  MOVLW  01
1616:  MOVWF  FEF
....................         return(0);  
1618:  MOVLW  00
161A:  MOVWF  01
161C:  GOTO   1620
....................     }   
.................... }  
1620:  RETLW  00
....................   
....................   
....................   
....................   
....................   
....................   
....................   
....................   
....................   
....................   
....................  
.................... #include "Host.c" 
....................  //------------------------------------------------------------------------------  
.................... // File: Host  
.................... //  
.................... // Purpose: Host communication and parsing routines.   
.................... //  
.................... // Change History:  
.................... // Date		Author		Description  
.................... //          Lafreniere	Created  
.................... //------------------------------------------------------------------------------  
.................... #include "Host.h" 
....................  //------------------------------------------------------------------------------  
.................... // File: Host  
.................... //  
.................... // Purpose: Host communication and parsing routines.   
.................... //  
.................... // Change History:  
.................... // Date		Author		Description  
.................... //          Lafreniere	Created  
.................... //------------------------------------------------------------------------------  
.................... #ifndef HOST_H  
.................... #define HOST_H  
....................   
.................... BOOLEAN HostParseMsg();  
.................... void HostSendVehicleData();  
.................... void HostSendLocalData();  
.................... void HostSendError();  
....................   
.................... #endif  
....................  
.................... #include "Globals.h" 
....................  //------------------------------------------------------------------------------  
.................... // File: Globals  
.................... //  
.................... // Purpose: Project global variables.  
.................... //  
.................... // Change History:  
.................... // Date		Author		Description  
.................... //          Lafreniere	Created  
.................... //------------------------------------------------------------------------------  
.................... #ifndef GLOBALS_H  
.................... #define GLOBALS_H  
....................   
.................... #include "Const.h"  
.................... #include "Timer.h"  
....................                    
.................... typedef struct   
.................... {  
....................     int8 comType : 3;  
....................     int8 firstResp : 1;  
.................... 	int8 forceInitCAN : 1;  
....................     int8 canModeChanged : 1;  // true when mode changes (e.g. 250kb to 500kb, or SI to EI)  
....................     int8 adapterLocked : 1;  
.................... 	int8 enableLLineXmit : 1; 		// transmit at 10.4 on both K and L lines (default is K line only)  
.................... 	int8 enableIso9600Baud : 1;		// transmit ISO at 9600 if true, false means 10.4k (default is 10.4k)  
.................... 	int8 enableIso5msByteDelay : 1; // true means 5mS between each byte sent to vehicle, false no delay (default is true)  
.................... 	int8 enableIsoChecksum : 1;		// add checksum byte to ISO messages if true, no byte added if false (default is true)  
.................... } Flags;  
....................   
.................... int8 gDevid1;  
.................... int8 gDevid2;  
....................   
.................... Flags gFlags = { MODE_ISO, FALSE };  
.................... int8 gError = ERR_NONE;  
.................... int8 gErrorExtraData1 = 0;  
.................... int8 gErrorExtraData2 = 0;  
.................... int8 gErrorExtraData3 = 0;  
....................   
.................... int8 gHostBuf[HOST_RECV_MSG_SIZE];  
.................... //*** #locate gHostBuf=0x2d  // pic18f248 should not require ram to be managed  
.................... int8 gHostBufCnt = 0;  
.................... int16 gHostRecvTimeout = 0;  
....................   
.................... int8 gVehicleBuf[VEHICLE_MAX_MSGS][VEHICLE_MSG_SIZE];  
.................... //*** #locate gVehicleBuf=0xa0  
....................   
.................... int8 gVehicleBufCnt = 0;  
....................   
.................... int8 gCurrentCmd = 0;   // current command sent from host  
.................... int8 gLastCmd = 0;      // last command sent from host  
....................   
.................... int32 gP2can = HST_FIFTY_MS;  
....................   
.................... // decyption variables  
.................... int16  gLfsr;  
.................... //int8 gLast;  
....................   
.................... #endif  
....................  
.................... #include "Const.h" 
....................  //------------------------------------------------------------------------------  
.................... // File: Const  
.................... //  
.................... // Purpose: Project constants.  
.................... //  
.................... // Change History:  
.................... // Date		Author		Description  
.................... //          Lafreniere	Created  
.................... //------------------------------------------------------------------------------  
.................... #ifndef CONST_H  
.................... #define CONST_H  
....................   
.................... #ifdef DEBUG  
....................     #define TRACE(char) Trace(char);  
.................... #else  
....................     #define TRACE(char)   
.................... #endif  
....................   
.................... // software revision  
.................... #define SOFTWARE_REV            0x08  
....................   
.................... #define MAX_ECU				8 	// per ISO 15675-4 7.3.3. max ECUs is 8  
....................   
.................... #define DEVID1_ADDR 0x3FFFFEL  
.................... #define DEVID2_ADDR 0x3FFFFFL   
....................   
.................... // The old 18F248 and the new 18F2480 have some differences, mostly in the analog  
.................... // to digital converter. Using _DEVID2 check the processor version.   
.................... #define VER_18F248				0x08  
.................... //#define VER_18F2480 					  
....................   
.................... // destination address  
.................... #define DESTINATION_ADDR        0x2d  
....................   
.................... // from host msg byte positions  
.................... #define IDX_HOST_DESTINATION        0  
.................... #define IDX_HOST_COMMAND            1  
.................... #define IDX_HOST_BYTE_COUNT         2  
.................... #define IDX_HOST_START_DATA         3  
.................... #define IDX_HOST_CHECKSUM           14  
....................   
.................... // to host msg byte positions  
.................... #define IDX_VEHICLE_DESTINATION     0  
.................... #define IDX_VEHICLE_COMMAND         1  
.................... #define IDX_VEHICLE_CHECKSUM        13  
....................   
.................... // max size of all messages  
.................... #define HOST_RECV_MSG_SIZE          15      // from host size including all non-OBD II bytes  
.................... #define HOST_SEND_MSG_SIZE          14      // to host size  
.................... #define VEHICLE_MSG_SIZE            12      // to/from max vehicle size, not as sent to host (RSP byte not included)   
.................... #define VEHICLE_MAX_MSGS            32      // number of VEHICLE_MSG_SIZE we can store in RAM  
....................   
.................... // error codes returned to host  
.................... #define ERR_NONE                        0x00   // ERR_NONE must be 0!  
.................... #define ERR_NOT_IMPLEMENTED             0x01  
.................... #define ERR_BAD_CHECKSUM                0x02  
.................... #define ERR_ISO_NO_SYNC                 0x03  
.................... #define ERR_ISO_INCORRECT_INV_ADDR      0x04  
.................... #define ERR_ISO_NO_RESPONSE             0x05  
.................... #define ERR_J1850_NO_RESPONSE           0x07  
.................... #define ERR_ISO_BAD_CHECKSUM            0x08  
.................... #define ERR_J1850_BAD_CRC               0x09      
.................... #define ERR_KWP_BAUD_TOO_SLOW           0x0b    // not used  
.................... #define ERR_KWP_NO_RESPONSE             0x0c    // not used  
.................... #define ERR_KWP_INCORRECT_SYNC          0x0d    // not used  
.................... #define ERR_ISO_NOT_ENABLED             0x10    // not used  
.................... #define ERR_J1850_VPW_NOT_ENABLED       0x11    // not used  
.................... #define ERR_J1850_PWM_NOT_ENABLED       0x12    // not used  
.................... #define ERR_KWP_NOT_ENABLED             0x13    // not used  
.................... #define ERR_VW_PASS_THRU_NOT_ENABLED    0x14    // not used  
.................... #define ERR_CAN_NO_RESPONSE             0x15	// COMSTAT CAN register returned as extra data  
.................... #define ERR_CAN_RX_OVERFLOW             0x16  
.................... #define ERR_CAN_TX_BUFFER_UNAVAIL       0x18  
.................... #define ERR_CAN_RX_MESSAGE_LEN_WRONG    0x19  
.................... #define ERR_CAN_ERROR_INTERRUPT			0x1A	// COMSTAT CAN register returned as extra data  
.................... #define ERR_CAN_INVALID_MSG_INTERRUPT   0x1B    // TXBnCON CAN register returned as extra data 1, 2 and 3  
.................... #define ERR_ISO_INV_ADDR_NOT_RECEIVED	0x1F  
.................... #define ERR_ISO_SYNC_BYTE_NOT_RECEIVED	0x20  
....................   
.................... #define ERR_WRONG_DESTINATION           0x80      
.................... #define ERR_BYTE_COUNT_TOO_LARGE        0x81  
.................... #define ERR_J1850_FRAMING_ERROR         0x82  
.................... #define ERR_J1850_MSG_OVERFLOW          0x83   
.................... #define ERR_ISO_NO_KEYBYTE              0x84  
.................... #define ERR_ADAPTER_LOCKED              0x85  
.................... #define ERR_INVALID_NON_VOLATILE_SECTOR 0x86  
.................... #define ERR_NON_VOLATILE_SECTOR_LOCKED  0x87  
....................   
.................... // host-to-adapter commands  
.................... #define CMD_ISO_WITH_5_BAUD             0x01  
.................... #define CMD_VPW                         0x02  
.................... #define CMD_PWM                         0x04  
.................... #define CMD_CAN_SI_250KB                0x08      
.................... #define CMD_ISO                         0x10  
.................... #define CMD_VW_PASS_THRU_WITH_5_BAUD    0x20    // not used  
.................... #define CMD_VW_PASS_THRU_WITHOUT_5_BAUD 0x40    // not used  
.................... #define CMD_PWM_WITH_IFR                0x80  
.................... #define CMD_ISO_1ST_RESPONSE            0x81  
.................... #define CMD_VPW_1ST_RESPONSE            0x82  
.................... #define CMD_ATOD_CONVERSION             0x83    // not used  
.................... #define CMD_PWM_1ST_RESPONSE            0x84  
.................... #define CMD_KWP_WITH_5_BAUD             0x85  
.................... #define CMD_KWP_REPORT_KW1_KW2          0x86    // not used  
.................... #define CMD_KWP_FAST_INIT               0x87  
.................... #define CMD_KWP                         0x88  
.................... #define CMD_KWP_1ST_RESPONSE            0x89  
.................... #define CMD_CAN_SI_500KB                0x90  
.................... #define CMD_CAN_EI_250KB                0x91  
.................... #define CMD_CAN_EI_500KB                0x92  
.................... #define CMD_CAN_SI_250KB_1ST            0x93  
.................... #define CMD_CAN_SI_500KB_1ST            0x94  
.................... #define CMD_CAN_EI_250KB_1ST            0x95  
.................... #define CMD_CAN_EI_500KB_1ST            0x96  
.................... #define CMD_CAN_SET_STD_MASK_FILTER		0x97  
.................... #define CMD_CAN_SET_XTD_MASK_FILTER		0x98  
.................... #define CMD_CAN_SET_P2_CAN_TIMEOUT		0x99  
.................... #define CMD_CAN_SI_250KB_FBGO			0x9A	// FBGO = fast bus get off  
.................... #define CMD_CAN_SI_500KB_FBGO			0x9B	// FBGO = fast bus get off  
.................... #define CMD_CAN_EI_250KB_FBGO			0x9C	// FBGO = fast bus get off  
.................... #define CMD_CAN_EI_500KB_FBGO			0x9D	// FBGO = fast bus get off  
.................... #define CMD_CAN_SI_250KB_LISTEN			0x9E	  
.................... #define CMD_CAN_SI_500KB_LISTEN			0x9F	  
.................... #define CMD_CAN_EI_250KB_LISTEN			0xA0	  
.................... #define CMD_CAN_EI_500KB_LISTEN			0xA1  
.................... #define CMD_CAN_SI_250KB_NO_RESPONSE	0xA2	  
.................... #define CMD_CAN_SI_500KB_NO_RESPONSE	0xA3	  
.................... #define CMD_CAN_EI_250KB_NO_RESPONSE	0xA4	  
.................... #define CMD_CAN_EI_500KB_NO_RESPONSE	0xA5  
.................... #define CMD_ISO_NO_RESPONSE				0xA6  
.................... #define CMD_ISO_ENABLE_L_LINE_XMIT		0xA9  
.................... #define CMD_ISO_SET_9600_BAUD			0xAB  
.................... #define CMD_ISO_CHECKSUM_ENABLE			0xAC  
.................... #define CMD_ISO_5MS_BYTE_DELAY_ENABLE	0xAD  
.................... #define CMD_UNLOCK_ADAPTER              0xB0	  
.................... #define CMD_READ_EEPROM					0xB9  
.................... #define CMD_WRITE_EEPROM				0xBA  
.................... #define CMD_KWP_FAST_INIT_9600			0xC4  
.................... #define CMD_READ_BATTERY_VOLTAGE		0xF0  
....................   
.................... // adapter-to-host commands  
.................... #define CMD_ERROR                       0x80  
.................... #define CMD_ISO_MSG                     0x81  
.................... #define CMD_VPW_MSG                     0x82  
.................... #define CMD_PWM_MSG                     0x84  
.................... #define CMD_CAN_MSG                     0x88  
.................... #define CMD_KWP_MSG                     0x01  
.................... #define CMD_LOCAL_DATA					0x40  
....................   
.................... // transmit modes (must fit in 3-bits!)  
.................... #define MODE_ISO                 0x00  
.................... #define MODE_VPW                 0x01  
.................... #define MODE_PWM                 0x02  
.................... #define MODE_KWP                 0x03  
.................... #define MODE_CAN                 0x04  
....................   
.................... // interface capabilites (i.e. what com modes does the adapter support)  
.................... #define CAP_ISO         0x01  
.................... #define CAP_VPW         0x02  
.................... #define CAP_PWM         0x04  
.................... #define CAP_KWP         0x08  
.................... #define CAP_CAN         0x10  
.................... #define CAP_DUAL_CAN	0x20  
.................... #define DASH_DYNO_VER	0x40  
.................... #ifdef DASH_DYNO  
.................... #define CAP_INTERFACE   (CAP_ISO | CAP_VPW | CAP_PWM | CAP_KWP | CAP_CAN | DASH_DYNO_VER)  
.................... #else  
.................... #define CAP_INTERFACE   (CAP_ISO | CAP_VPW | CAP_PWM | CAP_KWP | CAP_CAN)  
.................... #endif  
....................   
.................... #endif   
....................  
.................... #include "Timer.h" 
....................  //------------------------------------------------------------------------------  
.................... // File: Timer  
.................... //  
.................... // Purpose: High speed timer (HST) routines.   
.................... //  
.................... // Change History:  
.................... // Date		Author		Description  
.................... //          Lafreniere	Created  
.................... //------------------------------------------------------------------------------  
.................... #ifndef TIMER_H  
.................... #define TIMER_H  
....................   
.................... #define TIMER1_TIMEOUT          0     // 1.6uS per tick with div set to 8  
.................... #define MS_TO_TICKS(mS) 		((mS * 10000) / 16)	  // 1.6uS per tick  
....................   
.................... // max 16-bit number  
.................... #define HST_TWO_MS              1250  
.................... #define HST_TEN_MS              6250  
.................... #define HST_TWENTY_FIVE_MS      15625  
.................... #define HST_FIFTY_MS            31250  
.................... #define HST_FIVE_HUNDRED_MS		312500	// NOTE: this number exceeds 16-bit timer and must be used with Int32  
.................... #define HST_ONE_S				625000	// NOTE: this number exceeds 16-bit timer and must be used with Int32  
....................   
.................... typedef int16 HstTimer; //TBD DEBUG  
.................... //typedef int32 HstTimer;  
....................               
.................... HstTimer HstGetTicks(void) { return get_timer1(); }  
.................... BOOLEAN HstTestTimer(HstTimer timer, HstTimer ticks);  
.................... BOOLEAN HstTestTimerRetrig(HstTimer *timer, HstTimer ticks);  
.................... HstTimer HstElapsedTime(HstTimer timer);  
....................   
.................... #endif  
....................  
.................... #include "Util.h" 
....................  //------------------------------------------------------------------------------  
.................... // File: Util  
.................... //  
.................... // Purpose: Misc utility routines.   
.................... //  
.................... // Change History:  
.................... // Date		Author		Description  
.................... //          Lafreniere	Created  
.................... //------------------------------------------------------------------------------  
.................... #ifndef UTIL_H  
.................... #define UTIL_H  
....................   
.................... // starting address for the 4-byte EEPOM write protect table  
.................... #define EEPROM_WRITE_PROTECT_TABLE_ADDR 	252  
....................   
.................... // the logical sector size is arbitrary and has nothing to do with the PIC hardware  
.................... #define EEPROM_SECTOR_SIZE 	8  
....................   
.................... void ReadEeprom();  
.................... void ReadEepromLocal(int8 sector);  
.................... void WriteEeprom();  
.................... int8 IsEepromSectorWriteProtected(int8 sector);  
.................... int32 ReadEepromSectorWriteProtectTable();  
.................... void WriteEerpomSectorWriteProtectTable(int32 writeProtectBits);  
.................... void init_ports();  
.................... void Bus_If_Init(void);  
.................... void DecryptBlock(int8 *outbfr, int8 *inbfr);  
.................... int8 IsCmdCAN(int8 cmd);  
.................... int8 IsCmdLocal(int8 cmd);  
.................... int8 IsCmdFBGO(int8 cmd);  
.................... int8 IsCmdListen(int8 cmd);  
.................... int8 IsCmdNoResponse(int8 cmd);  
.................... int8 IsCmdFirstResp(int8 cmd);  
.................... int8 IsCmdStandardId(int8 cmd);  
.................... int8 IsCmd250kb(int8 cmd);  
.................... int8 checksum(int8* pMsg, int8 size);  
.................... int8 crc8(int8* buffer, int8 count);  
.................... int32 StrToInt32(int8* str);  
.................... int8 TraceStr(int8* pMsg, int8 size);  
.................... int8 Trace(int8 msg);  
....................   
.................... #endif  
....................  
....................   
.................... // setup the host UART which is the hardware UART  
.................... #ifdef DASH_DYNO  
.................... #use rs232(baud=115200,xmit=PIN_C6,rcv=PIN_C7,parity=n,bits=8,stream=STREAM_HOST)   
.................... #else  
.................... #use rs232(baud=19200,xmit=PIN_C6,rcv=PIN_C7,parity=n,bits=8,stream=STREAM_HOST)   
.................... #endif  
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: HostParseMsg   
.................... // Description: Parse and error check the incoming host message. gError will   
.................... //  contain an error if parse fails.   
.................... // Parameters:   
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void HostParseMsg()  
.................... {  
.................... 	// error check incoming message (order of these checks is important! Last  
....................     // check has the highest priority error code).  
....................     if (gFlags.adapterLocked == TRUE && gHostBuf[IDX_HOST_COMMAND] != CMD_UNLOCK_ADAPTER)  
....................         gError = ERR_ADAPTER_LOCKED;  
*
09FE:  MOVLW  00
0A00:  BTFSC  18.6
0A02:  MOVLW  01
0A04:  SUBLW  01
0A06:  BTFSS  FD8.2
0A08:  GOTO   0A1A
0A0C:  MOVF   33,W
0A0E:  SUBLW  B0
0A10:  BTFSC  FD8.2
0A12:  GOTO   0A1A
0A16:  MOVLW  85
0A18:  MOVWF  1A
....................     if (gHostBuf[IDX_HOST_DESTINATION] != DESTINATION_ADDR)  
....................         gError = ERR_WRONG_DESTINATION;  
0A1A:  MOVF   32,W
0A1C:  SUBLW  2D
0A1E:  BTFSC  FD8.2
0A20:  GOTO   0A28
0A24:  MOVLW  80
0A26:  MOVWF  1A
....................     if (gHostBuf[IDX_HOST_BYTE_COUNT] > 10 && !IsCmdCAN(gHostBuf[IDX_HOST_COMMAND]) &&  
....................     	!IsCmdLocal(gHostBuf[IDX_HOST_COMMAND]))  
....................         gError = ERR_BYTE_COUNT_TOO_LARGE;  
0A28:  MOVF   34,W
0A2A:  SUBLW  0A
0A2C:  BTFSC  FD8.0
0A2E:  GOTO   0A62
0A32:  CLRF   15
0A34:  BTFSC  FF2.7
0A36:  BSF    15.7
0A38:  BCF    FF2.7
0A3A:  MOVFF  33,278
0A3E:  CALL   01CE
0A42:  BTFSC  15.7
0A44:  BSF    FF2.7
0A46:  MOVF   01,F
0A48:  BTFSS  FD8.2
0A4A:  GOTO   0A62
0A4E:  MOVFF  33,210
0A52:  CALL   0944
0A56:  MOVF   01,F
0A58:  BTFSS  FD8.2
0A5A:  GOTO   0A62
0A5E:  MOVLW  81
0A60:  MOVWF  1A
....................     if (gHostBuf[IDX_HOST_CHECKSUM] != checksum(gHostBuf+1, HOST_RECV_MSG_SIZE-2))  
....................         gError = ERR_BAD_CHECKSUM;  
0A62:  MOVLB  2
0A64:  CLRF   x40
0A66:  MOVLW  33
0A68:  MOVWF  x3F
0A6A:  MOVLW  0D
0A6C:  MOVWF  x41
0A6E:  MOVLB  0
0A70:  CALL   09CC
0A74:  MOVF   01,W
0A76:  SUBWF  40,W
0A78:  BTFSC  FD8.2
0A7A:  GOTO   0A82
0A7E:  MOVLW  02
0A80:  MOVWF  1A
.................... }  
0A82:  GOTO   3A5A (RETURN)
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: HostSendVehicleData  
.................... // Description: Send a vehilce data message to the host. The message(s) to send   
.................... //	is contained  within global arrays. Messages must be sent to host in the   
.................... //	order they were received from the vehicle.  
.................... // Parameters:   
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void HostSendVehicleData()  
.................... {  
....................     int8 charCnt;  
....................     int8 msgCnt = 0;  
*
36E0:  MOVLB  2
36E2:  CLRF   x11
....................   
....................     // send the data out the ISO RS-232 port  
....................     while (msgCnt < gVehicleBufCnt)  
....................     {  
36E4:  MOVF   21,W
36E6:  SUBWF  x11,W
36E8:  BTFSC  FD8.0
36EA:  GOTO   3814
....................         // zero all buffer bytes  
....................         //memset(gHostBuf, 0x00, HOST_SEND_MSG_SIZE-1);  
....................   
....................         // add destination  
....................         gHostBuf[IDX_VEHICLE_DESTINATION] = DESTINATION_ADDR;  
36EE:  MOVLW  2D
36F0:  MOVWF  32
....................   
....................         // add command  
....................         if (gFlags.comType == MODE_ISO)  
....................             gHostBuf[IDX_VEHICLE_COMMAND] = CMD_ISO_MSG;  
36F2:  MOVF   18,W
36F4:  ANDLW  07
36F6:  XORLW  00
36F8:  BTFSS  FD8.2
36FA:  GOTO   3706
36FE:  MOVLW  81
3700:  MOVWF  33
....................         else if (gFlags.comType == MODE_VPW)  
3702:  GOTO   3752
....................             gHostBuf[IDX_VEHICLE_COMMAND] = CMD_VPW_MSG;  
3706:  MOVF   18,W
3708:  ANDLW  07
370A:  SUBLW  01
370C:  BTFSS  FD8.2
370E:  GOTO   371A
3712:  MOVLW  82
3714:  MOVWF  33
....................         else if (gFlags.comType == MODE_PWM)  
3716:  GOTO   3752
....................             gHostBuf[IDX_VEHICLE_COMMAND] = CMD_PWM_MSG;  
371A:  MOVF   18,W
371C:  ANDLW  07
371E:  SUBLW  02
3720:  BTFSS  FD8.2
3722:  GOTO   372E
3726:  MOVLW  84
3728:  MOVWF  33
....................         else if (gFlags.comType == MODE_KWP)  
372A:  GOTO   3752
....................             gHostBuf[IDX_VEHICLE_COMMAND] = CMD_KWP_MSG;  
372E:  MOVF   18,W
3730:  ANDLW  07
3732:  SUBLW  03
3734:  BTFSS  FD8.2
3736:  GOTO   3742
373A:  MOVLW  01
373C:  MOVWF  33
.................... 		else if (gFlags.comType == MODE_CAN)  
373E:  GOTO   3752
....................             gHostBuf[IDX_VEHICLE_COMMAND] = CMD_CAN_MSG;  
3742:  MOVF   18,W
3744:  ANDLW  07
3746:  SUBLW  04
3748:  BTFSS  FD8.2
374A:  GOTO   3752
374E:  MOVLW  88
3750:  MOVWF  33
....................    
....................         // add 11-bytes of response  
....................         for (charCnt=0; charCnt<VEHICLE_MSG_SIZE-1; charCnt++)  
3752:  CLRF   x10
3754:  MOVF   x10,W
3756:  SUBLW  0A
3758:  BTFSS  FD8.0
375A:  GOTO   37C6
....................             gHostBuf[charCnt+2] = gVehicleBuf[msgCnt][charCnt];  
375E:  MOVLW  02
3760:  ADDWF  x10,W
3762:  CLRF   03
3764:  ADDLW  32
3766:  MOVWF  01
3768:  MOVLW  00
376A:  ADDWFC 03,F
376C:  MOVF   01,W
376E:  MOVWF  x13
3770:  MOVLB  0
3772:  MOVFF  03,214
3776:  MOVLB  2
3778:  CLRF   x43
377A:  MOVLB  0
377C:  MOVFF  211,242
3780:  MOVLB  2
3782:  CLRF   x45
3784:  MOVLW  0C
3786:  MOVWF  x44
3788:  MOVLB  0
378A:  CALL   0EC6
378E:  MOVFF  01,215
3792:  MOVLB  2
3794:  MOVF   x10,W
3796:  ADDWF  01,W
3798:  MOVWF  01
379A:  MOVLW  00
379C:  ADDWFC 02,W
379E:  MOVWF  03
37A0:  MOVF   01,W
37A2:  ADDLW  41
37A4:  MOVWF  FE9
37A6:  MOVLW  00
37A8:  ADDWFC 03,W
37AA:  MOVWF  FEA
37AC:  MOVF   FEF,W
37AE:  MOVWF  x17
37B0:  MOVLB  0
37B2:  MOVFF  214,FEA
37B6:  MOVFF  213,FE9
37BA:  MOVFF  217,FEF
37BE:  MOVLB  2
37C0:  INCF   x10,F
37C2:  GOTO   3754
....................   
....................         // add checksum (don't count first byte in checksum)  
....................         gHostBuf[IDX_VEHICLE_CHECKSUM] = checksum(&gHostBuf[1], HOST_SEND_MSG_SIZE-2);  
37C6:  CLRF   x40
37C8:  MOVLW  33
37CA:  MOVWF  x3F
37CC:  MOVLW  0C
37CE:  MOVWF  x41
37D0:  MOVLB  0
37D2:  CALL   09CC
37D6:  MOVFF  01,3F
....................           
....................         // send message to host  
....................         for (charCnt=0; charCnt<HOST_SEND_MSG_SIZE; charCnt++)  
37DA:  MOVLB  2
37DC:  CLRF   x10
37DE:  MOVF   x10,W
37E0:  SUBLW  0D
37E2:  BTFSS  FD8.0
37E4:  GOTO   380E
.................... 	        fputc(gHostBuf[charCnt], STREAM_HOST);   
37E8:  CLRF   03
37EA:  MOVF   x10,W
37EC:  ADDLW  32
37EE:  MOVWF  FE9
37F0:  MOVLW  00
37F2:  ADDWFC 03,W
37F4:  MOVWF  FEA
37F6:  MOVLB  0
37F8:  MOVFF  FEF,212
37FC:  MOVLB  2
37FE:  MOVF   x12,W
3800:  BTFSS  F9E.4
3802:  GOTO   3800
3806:  MOVWF  FAD
3808:  INCF   x10,F
380A:  GOTO   37DE
....................   
....................         msgCnt++;      
380E:  INCF   x11,F
....................     }  
3810:  GOTO   36E4
....................       
....................     // all messages sent  
....................     gVehicleBufCnt = 0;  
3814:  CLRF   21
.................... }  
3816:  MOVLB  0
3818:  GOTO   3A8E (RETURN)
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: HostSendLocalData  
.................... // Description: Send a message to the host that doesn't require vehicle   
.................... //	communication (e.g. A/D battery reading). The message to send is contained   
.................... //  within gVehicleBuf[0] up to 10 bytes of information.  
.................... // Parameters:   
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void HostSendLocalData()  
.................... {  
....................     int8 charCnt;  
....................   
....................     // zero all buffer bytes  
....................     //memset(gHostBuf, 0x00, HOST_SEND_MSG_SIZE-1);  
....................   
....................     // add bytes  
....................     gHostBuf[IDX_VEHICLE_DESTINATION] = DESTINATION_ADDR;  
381C:  MOVLW  2D
381E:  MOVWF  32
....................     gHostBuf[IDX_VEHICLE_COMMAND] = CMD_LOCAL_DATA;  
3820:  MOVLW  40
3822:  MOVWF  33
....................     gHostBuf[IDX_HOST_BYTE_COUNT] = gCurrentCmd;  
3824:  MOVFF  22,34
....................   
....................     // add up to 10-bytes of response bytes from vehicle buffer 0  
....................     for (charCnt=0; charCnt<VEHICLE_MSG_SIZE-2; charCnt++)  
3828:  MOVLB  2
382A:  CLRF   x10
382C:  MOVF   x10,W
382E:  SUBLW  09
3830:  BTFSS  FD8.0
3832:  GOTO   3872
....................         gHostBuf[charCnt+3] = gVehicleBuf[0][charCnt];  
3836:  MOVLW  03
3838:  ADDWF  x10,W
383A:  CLRF   03
383C:  ADDLW  32
383E:  MOVWF  01
3840:  MOVLW  00
3842:  ADDWFC 03,F
3844:  MOVF   01,W
3846:  MOVWF  x12
3848:  MOVLB  0
384A:  MOVLW  41
384C:  MOVLB  2
384E:  ADDWF  x10,W
3850:  MOVWF  FE9
3852:  CLRF   FEA
3854:  BTFSC  FD8.0
3856:  INCF   FEA,F
3858:  MOVF   FEF,W
385A:  MOVWF  x14
385C:  MOVLB  0
385E:  MOVFF  03,FEA
3862:  MOVFF  212,FE9
3866:  MOVFF  214,FEF
386A:  MOVLB  2
386C:  INCF   x10,F
386E:  GOTO   382C
....................   
....................     // add checksum (don't count first byte in checksum)  
....................     gHostBuf[IDX_VEHICLE_CHECKSUM] = checksum(&gHostBuf[1], HOST_SEND_MSG_SIZE-2);  
3872:  CLRF   x40
3874:  MOVLW  33
3876:  MOVWF  x3F
3878:  MOVLW  0C
387A:  MOVWF  x41
387C:  MOVLB  0
387E:  CALL   09CC
3882:  MOVFF  01,3F
....................               
....................     // send local data message to host  
....................     for (charCnt=0; charCnt<HOST_SEND_MSG_SIZE; charCnt++)  
3886:  MOVLB  2
3888:  CLRF   x10
388A:  MOVF   x10,W
388C:  SUBLW  0D
388E:  BTFSS  FD8.0
3890:  GOTO   38BA
....................         fputc(gHostBuf[charCnt], STREAM_HOST);  
3894:  CLRF   03
3896:  MOVF   x10,W
3898:  ADDLW  32
389A:  MOVWF  FE9
389C:  MOVLW  00
389E:  ADDWFC 03,W
38A0:  MOVWF  FEA
38A2:  MOVLB  0
38A4:  MOVFF  FEF,211
38A8:  MOVLB  2
38AA:  MOVF   x11,W
38AC:  BTFSS  F9E.4
38AE:  GOTO   38AC
38B2:  MOVWF  FAD
38B4:  INCF   x10,F
38B6:  GOTO   388A
.................... }  
38BA:  MOVLB  0
38BC:  GOTO   3A96 (RETURN)
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: HostSendError  
.................... // Description: Sends an error message to the host. Checks the global error   
.................... //  byte set by some other part of the system.  
.................... // Parameters:   
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void HostSendError()  
.................... {  
....................     int8 charCnt;  
....................   
....................     // zero all buffer bytes  
....................     //memset(gHostBuf, 0x00, HOST_SEND_MSG_SIZE-1);  
....................   
....................     // add bytes  
....................     gHostBuf[IDX_VEHICLE_DESTINATION] = DESTINATION_ADDR;  
*
3668:  MOVLW  2D
366A:  MOVWF  32
....................     gHostBuf[IDX_VEHICLE_COMMAND] = CMD_ERROR;  
366C:  MOVLW  80
366E:  MOVWF  33
....................     gHostBuf[2] = 0xFF;         // ME software rev byte, make FF  
3670:  MOVLW  FF
3672:  MOVWF  34
....................     gHostBuf[3] = gError;  
3674:  MOVFF  1A,35
....................     gHostBuf[4] = CAP_INTERFACE;  
3678:  MOVLW  5F
367A:  MOVWF  36
....................     gHostBuf[5] = SOFTWARE_REV; // Auterra software rev byte  
367C:  MOVLW  08
367E:  MOVWF  37
.................... 	gHostBuf[6] = gErrorExtraData1;   // extra data, if any  
3680:  MOVFF  1B,38
.................... 	gHostBuf[7] = gErrorExtraData2;  
3684:  MOVFF  1C,39
.................... 	gHostBuf[8] = gErrorExtraData3;  
3688:  MOVFF  1D,3A
....................   
....................     // add checksum (don't count first byte in checksum)  
....................     gHostBuf[IDX_VEHICLE_CHECKSUM] = checksum(&gHostBuf[1], HOST_SEND_MSG_SIZE-2);  
368C:  MOVLB  2
368E:  CLRF   x40
3690:  MOVLW  33
3692:  MOVWF  x3F
3694:  MOVLW  0C
3696:  MOVWF  x41
3698:  MOVLB  0
369A:  CALL   09CC
369E:  MOVFF  01,3F
....................               
....................     // send error message to host  
....................     for (charCnt=0; charCnt<HOST_SEND_MSG_SIZE; charCnt++)  
36A2:  MOVLB  2
36A4:  CLRF   x10
36A6:  MOVF   x10,W
36A8:  SUBLW  0D
36AA:  BTFSS  FD8.0
36AC:  GOTO   36D6
....................         fputc(gHostBuf[charCnt], STREAM_HOST);  
36B0:  CLRF   03
36B2:  MOVF   x10,W
36B4:  ADDLW  32
36B6:  MOVWF  FE9
36B8:  MOVLW  00
36BA:  ADDWFC 03,W
36BC:  MOVWF  FEA
36BE:  MOVLB  0
36C0:  MOVFF  FEF,211
36C4:  MOVLB  2
36C6:  MOVF   x11,W
36C8:  BTFSS  F9E.4
36CA:  GOTO   36C8
36CE:  MOVWF  FAD
36D0:  INCF   x10,F
36D2:  GOTO   36A6
....................   
....................     // sent error so no vehicle buffers to send  
....................     gVehicleBufCnt = 0;   
36D6:  CLRF   21
....................     gError = ERR_NONE;  
36D8:  CLRF   1A
.................... }  
36DA:  MOVLB  0
36DC:  GOTO   3A76 (RETURN)
....................   
.................... #ifdef BLUETOOTH  
.................... //------------------------------------------------------------------------------  
.................... // Function Name: SendHost  
.................... // Description:   
.................... // Parameters:   
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void HostSend(int8* bufToSend, int8 size)  
.................... {  
.................... 	int8 charCnt;  
.................... 	for (charCnt=0; charCnt<size; charCnt++)  
*
0820:  MOVLB  2
0822:  CLRF   x14
0824:  MOVF   x13,W
0826:  SUBWF  x14,W
0828:  BTFSC  FD8.0
082A:  GOTO   0860
.................... 	{  
....................         fputc(bufToSend[charCnt], STREAM_HOST);  
082E:  CLRF   03
0830:  MOVF   x14,W
0832:  ADDWF  x11,W
0834:  MOVWF  FE9
0836:  MOVF   x12,W
0838:  ADDWFC 03,W
083A:  MOVWF  FEA
083C:  MOVLB  0
083E:  MOVFF  FEF,215
0842:  MOVLB  2
0844:  MOVF   x15,W
0846:  BTFSS  F9E.4
0848:  GOTO   0846
084C:  MOVWF  FAD
....................         delay_ms(20);  
084E:  MOVLW  14
0850:  MOVWF  x3C
0852:  MOVLB  0
0854:  CALL   07F4
....................     }  
0858:  MOVLB  2
085A:  INCF   x14,F
085C:  GOTO   0824
.................... }  
0860:  MOVLB  0
0862:  RETLW  00
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: HostInitBluetooth  
.................... // Description:   
.................... // Parameters:   
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void HostInitBluetooth()  
.................... {  
.................... 	// If the EEPROM sector 30 first byte is 0xFF then auto pair the adapter to the  
.................... 	// Windows PC for manufacturing ease. Otherwise, don't auto pair for shipment to  
.................... 	// the customer. The AdapterTest windows software writes a non-FF value after  
.................... 	// successfully completing the test.  
.................... 	int8 autoPair;  
.................... 	autoPair = read_eeprom(30 * EEPROM_SECTOR_SIZE);  
0864:  MOVFF  FF2,211
0868:  BCF    FF2.7
086A:  CLRF   FAA
086C:  MOVLW  F0
086E:  MOVWF  FA9
0870:  BCF    FA6.6
0872:  BCF    FA6.7
0874:  BSF    FA6.0
0876:  MOVF   FA8,W
0878:  MOVLB  2
087A:  BTFSC  x11.7
087C:  BSF    FF2.7
087E:  MOVWF  x10
.................... 	if (autoPair != 0xFF)  
.................... 		return;  
0880:  INCFSZ x10,W
0882:  GOTO   088A
0886:  GOTO   088E
088A:  GOTO   093E
.................... 	  
.................... 	delay_ms(1000);  
088E:  MOVLW  04
0890:  MOVWF  x11
0892:  MOVLW  FA
0894:  MOVWF  x3C
0896:  MOVLB  0
0898:  CALL   07F4
089C:  MOVLB  2
089E:  DECFSZ x11,F
08A0:  BRA    0892
.................... 	  
.................... 	// Get the RN42 Bluetooth module into command mode  
.................... 	gHostBuf[0] = '$';  
08A2:  MOVLW  24
08A4:  MOVWF  32
.................... 	gHostBuf[1] = '$';  
08A6:  MOVWF  33
.................... 	gHostBuf[2] = '$';	  
08A8:  MOVWF  34
....................     HostSend(&gHostBuf[0], 3);  
08AA:  CLRF   x12
08AC:  MOVLW  32
08AE:  MOVWF  x11
08B0:  MOVLW  03
08B2:  MOVWF  x13
08B4:  MOVLB  0
08B6:  CALL   0820
....................       
.................... 	delay_ms(50);  
08BA:  MOVLW  32
08BC:  MOVLB  2
08BE:  MOVWF  x3C
08C0:  MOVLB  0
08C2:  CALL   07F4
.................... 	  
.................... 	// Send RN42 command and Bluetooth address to auto-pair  
.................... 	gHostBuf[0] = 'C';	  
08C6:  MOVLW  43
08C8:  MOVWF  32
.................... 	gHostBuf[1] = ',';	  
08CA:  MOVLW  2C
08CC:  MOVWF  33
.................... 	gHostBuf[2] = '0';  
08CE:  MOVLW  30
08D0:  MOVWF  34
.................... 	gHostBuf[3] = '0';  
08D2:  MOVWF  35
.................... 	gHostBuf[4] = '0';  
08D4:  MOVWF  36
.................... 	gHostBuf[5] = '2';  
08D6:  MOVLW  32
08D8:  MOVWF  37
.................... 	gHostBuf[6] = '7';  
08DA:  MOVLW  37
08DC:  MOVWF  38
.................... 	gHostBuf[7] = '2';  
08DE:  MOVLW  32
08E0:  MOVWF  39
.................... 	gHostBuf[8] = '3';  
08E2:  MOVLW  33
08E4:  MOVWF  3A
.................... 	gHostBuf[9] = '3';  
08E6:  MOVWF  3B
.................... 	gHostBuf[10] = '3';  
08E8:  MOVWF  3C
.................... 	gHostBuf[11] = 'C';  
08EA:  MOVLW  43
08EC:  MOVWF  3D
.................... 	gHostBuf[12] = '6';  
08EE:  MOVLW  36
08F0:  MOVWF  3E
.................... 	gHostBuf[13] = 'D';  
08F2:  MOVLW  44
08F4:  MOVWF  3F
.................... 	HostSend(&gHostBuf[0], 14);  
08F6:  MOVLB  2
08F8:  CLRF   x12
08FA:  MOVLW  32
08FC:  MOVWF  x11
08FE:  MOVLW  0E
0900:  MOVWF  x13
0902:  MOVLB  0
0904:  CALL   0820
.................... 	  
.................... 	// This was to read the Bluetooth address from sector 0 EEPROM, didn't work  
.................... 	// so for now the address is hard coded  
.................... /*	gHostBuf[0] = 'C';	  
.................... 	gHostBuf[1] = ',';	  
.................... 	HostSend(&gHostBuf[0], 2);  
.................... 	  
.................... 	ReadEepromLocal(0);  
.................... 	HostSend(&gVehicleBuf[0][2], 8);  
.................... 	  
.................... 	ReadEepromLocal(1);  
.................... 	HostSend(&gVehicleBuf[0][2], 4);*/  
.................... 	  
.................... 	delay_ms(3000);  
0908:  MOVLW  0C
090A:  MOVLB  2
090C:  MOVWF  x11
090E:  MOVLW  FA
0910:  MOVWF  x3C
0912:  MOVLB  0
0914:  CALL   07F4
0918:  MOVLB  2
091A:  DECFSZ x11,F
091C:  BRA    090E
.................... 	  
.................... 	// Get the RN42 Bluetooth out of command mode  
.................... 	//memcpy(gHostBuf, "---\r", 4);  
.................... 	gHostBuf[0] = '-';  
091E:  MOVLW  2D
0920:  MOVWF  32
.................... 	gHostBuf[1] = '-';  
0922:  MOVWF  33
.................... 	gHostBuf[2] = '-';  
0924:  MOVWF  34
.................... 	gHostBuf[3] = '\r';  
0926:  MOVLW  0D
0928:  MOVWF  35
....................     HostSend(&gHostBuf[0], 4);  
092A:  CLRF   x12
092C:  MOVLW  32
092E:  MOVWF  x11
0930:  MOVLW  04
0932:  MOVWF  x13
0934:  MOVLB  0
0936:  CALL   0820
.................... 	  
.................... 	gHostBufCnt = 0;  
093A:  CLRF   1E
093C:  MOVLB  2
.................... }  
093E:  MOVLB  0
0940:  GOTO   3A48 (RETURN)
....................   
.................... #endif  
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: HostUartISR  
.................... // Description: Interrupt function to handling incoming bytes from the host.   
.................... //  Put the bytes into a global array to be picked up by the main loop.   
.................... // Parameters:   
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... #int_rda  
.................... void HostUartISR()  
.................... {  
.................... 	int8 junk;  
....................   
.................... 	// if UART error occurred  
.................... 	if (bit_test(RCSTA, OERR))  
.................... 	{  
*
00C4:  BTFSS  FAB.1
00C6:  GOTO   00D2
....................         // per Microchip spec, clear CREN to clear OERR error  
....................         bit_clear(RCSTA, CREN);	 // disable UART  
00CA:  BCF    FAB.4
....................         bit_set(RCSTA, CREN);	 // re-enable UART  
00CC:  BSF    FAB.4
....................         return;  
00CE:  GOTO   0122
....................     }   
....................     if (bit_test(RCSTA, FERR))  
....................     {  
00D2:  BTFSS  FAB.2
00D4:  GOTO   00E0
.................... 		// per Microship spec, read RCREG to clear FERR	and discard byte  
.................... 		junk = RCREG;	   // read and discard byte  
00D8:  MOVFF  FAE,24F
.................... 		return;  
00DC:  GOTO   0122
.................... 	}  
....................   
....................     // don't overrun host buffer  
....................     if (gHostBufCnt < HOST_RECV_MSG_SIZE)  
....................     {  
00E0:  MOVF   1E,W
00E2:  SUBLW  0E
00E4:  BTFSS  FD8.0
00E6:  GOTO   011E
....................         // get byte from UART and place in global array  
....................         gHostBuf[gHostBufCnt] = RCREG; //fgetc(STREAM_HOST);  
00EA:  CLRF   03
00EC:  MOVF   1E,W
00EE:  ADDLW  32
00F0:  MOVWF  FE9
00F2:  MOVLW  00
00F4:  ADDWFC 03,W
00F6:  MOVWF  FEA
00F8:  MOVFF  FAE,FEF
....................   
....................         // if this is the first byte it must be the destination addr  
....................         // this helps get the scan tool re-sync'ed with host  
....................         if (gHostBuf[0] == DESTINATION_ADDR)  
....................             gHostBufCnt++;  
00FC:  MOVF   32,W
00FE:  SUBLW  2D
0100:  BTFSS  FD8.2
0102:  GOTO   010C
0106:  INCF   1E,F
.................... 		else  
.................... 			gHostBufCnt = 0;    
0108:  GOTO   010E
010C:  CLRF   1E
....................   
....................         // keep reseting timer while chars coming in  
....................         gHostRecvTimeout = HstGetTicks();  
010E:  CALL   00B6
0112:  MOVFF  02,20
0116:  MOVFF  01,1F
....................     }  
....................     else  
....................         // eat char from port to stop UART interrupt from firing  
....................         junk = RCREG; //fgetc(STREAM_HOST);  
011A:  GOTO   0122
011E:  MOVFF  FAE,24F
....................   
.................... }  
....................   
....................   
....................   
....................  
.................... #include "CAN.c" 
....................  //------------------------------------------------------------------------------  
.................... // File: CAN  
.................... //  
.................... // Purpose: CAN communication and parsing routines.   
.................... //  
.................... // Change History:  
.................... // Date		Author		Description  
.................... //          Lafreniere	Created  
.................... //------------------------------------------------------------------------------  
.................... #include "CAN.h" 
....................  //------------------------------------------------------------------------------  
.................... // File: CAN  
.................... //  
.................... // Purpose: CAN communication and parsing routines.   
.................... //  
.................... // Change History:  
.................... // Date		Author		Description  
.................... //          Lafreniere	Created  
.................... //------------------------------------------------------------------------------  
.................... #ifndef CAN_H  
.................... #define CAN_H  
....................   
.................... void VehSendCAN();  
.................... void VehRecvCAN();  
.................... void CanEmptyRxBuffer();  
.................... void CanSetMaskFilter();  
.................... void CanSetP2CanTimeout();  
.................... void CanDisable();  
....................   
.................... #endif 
.................... #include <stdlib.h> 
....................  ///////////////////////////////////////////////////////////////////////////  
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////  
.................... //// This source code may only be used by licensed users of the CCS C  ////  
.................... //// compiler.  This source code may only be distributed to other      ////  
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////  
.................... //// or distribution is permitted without written permission.          ////  
.................... //// Derivative programs created using this software in object code    ////  
.................... //// form are not restricted in any way.                               ////  
.................... ///////////////////////////////////////////////////////////////////////////  
....................   
.................... #ifndef _STDLIB  
.................... #define _STDLIB  
....................   
.................... //---------------------------------------------------------------------------  
.................... // Definitions and types  
.................... //---------------------------------------------------------------------------  
....................   
.................... #ifndef RAND_MAX  
.................... #define RAND_MAX  32767    // The value of which is the maximum value  
....................                            // ... returned by the rand function  
.................... #endif  
....................   
0122:  BCF    F9E.5
0124:  GOTO   007C
.................... typedef struct {  
....................    signed int quot;  
....................    signed int rem;  
.................... } div_t;  
....................   
.................... typedef struct {  
....................    signed long quot;  
....................    signed long rem;  
.................... } ldiv_t;  
....................   
.................... #include <stddef.h> 
....................  ///////////////////////////////////////////////////////////////////////////  
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////  
.................... //// This source code may only be used by licensed users of the CCS C  ////  
.................... //// compiler.  This source code may only be distributed to other      ////  
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////  
.................... //// or distribution is permitted without written permission.          ////  
.................... //// Derivative programs created using this software in object code    ////  
.................... //// form are not restricted in any way.                               ////  
.................... ///////////////////////////////////////////////////////////////////////////  
....................   
.................... #ifndef _STDDEF  
....................   
.................... #define _STDDEF  
....................   
.................... #if sizeof(int *)==1  
.................... #define ptrdiff_t int  
.................... #else  
.................... #define ptrdiff_t long  
.................... #endif  
....................   
.................... #define size_t int  
.................... #define wchar_t char  
.................... #define NULL 0  
....................   
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)  
....................   
.................... #endif  
....................  
....................   
.................... //---------------------------------------------------------------------------  
.................... // String conversion functions  
.................... //---------------------------------------------------------------------------  
....................   
.................... /* Standard template: float atof(char * s)  
....................  * converts the initial portion of the string s to a float.  
....................  * returns the converted value if any, 0 otherwise  
....................  */  
.................... float atof(char * s);  
....................   
.................... /* Standard template: signed int  atoi(char * s)  
....................  * converts the initial portion of the string s to a signed int  
....................  * returns the converted value if any, 0 otherwise  
....................  */  
.................... signed int atoi(char *s);  
....................   
.................... /* Syntax: signed int32  atoi32(char * s)  
....................    converts the initial portion of the string s to a signed int32  
....................    returns the converted value if any, 0 otherwise*/  
.................... signed int32 atoi32(char *s);  
....................   
.................... /* Standard template: signed long  atol(char * s)  
....................  * converts the initial portion of the string s to a signed long  
....................  * returns the converted value if any, 0 otherwise  
....................  */  
.................... signed long atol(char *s);  
....................   
.................... /* Standard template: float strtol(char * s,char *endptr)  
....................  * converts the initial portion of the string s to a float  
....................  * returns the converted value if any, 0 otherwise  
....................  * the final string is returned in the endptr, if endptr is not null  
....................  */  
.................... float strtod(char *s,char *endptr);  
....................   
.................... /* Standard template: long strtoul(char * s,char *endptr,signed int base)  
....................  * converts the initial portion of the string s, represented as an  
....................  * integral value of radix base  to a signed long.  
....................  * Returns the converted value if any, 0 otherwise  
....................  * the final string is returned in the endptr, if endptr is not null  
....................  */  
.................... signed long strtol(char *s,char *endptr,signed int base);  
....................   
.................... /* Standard template: long strtoul(char * s,char *endptr,signed int base)  
....................  * converts the initial portion of the string s, represented as an  
....................  * integral value of radix base to a unsigned long.  
....................  * returns the converted value if any, 0 otherwise  
....................  * the final string is returned in the endptr, if endptr is not null  
....................  */  
.................... long strtoul(char *s,char *endptr,signed int base);  
....................   
.................... //---------------------------------------------------------------------------  
.................... // Pseudo-random sequence generation functions  
.................... //---------------------------------------------------------------------------  
....................   
.................... /* The rand function computes a sequence of pseudo-random integers in  
....................  * the range 0 to RAND_MAX  
....................  *  
....................  * Parameters:  
....................  *       (none)  
....................  *  
....................  * Returns:  
....................  *       The pseudo-random integer  
....................  */  
.................... long rand(void);  
....................   
.................... /* The srand function uses the argument as a seed for a new sequence of  
....................  * pseudo-random numbers to be returned by subsequent calls to rand.  
....................  *  
....................  * Parameters:  
....................  *       [in] seed: The seed value to start from. You might need to pass  
....................  *  
....................  * Returns:  
....................  *       (none)  
....................  *  
....................  * Remarks  
....................  *          The srand function sets the starting point for generating  
....................  *       a series of pseudorandom integers. To reinitialize the  
....................  *       generator, use 1 as the seed argument. Any other value for  
....................  *       seed sets the generator to a random starting point. rand  
....................  *       retrieves the pseudorandom numbers that are generated.  
....................  *       Calling rand before any call to srand generates the same  
....................  *       sequence as calling srand with seed passed as 1.  
....................  *          Usually, you need to pass a time here from outer source  
....................  *       so that the numbers will be different every time you run.  
....................  */  
.................... void srand(unsigned int32 seed);  
....................   
.................... //---------------------------------------------------------------------------  
.................... // Memory management functions  
.................... //---------------------------------------------------------------------------  
....................   
.................... // Comming soon  
....................   
.................... //---------------------------------------------------------------------------  
.................... // Communication with the environment  
.................... //---------------------------------------------------------------------------  
....................   
.................... /* The function returns 0 always  
....................  */  
.................... signed int system(char *string);  
....................   
.................... //---------------------------------------------------------------------------  
.................... // Searching and sorting utilities  
.................... //---------------------------------------------------------------------------  
....................   
.................... /* Performs a binary search of a sorted array..  
....................  *  
....................  * Parameters:  
....................  *       [in] key: Object to search for  
....................  *       [in] base: Pointer to base of search data  
....................  *       [in] num: Number of elements  
....................  *       [in] width: Width of elements  
....................  *       [in] compare: Function that compares two elements  
....................  *  
....................  * Returns:  
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed  
....................  *       to by base. If key is not found, the function returns NULL. If the  
....................  *       array is not in order or contains duplicate records with identical keys,  
....................  *       the result is unpredictable.  
....................  */  
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,  
.................... //              int (*compare)(const void *, const void *));  
....................   
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents  
....................  * of the array are sorted into ascending order according to a comparison  
....................  * function pointed to by compar.  
....................  *  
....................  * Parameters:  
....................  *       [in] base: Pointer to base of search data  
....................  *       [in] num: Number of elements  
....................  *       [in] width: Width of elements  
....................  *       [in] compare: Function that compares two elements  
....................  *  
....................  * Returns:  
....................  *       (none)  
....................  */  
.................... //void *qsort(const void *base, size_t num, size_t width,  
.................... //              int (*compare)(const void *, const void *));  
....................   
.................... //---------------------------------------------------------------------------  
.................... // Integer arithmetic functions  
.................... //---------------------------------------------------------------------------  
....................   
.................... #define labs abs  
....................   
.................... div_t div(signed int numer,signed int denom);  
.................... ldiv_t ldiv(signed long numer,signed long denom);  
....................   
.................... //---------------------------------------------------------------------------  
.................... // Multibyte character functions  
.................... //---------------------------------------------------------------------------  
....................   
.................... // Not supported  
....................   
.................... //---------------------------------------------------------------------------  
.................... // Multibyte string functions  
.................... //---------------------------------------------------------------------------  
....................   
.................... // Not supported  
....................   
....................   
.................... //---------------------------------------------------------------------------  
.................... // Internal implementation  
.................... //---------------------------------------------------------------------------  
....................   
.................... #include <stddef.h> 
....................  ///////////////////////////////////////////////////////////////////////////  
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////  
.................... //// This source code may only be used by licensed users of the CCS C  ////  
.................... //// compiler.  This source code may only be distributed to other      ////  
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////  
.................... //// or distribution is permitted without written permission.          ////  
.................... //// Derivative programs created using this software in object code    ////  
.................... //// form are not restricted in any way.                               ////  
.................... ///////////////////////////////////////////////////////////////////////////  
....................   
.................... #ifndef _STDDEF  
....................   
.................... #define _STDDEF  
....................   
.................... #if sizeof(int *)==1  
.................... #define ptrdiff_t int  
.................... #else  
.................... #define ptrdiff_t long  
.................... #endif  
....................   
.................... #define size_t int  
.................... #define wchar_t char  
.................... #define NULL 0  
....................   
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)  
....................   
.................... #endif  
....................  
.................... #include <string.h> 
....................  ////////////////////////////////////////////////////////////////////////////  
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////  
.................... //// This source code may only be used by licensed users of the CCS C   ////  
.................... //// compiler.  This source code may only be distributed to other       ////  
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////  
.................... //// or distribution is permitted without written permission.           ////  
.................... //// Derivative programs created using this software in object code     ////  
.................... //// form are not restricted in any way.                                ////  
.................... ////////////////////////////////////////////////////////////////////////////  
....................   
.................... #ifndef _STRING  
.................... #define _STRING  
.................... #include <stddef.h> 
....................  ///////////////////////////////////////////////////////////////////////////  
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////  
.................... //// This source code may only be used by licensed users of the CCS C  ////  
.................... //// compiler.  This source code may only be distributed to other      ////  
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////  
.................... //// or distribution is permitted without written permission.          ////  
.................... //// Derivative programs created using this software in object code    ////  
.................... //// form are not restricted in any way.                               ////  
.................... ///////////////////////////////////////////////////////////////////////////  
....................   
.................... #ifndef _STDDEF  
....................   
.................... #define _STDDEF  
....................   
.................... #if sizeof(int *)==1  
.................... #define ptrdiff_t int  
.................... #else  
.................... #define ptrdiff_t long  
.................... #endif  
....................   
.................... #define size_t int  
.................... #define wchar_t char  
.................... #define NULL 0  
....................   
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)  
....................   
.................... #endif  
....................  
.................... #include <ctype.h> 
....................  ////////////////////////////////////////////////////////////////////////////  
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////  
.................... //// This source code may only be used by licensed users of the CCS C   ////  
.................... //// compiler.  This source code may only be distributed to other       ////  
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////  
.................... //// or distribution is permitted without written permission.           ////  
.................... //// Derivative programs created using this software in object code     ////  
.................... //// form are not restricted in any way.                                ////  
.................... ////////////////////////////////////////////////////////////////////////////  
....................   
.................... #ifndef _CTYPE  
.................... #define _CTYPE  
....................   
.................... #define islower(x)  isamoung(x,"abcdefghijklmnopqrstuvwxyz")  
.................... #define isupper(x)  isamoung(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")  
.................... #define isalnum(x)  isamoung(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")  
.................... #define isalpha(x)  isamoung(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")  
.................... #define isdigit(x)  isamoung(x,"0123456789")  
.................... #define isspace(x)  (x==' ')  
.................... #define isxdigit(x) isamoung(x,"0123456789ABCDEFabcdef")  
.................... #define iscntrl(x)  (x<' ')  
.................... #define isprint(x)  (x>=' ')  
.................... #define isgraph(x)  (x>' ')  
.................... #define ispunct(x)  ((x>' ')&&!isalnum(x))  
....................   
.................... #endif  
....................   
....................  
....................   
.................... /*Copying functions*/  
.................... /* standard template:  
....................    void *memmove(void *s1, void *s2, size_t n).  
....................    Copies max of n characters safely (not following ending '\0')  
....................    from s2 in s1; if s2 has less than n characters, appends 0 */  
....................   
.................... char *memmove(void *s1,char *s2,size_t n)  
.................... {  
....................    char *sc1;  
....................    char *sc2;  
....................    sc1=s1;  
....................    sc2=s2;  
....................    if(sc2<sc1 && sc1 <sc2 +n)  
....................       for(sc1+=n,sc2+=n;0<n;--n)  
....................          *--sc1=*--sc2;  
....................    else  
....................       for(;0<n;--n)  
....................          *sc1++=*sc2++;  
....................   return s1;  
....................   }  
.................... /*    Standard template: char *strcpy(char *s1, const char *s2)  
.................... copies the string s2 including the null character to s1*/  
....................   
.................... char *strcpy(char *s1, char *s2)  
.................... {  
....................   char *s;  
....................   
....................   for (s = s1; *s2 != 0; s++, s2++)  
.................... 	  *s = *s2;  
....................   return(s1);  
.................... }  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved?? 
....................    Standard template: char *strcpy(char *s1, const char *s2)  
....................    copies the string s2 including the null character to s1*/  
....................   
.................... char *strcopy(char *s1, char *s2)  
.................... {  
....................   char *s;  
....................   
....................   for (s = s1; *s2 != 0; s++, s2++)  
.................... 	  *s = *s2;  
....................   return(s1);  
.................... }  
....................   
.................... /* standard template:  
....................    char *strncpy(char *s1, const char *s2, size_t n).  
....................    Copies max of n characters (not following ending '\0')  
....................    from s2 in s1; if s2 has less than n characters, appends 0 */  
....................   
.................... char *strncpy(char *s1, char *s2, size_t n)  
.................... {  
....................   char *s;  
....................   
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)  
....................      *s++ = *s2++;  
....................   for (; n > 0; n--)  
....................      *s++ = '\0';  
....................   
....................   return(s1);  
.................... }  
.................... /***********************************************************/  
....................   
.................... /*concatenation functions*/  
.................... /* standard template: char *strcat(char *s1, const char *s2)  
.................... appends s2 to s1*/  
....................   
.................... char *strcat(char *s1, char *s2)  
.................... {  
....................    char *s;  
....................   
....................    for (s = s1; *s != '\0'; s++);  
....................    while ((*s = *s2) != '\0')  
....................    {  
....................        s++;  
....................        s2++;  
....................    }  
....................    return(s1);  
.................... }  
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)  
.................... appends not more than n characters from s2 to s1*/  
....................   
.................... char *strncat(char *s1, char *s2, size_t n)  
.................... {  
....................    char *s;  
....................   
....................    for (s = s1; *s != '\0'; s++);  
....................    while ((*s = *s2) != '\0' && 0< n)  
....................    {  
....................        s++;  
....................        s2++;  
....................        --n;  
....................    }  
....................    *s='\0';  
....................    return(s1);  
.................... }  
....................   
.................... /***********************************************************/  
....................   
.................... /*comparison functions*/  
.................... /* standard template: signed int memcmp(void *s1, void *s2).  
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */  
....................   
.................... signed int memcmp(void * s1,char *s2,size_t n)  
.................... {  
.................... char *su1,su2;  
.................... for(su1=s1,su2=s2;0<n;++su1,++su2,--n)  
.................... {  
....................    if(*su1!=*su2)  
....................       return ((*su1<*su2)??1:+1);  
.................... }  
.................... return 0;  
.................... }  
.................... /* standard template: int strcmp(const char *s1, const char *s2).  
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */  
....................   
.................... signed int strcmp(char *s1, char *s2)  
.................... {  
....................    for (; *s1 == *s2; s1++, s2++)  
....................       if (*s1 == '\0')  
....................          return(0);  
....................    return((*s1 < *s2) ??-1: 1);  
.................... }  
.................... /* standard template: int strcoll(const char *s1, const char *s2).  
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */  
....................   
.................... signed int strcoll(char *s1, char *s2)  
.................... {  
....................    for (; *s1 == *s2; s1++, s2++)  
....................       if (*s1 == '\0')  
....................          return(0);  
....................    return((*s1 < *s2) ??-1: 1);  
.................... }  
....................   
.................... /* standard template:  
....................    int strncmp(const char *s1, const char *s2, size_t n).  
....................    Compares max of n characters (not following 0) from s1 to s2;  
....................    returns same as strcmp */  
....................   
.................... signed int strncmp(char *s1, char *s2, size_t n)  
.................... {  
....................    for (; n > 0; s1++, s2++, n--)  
....................       if (*s1 != *s2)  
....................          return((*s1 <*s2) ??-1: 1);  
....................       else if (*s1 == '\0')  
....................          return(0);  
....................    return(0);  
.................... }  
.................... /* standard template:  
....................    int strxfrm(const char *s1, const char *s2, size_t n).  
....................    transforms maximum of n characters from s2 and places them into s1*/  
.................... size_t strxfrm(char *s1, char *s2, size_t n)  
.................... {  
....................   char *s;  
....................   int n1;  
....................   n1=n;  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)  
....................      *s++ = *s2++;  
....................   for (; n > 0; n--)  
....................      *s++ = '\0';  
....................   
....................   return(n1);  
.................... }  
....................   
....................   
....................   
....................   
....................   
.................... /***********************************************************/  
.................... /*Search functions*/  
.................... /* standard template: void *memchr(const char *s, int c).  
....................    Finds first occurrence of c in n characters of s */  
....................   
.................... char *memchr(void *s,int c,size_t n)  
.................... {  
....................    char uc;  
....................    char *su;  
....................    uc=c;  
....................    for(su=s;0<n;++su,--n)  
....................       if(*su==uc)  
....................       return su;  
....................    return NULL;  
.................... }  
....................   
.................... /* standard template: char *strchr(const char *s, int c).  
....................    Finds first occurrence of c in s */  
....................   
.................... char *strchr(char *s, int c)  
.................... {  
....................    for (; *s != c; s++)  
....................       if (*s == '\0')  
....................          return(0);  
....................    return(s);  
.................... }  
.................... /* standard template:  
....................    size_t strcspn(const char *s1, const char *s2).  
....................    Computes length of max initial segment of s1 that  
....................    consists entirely of characters NOT from s2*/  
....................   
.................... int *strcspn(char *s1, char *s2)  
.................... {  
....................    char *sc1, *sc2;  
....................   
....................    for (sc1 = s1; *sc1 != 0; sc1++)  
....................       for (sc2 = s2; *sc2 != 0; sc2++)  
....................          if (*sc1 == *sc2)  
....................             return(sc1 - s1);  
....................    return(sc1 - s1);  
.................... }  
.................... /* standard template:  
....................    char *strpbrk(const char *s1, const char *s2).  
....................    Locates first occurence of any character from s2 in s1;  
....................    returns s1 if s2 is empty string */  
....................   
.................... char *strpbrk(char *s1, char *s2)  
.................... {  
....................    char *sc1, *sc2;  
....................   
....................    for (sc1 = s1; *sc1 != 0; sc1++)  
....................       for (sc2 = s2; *sc2 != 0; sc2++)  
....................          if (*sc1 == *sc2)  
....................             return(sc1);  
....................    return(0);  
.................... }  
....................   
....................   
.................... /* standard template: char *strrchr(const char *s, int c).  
....................    Finds last occurrence of c in s */  
....................   
.................... char *strrchr(char *s, int c)  
.................... {  
....................    char *p;  
....................   
....................    for (p = 0; ; s++)  
....................    {  
....................       if (*s == c)  
....................          p = s;  
....................       if (*s == '\0')  
....................          return(p);  
....................    }  
.................... }  
.................... /* computes length of max initial segment of s1 consisting  
....................    entirely of characters from s2 */  
....................   
.................... int *strspn(char *s1, char *s2)  
.................... {  
....................    char *sc1, *sc2;  
....................   
....................    for (sc1 = s1; *sc1 != 0; sc1++)  
....................       for (sc2 = s2; ; sc2++)  
.................... 	 if (*sc2 == '\0')  
.................... 	    return(sc1 - s1);  
....................          else if (*sc1 == *sc2)  
....................             break;  
....................    return(sc1 - s1);  
.................... }  
.................... /* standard template:  
....................    char *strstr(const char *s1, const char *s2);  
....................    Locates first occurence of character sequence s2 in s1;  
....................    returns 0 if s2 is empty string */  
....................   
.................... char *strstr(char *s1, char *s2)  
.................... {  
....................    char *sc1, *sc2;  
....................   
....................    if (*s2 == 0)  
....................          return(s1);  
....................    for (; s1 = strchr(s1, *s2); s1++)  
....................    {  
....................       for (sc1 = s1, sc2 = s2; ; sc1++, sc2++)  
....................          if (*sc2 == 0)  
.................... 	    return(s1);  
....................          else if (*sc1 != *sc2)  
....................             break;  
....................    }  
....................    return(0);  
.................... }  
.................... /* standard template: char *strtok(char *s1, const char *s2).  
....................   
....................    Finds next token in s1 delimited by a character from separator  
....................    string s2 (which can be different from call to call).  First call  
....................    starts at beginning of s1 searching for first character NOT  
....................    contained in s2; returns 0 if none is found.  
....................    If one is found, it is the start of first token (return value).  
....................    Function then searches from there for a character contained in s2.  
....................    If none is found, current token extends to end of s1, and subsequent  
....................    searches for a token will return 0.  If one is found, it is  
....................    overwritten by '\0', which terminates current token.  Function saves  
....................    pointer to following character from which next search will start.  
....................    Each subsequent call, with 0 as first argument, starts searching  
....................    from saved pointer */  
....................   
.................... char *strtok(char *s1, char *s2)  
.................... {  
....................    char *beg, *end;  
....................    static char *save;  
*
3910:  CLRF   xC5
3912:  CLRF   xC6
....................   
....................    beg = (s1)??s1: save;  
....................    beg += strspn(beg, s2);  
....................    if (*beg == '\0')  
....................    {  
....................       *save = ' ';  
....................       return(0);  
....................    }  
....................    end = strpbrk(beg, s2);  
....................    if (*end != '\0')  
....................    {  
....................       *end = '\0';  
....................       end++;  
....................    }  
....................    save = end;  
....................    return(beg);  
.................... }  
....................   
.................... /*****************************************************************/  
.................... /*Miscellaneous functions*/  
.................... /* standard template  
.................... maps error number in errnum to an error message string  
.................... Returns: Pointer to string  
.................... */  
.................... #ifdef _ERRNO  
.................... char * strerror(int errnum)  
.................... {  
.................... char s[15];  
.................... switch( errnum)  
.................... {  
.................... case 0:  
....................    strcpy(s,"no errors");  
....................    return s;  
.................... case EDOM :  
....................    strcpy(s,"domain error");  
....................    return s;  
.................... case ERANGE:  
....................    strcpy(s,"range error");  
....................    return s;  
.................... }  
.................... }  
.................... #ENDIF  
.................... /* standard template: size_t strlen(const char *s).  
....................    Computes length of s1 (preceding terminating 0) */  
....................   
.................... int *strlen(char *s)  
.................... {  
....................    char *sc;  
....................   
....................    for (sc = s; *sc != 0; sc++);  
....................    return(sc - s);  
.................... }  
....................   
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).  
....................    Compares s1 to s2 ignoring case (upper vs. lower) */  
....................   
.................... signed int stricmp(char *s1, char *s2)  
.................... {  
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32));  
....................     s1++, s2++)  
....................     if (*s1 == '\0')  
....................        return(0);  
....................  return((*s1 < *s2) ??-1: 1);  
.................... }  
....................   
....................   
.................... /* standard template: char *strlwr(char *s).  
....................    Replaces uppercase letters by lowercase;  
....................    returns pointer to new string s */  
....................   
.................... char *strlwr(char *s)  
.................... {  
....................    char *p;  
....................   
....................    for (p = s; *p != '\0'; p++)  
....................       if (*p >= 'A' && *p <='Z')  
....................          *p += 'a' - 'A';  
....................    return(s);  
.................... }  
....................   
....................   
....................   
....................   
.................... /************************************************************/  
....................   
....................   
....................   
....................   
....................   
....................   
....................   
.................... #endif  
....................  
....................   
.................... div_t div(signed int numer,signed int denom)  
.................... {  
....................    div_t val;  
....................    val.quot = numer / denom;  
....................    val.rem = numer - (denom * val.quot);  
....................    return (val);  
.................... }  
....................   
.................... ldiv_t ldiv(signed long numer,signed long denom)  
.................... {  
....................    ldiv_t val;  
....................    val.quot = numer / denom;  
....................    val.rem = numer - (denom * val.quot);  
....................    return (val);  
.................... }  
....................   
.................... float atof(char * s)  
.................... {  
....................    float pow10 = 1.0;  
....................    float result = 0.0;  
....................    int sign = 0;  
....................    char c;  
....................    int ptr = 0;  
....................   
....................    c = s[ptr++];  
....................   
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') {  
....................       if(c == '-') {  
....................          sign = 1;  
....................          c = s[ptr++];  
....................       }  
....................       if(c == '+')  
....................          c = s[ptr++];  
....................   
....................       while((c >= '0' && c <= '9')) {  
....................          result = 10*result + c - '0';  
....................          c = s[ptr++];  
....................       }  
....................   
....................       if (c == '.') {  
....................          c = s[ptr++];  
....................          while((c >= '0' && c <= '9')) {  
....................              pow10 = pow10*10;  
....................              result += (c - '0')/pow10;  
....................              c = s[ptr++];  
....................          }  
....................       }  
....................   
....................    }  
....................   
....................    if (sign == 1)  
....................       result = -1*result;  
....................    return(result);  
.................... }  
....................   
.................... signed int atoi(char *s)  
.................... {  
....................    signed int result;  
....................    int sign, base, index;  
....................    char c;  
....................   
....................    index = 0;  
....................    sign = 0;  
....................    base = 10;  
....................    result = 0;  
....................   
....................    // Omit all preceeding alpha characters  
....................    if(s)  
....................       c = s[index++];  
....................   
....................    // increase index if either positive or negative sign is detected  
....................    if (c == '-')  
....................    {  
....................       sign = 1;         // Set the sign to negative  
....................       c = s[index++];  
....................    }  
....................    else if (c == '+')  
....................    {  
....................       c = s[index++];  
....................    }  
....................   
....................    if (c >= '0' && c <= '9')  
....................    {  
....................   
....................       // Check for hexa number  
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))  
....................       {  
....................          base = 16;  
....................          index++;  
....................          c = s[index++];  
....................       }  
....................   
....................       // The number is a decimal number  
....................       if (base == 10)  
....................       {  
....................          while (c >= '0' && c <= '9')  
....................          {  
....................             result = 10*result + (c - '0');  
....................             c = s[index++];  
....................          }  
....................       }  
....................       else if (base == 16)    // The number is a hexa number  
....................       {  
....................          while (c = toupper(c), (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))  
....................          {  
....................             if (c >= '0' && c <= '9')  
....................                result = (result << 4) + (c - '0');  
....................             else  
....................                result = (result << 4) + (c - 'A' + 10);  
....................   
....................             c = s[index++];  
....................          }  
....................       }  
....................    }  
....................   
....................    if (sign == 1 && base == 10)  
....................        result = -result;  
....................   
....................    return(result);  
.................... }  
....................   
.................... signed long atol(char *s)  
.................... {  
....................    signed long result;  
....................    int sign, base, index;  
....................    char c;  
....................   
....................    index = 0;  
....................    sign = 0;  
....................    base = 10;  
....................    result = 0;  
....................   
....................    if(s)  
....................       c = s[index++];  
....................   
....................    // increase index if either positive or negative sign is detected  
....................    if (c == '-')  
....................    {  
....................       sign = 1;         // Set the sign to negative  
....................       c = s[index++];  
....................    }  
....................    else if (c == '+')  
....................    {  
....................       c = s[index++];  
....................    }  
....................   
....................    if (c >= '0' && c <= '9')  
....................    {  
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))  
....................       {  
....................          base = 16;  
....................          index++;  
....................          c = s[index++];  
....................       }  
....................   
....................       // The number is a decimal number  
....................       if (base == 10)  
....................       {  
....................          while (c >= '0' && c <= '9')  
....................          {  
....................             result = 10*result + (c - '0');  
....................             c = s[index++];  
....................          }  
....................       }  
....................       else if (base == 16)    // The number is a hexa number  
....................       {  
....................          while (c = toupper(c), (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))  
....................          {  
....................             if (c >= '0' && c <= '9')  
....................                result = (result << 4) + (c - '0');  
....................             else  
....................                result = (result << 4) + (c - 'A' + 10);  
....................   
....................             c = s[index++];  
....................          }  
....................       }  
....................    }  
....................   
....................    if (base == 10 && sign == 1)  
....................       result = -result;  
....................   
....................    return(result);  
.................... }  
....................   
.................... /* A fast routine to multiply by 10  
....................  */  
.................... signed int32 mult_with10(int32 num)  
.................... {  
....................    return ( (num << 1) + (num << 3) );  
.................... }  
....................   
.................... signed int32 atoi32(char *s)  
.................... {  
....................    signed int32 result;  
....................    int sign, base, index;  
....................    char c;  
....................   
....................    index = 0;  
....................    sign = 0;  
....................    base = 10;  
....................    result = 0;  
....................   
....................    if(s)  
....................       c = s[index++];  
....................   
....................    // increase index if either positive or negative sign is detected  
....................    if (c == '-')  
....................    {  
....................       sign = 1;         // Set the sign to negative  
....................       c = s[index++];  
....................    }  
....................    else if (c == '+')  
....................    {  
....................       c = s[index++];  
....................    }  
....................   
....................    if (c >= '0' && c <= '9')  
....................    {  
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))  
....................       {  
....................          base = 16;  
....................          index++;  
....................          c = s[index++];  
....................       }  
....................   
....................       // The number is a decimal number  
....................       if (base == 10)  
....................       {  
....................          while (c >= '0' && c <= '9') {  
....................             result = (result << 1) + (result << 3);  // result *= 10;  
....................             result += (c - '0');  
....................             c = s[index++];  
....................          }  
....................       }  
....................       else if (base == 16)    // The number is a hexa number  
....................       {  
....................          while (c = toupper(c), (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))  
....................          {  
....................             if (c >= '0' && c <= '9')  
....................                result = (result << 4) + (c - '0');  
....................             else  
....................                result = (result << 4) + (c - 'A' + 10);  
....................   
....................             c = s[index++];  
....................          }  
....................       }  
....................    }  
....................   
....................    if (base == 10 && sign == 1)  
....................       result = -result;  
....................   
....................    return(result);  
.................... }  
....................   
.................... float strtod(char *s,char *endptr) {  
....................    float pow10 = 1.0;  
....................    float result = 0.0;  
....................    int sign = 0, point = 0;  
....................    char c;  
....................    int ptr = 0;  
....................   
....................    if(s)  
....................    {  
....................       c=s[ptr++];  
....................    }  
....................   
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') {  
....................       if(c == '-') {  
....................          sign = 1;  
....................          c = s[ptr++];  
....................       }  
....................   
....................       while((c >= '0' && c <= '9') && point == 0) {  
....................          result = 10*result + c - '0';  
....................          c = s[ptr++];  
....................       }  
....................   
....................       if (c == '.') {  
....................          point = 1;  
....................          c = s[ptr++];  
....................       }  
....................   
....................       while((c >= '0' && c <= '9') && point == 1) {  
....................          pow10 = pow10*10;  
....................          result += (c - '0')/pow10;  
....................          c = s[ptr++];  
....................       }  
....................   
....................       if (c == '+') {  
....................          c = s[ptr++];  
....................       }  
....................    }  
....................   
....................    if (sign == 1)  
....................       result = -1*result;  
....................    if(endptr)  
....................    {  
....................       if (ptr) {  
....................          ptr--;  
....................          *((char *)endptr)=s+ptr;  
....................       }  
....................       else  
....................          *((char *)endptr)=s;  
....................    }  
....................   
....................    return(result);  
.................... }  
....................   
.................... long strtoul(char *s,char *endptr,signed int base)  
.................... {  
....................    char *sc,*s1,*s2,*sd;  
....................    unsigned long x=0;  
....................    char sign;  
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";  
....................    for(sc=s;isspace(*sc);++sc);  
....................    sign=*sc=='-'||*sc=='+'??sc++:'+';  
....................    if(sign=='-')  
....................    {  
....................       if (endptr)  
....................       {  
....................         *((char *)endptr)=s;  
....................       }  
....................       return 0;  
....................    }  
....................   
....................    if (base <0 || base ==1|| base >36) // invalid base  
....................    {  
....................       if (endptr)  
....................       {  
....................         *((char *)endptr)=s;  
....................       }  
....................       return 0;  
....................    }  
....................    else if (base)  
....................    {  
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))  
....................          sc+=2;  
....................       if(base==8 && *sc =='0')  
....................          sc+=1;  
....................       if(base==2 && *sc =='0'&&sc[1]=='b')  
....................          sc+=2;  
....................   
....................    }  
....................    else if(*sc!='0') // base is 0, find base  
....................       base=10;  
....................    else if (sc[1]=='x' || sc[1]=='X')  
....................       base =16,sc+=2;  
....................    else if(sc[1]=='b')  
....................       base=2,sc+=2;  
....................    else  
....................       base=8;  
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes  
....................    for(s2=sc;(sd=memchr(digits,tolower(*sc),base))!=0;++sc)  
....................    {  
....................       x=x*base+(int16)(sd-digits);  
....................    }  
....................    if(s1==sc)  
....................    {  
....................       if (endptr)  
....................       {  
....................         *((char *)endptr)=s;  
....................       }  
....................    return 0;  
....................    }  
....................    if (endptr)  
....................         *((char *)endptr)=sc;  
....................    return x;  
.................... }  
....................   
.................... signed long strtol(char *s,char *endptr,signed int base)  
.................... {  
....................    char *sc,*s1,*s2,*sd;  
....................    signed long x=0;  
....................    char sign;  
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";  
....................    for(sc=s;isspace(*sc);++sc);  
....................    sign=*sc=='-'||*sc=='+'??sc++:'+';  
....................    if (base <0 || base ==1|| base >36) // invalid base  
....................    {  
....................       if (endptr)  
....................       {  
....................         *((char *)endptr)=s;  
....................       }  
....................       return 0;  
....................    }  
....................    else if (base)  
....................    {  
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))  
....................          sc+=2;  
....................       if(base==8 && *sc =='0')  
....................          sc+=1;  
....................       if(base==2 && *sc =='0'&&sc[1]=='b')  
....................          sc+=2;  
....................   
....................    }  
....................    else if(*sc!='0') // base is 0, find base  
....................       base=10;  
....................    else if (sc[1]=='x' || sc[1]=='X')  
....................       base =16,sc+=2;  
....................    else if(sc[1]=='b')  
....................       base=2,sc+=2;  
....................    else  
....................       base=8;  
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes  
....................    for(s2=sc;(sd=memchr(digits,tolower(*sc),base))!=0;++sc)  
....................    {  
....................       x=x*base+(int16)(sd-digits);  
....................    }  
....................    if(s1==sc)  
....................    {  
....................       if (endptr)  
....................       {  
....................         *((char *)endptr)=s;  
....................       }  
....................    return 0;  
....................    }  
....................    if(sign=='-')  
....................       x  =-x;  
....................    if (endptr)  
....................         *((char *)endptr)=sc;  
....................    return x;  
.................... }  
....................   
.................... signed int system(char *string)  
.................... {  
....................    return 0;  
.................... }  
....................   
.................... int mblen(char *s,size_t n)  
.................... {  
....................    return strlen(s);  
.................... }  
....................   
.................... int mbtowc(wchar_t *pwc,char *s,size_t n)  
.................... {  
....................    *pwc=*s;  
....................    return 1;  
.................... }  
....................   
.................... int wctomb(char *s,wchar_t wchar)  
.................... {  
....................    *s=wchar;  
....................    return 1;  
.................... }  
....................   
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)  
.................... {  
....................    strncpy(pwcs,s,n);  
....................    return strlen(pwcs);  
.................... }  
....................   
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)  
.................... {  
....................    strncpy(s,pwcs,n);  
....................    return strlen(s);  
.................... }  
....................   
.................... //---------------------------------------------------------------------------  
.................... // The random number implementation  
.................... //---------------------------------------------------------------------------  
....................   
.................... unsigned int32 _Randseed = 1;  
3914:  MOVLW  01
3916:  MOVWF  xC7
3918:  CLRF   xC8
391A:  CLRF   xC9
391C:  CLRF   xCA
....................   
.................... long rand(void)  
.................... {  
....................    _Randseed = _Randseed * 1103515245 + 12345;  
....................    return ((unsigned long)(_Randseed >> 16) % RAND_MAX);  
.................... }  
....................   
.................... void srand(unsigned int32 seed)  
.................... {  
....................    _Randseed = seed;  
.................... }  
....................   
.................... //---------------------------------------------------------------------------  
.................... // Searching and sorting utilities implementation  
.................... //---------------------------------------------------------------------------  
....................   
.................... typedef signed int (*_Cmpfun)(char * p1,char * p2);  
....................   
.................... void qsort(char * qdata, int qitems, int qsize, _Cmpfun cmp) {  
....................    int m,j,i,l;  
....................    short done;  
....................    BYTE t[16];  
....................   
....................    m = qitems/2;  
....................    while( m > 0 ) {  
....................      for(j=0; j<(qitems-m); ++j) {  
....................         i = j;  
....................         do  
....................         {  
....................            done=TRUE;  
....................            l = i+m;  
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {  
....................               memcpy(t, qdata+i*qsize, qsize);  
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);  
....................               memcpy(qdata+l*qsize, t, qsize);  
....................               if(m <= i)  
....................                 i -= m;  
....................                 done = FALSE;  
....................            }  
....................         } while(!done);  
....................      }  
....................      m = m/2;  
....................    }  
.................... }  
....................   
....................   
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)  
.................... {  
....................    char *p, *q;  
....................    size_t n;  
....................    size_t pivot;  
....................    int val;  
....................   
....................    p = base;  
....................    n = num;  
....................   
....................    while (n > 0)  
....................    {  
....................       pivot = n >> 1;  
....................       q = p + width * pivot;  
....................   
....................       val = (*cmp)(key, q);  
....................   
....................       if (val < 0)  
....................          n = pivot;  
....................       else if (val == 0)  
....................          return ((char *)q);  
....................       else {  
....................          p = q + width;  
....................          n -= pivot + 1;  
....................       }  
....................    }  
....................   
....................    return NULL;      // There's no match  
.................... }  
....................   
....................   
.................... #endif  
....................  
....................   
.................... #define SINGLE_FRAME        0x00  
.................... #define FIRST_FRAME         0x10  
.................... #define CONSECUTIVE_FRAME   0x20  
.................... #define FLOW_CONTROL        0x30  
....................   
.................... typedef enum CAN_SEGMENTED_RECV_MODE  
.................... {  
.................... 	RECV_NONE,		// no segmented messages are pending (i.e. no FirstFrame messages rcvd)  
.................... 	RECV_PENDING,	// one or more segmented messages are pending (i.e. waiting on ConsecutiveFrame(s))  
.................... 	RECV_COMPLETE	// all segmented messages are received (i.e. all ConsecutiveFrame(s) rcvd)  
.................... };  
....................   
.................... static signed int16 gFirstFrameDataLength[MAX_ECU];  
391E:  CLRF   xCB
3920:  CLRF   xCC
3922:  CLRF   xCD
3924:  CLRF   xCE
3926:  CLRF   xCF
3928:  CLRF   xD0
392A:  CLRF   xD1
392C:  CLRF   xD2
392E:  CLRF   xD3
3930:  CLRF   xD4
3932:  CLRF   xD5
3934:  CLRF   xD6
3936:  CLRF   xD7
3938:  CLRF   xD8
393A:  CLRF   xD9
393C:  CLRF   xDA
.................... static int32 gFirstFrameIdentifier[MAX_ECU];  
393E:  CLRF   xDB
3940:  CLRF   xDC
3942:  CLRF   xDD
3944:  CLRF   xDE
3946:  CLRF   xDF
3948:  CLRF   xE0
394A:  CLRF   xE1
394C:  CLRF   xE2
394E:  CLRF   xE3
3950:  CLRF   xE4
3952:  CLRF   xE5
3954:  CLRF   xE6
3956:  CLRF   xE7
3958:  CLRF   xE8
395A:  CLRF   xE9
395C:  CLRF   xEA
395E:  CLRF   xEB
3960:  CLRF   xEC
3962:  CLRF   xED
3964:  CLRF   xEE
3966:  CLRF   xEF
3968:  CLRF   xF0
396A:  CLRF   xF1
396C:  CLRF   xF2
396E:  CLRF   xF3
3970:  CLRF   xF4
3972:  CLRF   xF5
3974:  CLRF   xF6
3976:  CLRF   xF7
3978:  CLRF   xF8
397A:  CLRF   xF9
397C:  CLRF   xFA
.................... static int8 gFirstFrameRespondedECUs = 0;  
397E:  CLRF   xFB
....................   
.................... static int32 gIdentifier = 0;  
3980:  CLRF   xFC
3982:  CLRF   xFD
3984:  CLRF   xFE
3986:  CLRF   xFF
.................... static int32 gStdMask 		= 0x000007f8;	  // 11-bit  
3988:  MOVLW  F8
398A:  MOVLB  2
398C:  MOVWF  x00
398E:  MOVLW  07
3990:  MOVWF  x01
3992:  CLRF   x02
3994:  CLRF   x03
.................... static int32 gStdFilter 	= 0x000007e8;	  // 11-bit  
3996:  MOVLW  E8
3998:  MOVWF  x04
399A:  MOVLW  07
399C:  MOVWF  x05
399E:  CLRF   x06
39A0:  CLRF   x07
.................... static int32 gXtdMask		= 0x1fffff00;	  // 29-bit  
39A2:  CLRF   x08
39A4:  MOVLW  FF
39A6:  MOVWF  x09
39A8:  MOVWF  x0A
39AA:  MOVLW  1F
39AC:  MOVWF  x0B
.................... static int32 gXtdFilter		= 0x18daf100;  	  // 29-bit  
39AE:  CLRF   x0C
39B0:  MOVLW  F1
39B2:  MOVWF  x0D
39B4:  MOVLW  DA
39B6:  MOVWF  x0E
39B8:  MOVLW  18
39BA:  MOVWF  x0F
39BC:  BCF    F93.4
39BE:  BSF    F8A.4
....................   
.................... void CanInit();  
.................... void CanClearRxErrors();  
.................... void CanSend(int8* data);  
.................... void CanResetSegmentedRecvStats();  
.................... CAN_SEGMENTED_RECV_MODE CanIsSegmentedRecvComplete();  
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: VehSendCAN  
.................... // Description: Send the vehicle a message using CAN.   
.................... // Parameters:    
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void VehSendCAN()  
.................... {  
.................... 	// only call init when the CAN mode changes	or someone forces  
....................     if (gLastCmd != gCurrentCmd || gFlags.forceInitCAN)  
.................... 	{  
*
277A:  MOVF   22,W
277C:  SUBWF  23,W
277E:  BTFSS  FD8.2
2780:  GOTO   278A
2784:  BTFSS  18.4
2786:  GOTO   2796
.................... 		gFlags.forceInitCAN = FALSE;  
278A:  BCF    18.4
....................         gFlags.canModeChanged = TRUE;  
278C:  BSF    18.5
....................         CanInit();  
278E:  GOTO   2210
.................... 	}  
....................     else  
....................     {  
2792:  GOTO   2798
....................         gFlags.canModeChanged = FALSE;  
2796:  BCF    18.5
....................     }  
.................... 	  
.................... 	// extract host indentifer from host message  
.................... 	gIdentifier = StrToInt32(&gHostBuf[2]);  
2798:  MOVLB  2
279A:  CLRF   x11
279C:  MOVLW  34
279E:  MOVWF  x10
27A0:  MOVLB  0
27A2:  CALL   24A0
27A6:  MOVFF  03,1FF
27AA:  MOVFF  02,1FE
27AE:  MOVFF  01,1FD
27B2:  MOVFF  00,1FC
.................... 	  
.................... 	// send host message to vehicle using CAN, only if not a listen only cmd  
.................... 	if (!IsCmdListen(gCurrentCmd))   
.................... 		CanSend(&gHostBuf[6]);  
27B6:  MOVFF  22,210
27BA:  GOTO   2532
27BE:  MOVF   01,F
27C0:  BTFSS  FD8.2
27C2:  GOTO   27D4
27C6:  MOVLB  2
27C8:  CLRF   x30
27CA:  MOVLW  38
27CC:  MOVWF  x2F
27CE:  MOVLB  0
27D0:  CALL   26FC
.................... }  
27D4:  GOTO   3580 (RETURN)
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: VehRecvCAN  
.................... // Description: Receive a message using CAN.  
.................... //  
.................... //	This routine obtains each FirstFrame message from the ECU(s), if any, and   
.................... //	responds with to the ECU with a FlowControl	message automatically without   
.................... //	intervention from the host. The FirstFrame tells the adapter how many more   
.................... //	bytes to expect	in ConsecutiveFrame(s) to follow. This routine waits for  
.................... //  all the bytes to arrive via ConsecutiveFrame(s) before returning.  
.................... //  
.................... //	All	FirstFrame and SingleFrame from all ECUs must arrive in 50mS. Then the   
.................... //	adapter must wait up to 1S (N_Cr) for reception of the next ConsecutiveFrame.  
.................... //  
.................... //	This routine polls for CAN responses and does not use RX interrupts.  
.................... // Parameters:    
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void VehRecvCAN()  
.................... {  
.................... 	int8 FLOW_CONTROL_MSG[8] = { 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };  
*
28AA:  MOVLW  30
28AC:  MOVLB  2
28AE:  MOVWF  x10
28B0:  CLRF   x11
28B2:  CLRF   x12
28B4:  CLRF   x13
28B6:  CLRF   x14
28B8:  CLRF   x15
28BA:  CLRF   x16
28BC:  CLRF   x17
....................     int16 recvTimeout;		  
....................     int32 totalRecvTimeout;	   // J1979 P2can timeout  
.................... 	int32 totalErrorTimeout;   // ISO 15765-2 N_Cr timeout  
....................     int32 newMessageID;			  
....................     int8 newMessageLen;  
....................     CAN_RX_MSG_FLAGS newMessageFlags;  
.................... 	int8 ecu;  
.................... 	int16 elapsedTime;  
.................... 	int32 firstRespECU;  
....................   
....................     recvTimeout = HstGetTicks();  
28BE:  MOVLB  0
28C0:  CALL   00B6
28C4:  MOVFF  02,219
28C8:  MOVFF  01,218
.................... 	totalRecvTimeout = 0;  
28CC:  MOVLB  2
28CE:  CLRF   x1D
28D0:  CLRF   x1C
28D2:  CLRF   x1B
28D4:  CLRF   x1A
.................... 	totalErrorTimeout = 0;  
28D6:  CLRF   x21
28D8:  CLRF   x20
28DA:  CLRF   x1F
28DC:  CLRF   x1E
.................... 	CanResetSegmentedRecvStats();  
28DE:  MOVLB  0
28E0:  GOTO   2826
....................   
....................     while (1)  
.................... 	{  
.................... 		elapsedTime = (int32)HstElapsedTime(recvTimeout);  
28E4:  MOVFF  219,23B
28E8:  MOVFF  218,23A
28EC:  CALL   1128
28F0:  MOVFF  02,22A
28F4:  MOVFF  01,229
....................         recvTimeout += elapsedTime;  
28F8:  MOVLB  2
28FA:  MOVF   x29,W
28FC:  ADDWF  x18,F
28FE:  MOVF   x2A,W
2900:  ADDWFC x19,F
....................         totalRecvTimeout += elapsedTime;  
2902:  MOVF   x29,W
2904:  ADDWF  x1A,F
2906:  MOVF   x2A,W
2908:  ADDWFC x1B,F
290A:  MOVLW  00
290C:  ADDWFC x1C,F
290E:  ADDWFC x1D,F
....................         totalErrorTimeout += elapsedTime;  
2910:  MOVF   x29,W
2912:  ADDWF  x1E,F
2914:  MOVF   x2A,W
2916:  ADDWFC x1F,F
2918:  MOVLW  00
291A:  ADDWFC x20,F
291C:  ADDWFC x21,F
....................   
.................... 		// if CAN error ISR sets an error while receiving messages then exit  
.................... 		if (gError)    
.................... 			return;  
291E:  MOVF   1A,F
2920:  BTFSC  FD8.2
2922:  GOTO   292E
2926:  GOTO   2E76
....................   
.................... 		// else if timer exceeds P2can and no segmented messages are pending then exit  
....................         else if (totalRecvTimeout > gP2can && CanIsSegmentedRecvComplete() != RECV_PENDING)    
292A:  GOTO   29E8
.................... 			break;  
292E:  MOVLB  1
2930:  MOVF   xC4,W
2932:  MOVLB  2
2934:  SUBWF  x1D,W
2936:  BTFSS  FD8.0
2938:  GOTO   299A
293C:  BTFSS  FD8.2
293E:  GOTO   297C
2942:  MOVLB  1
2944:  MOVF   xC3,W
2946:  MOVLB  2
2948:  SUBWF  x1C,W
294A:  BTFSS  FD8.0
294C:  GOTO   299A
2950:  BTFSS  FD8.2
2952:  GOTO   297C
2956:  MOVLB  1
2958:  MOVF   xC2,W
295A:  MOVLB  2
295C:  SUBWF  x1B,W
295E:  BTFSS  FD8.0
2960:  GOTO   299A
2964:  BTFSS  FD8.2
2966:  GOTO   297C
296A:  MOVF   x1A,W
296C:  MOVLB  1
296E:  SUBWF  xC1,W
2970:  BTFSS  FD8.0
2972:  BRA    297A
2974:  MOVLB  2
2976:  GOTO   299A
297A:  MOVLB  2
297C:  MOVLB  0
297E:  CALL   2834
2982:  DECFSZ 01,W
2984:  GOTO   2990
2988:  MOVLB  2
298A:  GOTO   299A
298E:  MOVLB  0
2990:  GOTO   2E5C
....................   
.................... 		// if time since last message exceeds 1 second (ISO 15765-2 N_Cr) while waiting for a segmented   
.................... 		// message (i.e. ConsecutiveFrame) to arrive then exit  
....................         else if (totalErrorTimeout > HST_ONE_S && CanIsSegmentedRecvComplete() == RECV_PENDING)  
2994:  GOTO   29EA
2998:  MOVLB  2
.................... 			break;  
299A:  MOVF   x21,F
299C:  BTFSS  FD8.2
299E:  GOTO   29D0
29A2:  MOVF   x20,W
29A4:  SUBLW  08
29A6:  BTFSC  FD8.0
29A8:  GOTO   29E8
29AC:  XORLW  FF
29AE:  BTFSS  FD8.2
29B0:  GOTO   29D0
29B4:  MOVF   x1F,W
29B6:  SUBLW  88
29B8:  BTFSC  FD8.0
29BA:  GOTO   29E8
29BE:  XORLW  FF
29C0:  BTFSS  FD8.2
29C2:  GOTO   29D0
29C6:  MOVF   x1E,W
29C8:  SUBLW  68
29CA:  BTFSC  FD8.0
29CC:  GOTO   29E8
29D0:  MOVLB  0
29D2:  CALL   2834
29D6:  DECFSZ 01,W
29D8:  BRA    29DC
29DA:  BRA    29E2
29DC:  MOVLB  2
29DE:  GOTO   29E8
29E2:  GOTO   2E5C
29E6:  MOVLB  2
29E8:  MOVLB  0
....................       
....................         // receive 1 CAN 8-byte message   
....................         if (CANReceiveMessage(&newMessageID, &gVehicleBuf[gVehicleBufCnt][3],   
.................... 	                          &newMessageLen, &newMessageFlags))  
....................         {	  
29EA:  MOVLB  2
29EC:  CLRF   x43
29EE:  MOVLB  0
29F0:  MOVFF  21,242
29F4:  MOVLB  2
29F6:  CLRF   x45
29F8:  MOVLW  0C
29FA:  MOVWF  x44
29FC:  MOVLB  0
29FE:  CALL   0EC6
2A02:  MOVFF  02,230
2A06:  MOVFF  01,22F
2A0A:  MOVLW  03
2A0C:  MOVLB  2
2A0E:  ADDWF  01,W
2A10:  MOVWF  01
2A12:  MOVLW  00
2A14:  ADDWFC 02,W
2A16:  MOVWF  03
2A18:  MOVF   01,W
2A1A:  ADDLW  41
2A1C:  MOVWF  x31
2A1E:  MOVLW  00
2A20:  ADDWFC 03,W
2A22:  MOVWF  x32
2A24:  CLRF   15
2A26:  BTFSC  FF2.7
2A28:  BSF    15.7
2A2A:  BCF    FF2.7
2A2C:  MOVLW  02
2A2E:  MOVWF  x79
2A30:  MOVLW  22
2A32:  MOVWF  x78
2A34:  MOVLB  0
2A36:  MOVFF  232,27B
2A3A:  MOVFF  231,27A
2A3E:  MOVLW  02
2A40:  MOVLB  2
2A42:  MOVWF  x7D
2A44:  MOVLW  26
2A46:  MOVWF  x7C
2A48:  MOVLW  02
2A4A:  MOVWF  x7F
2A4C:  MOVLW  27
2A4E:  MOVWF  x7E
2A50:  MOVLB  0
2A52:  CALL   055A
2A56:  BTFSC  15.7
2A58:  BSF    FF2.7
2A5A:  MOVF   01,F
2A5C:  BTFSC  FD8.2
2A5E:  GOTO   2E58
.................... 			// keep resetting CF error timeout as long as messages are arriving  
.................... 			totalErrorTimeout = 0;  
2A62:  MOVLB  2
2A64:  CLRF   x21
2A66:  CLRF   x20
2A68:  CLRF   x1F
2A6A:  CLRF   x1E
....................   
....................             if (newMessageFlags & CAN_RX_OVERFLOW)  
.................... 		    {  
2A6C:  BTFSS  x27.3
2A6E:  GOTO   2A7E
....................     		    gError = ERR_CAN_RX_OVERFLOW;  
2A72:  MOVLW  16
2A74:  MOVWF  1A
....................     		    return;  
2A76:  GOTO   2E76
.................... 		    }  
.................... 			else if (newMessageLen != 8)  
2A7A:  GOTO   2A88
.................... 			{  
2A7E:  MOVF   x26,W
2A80:  SUBLW  08
2A82:  BTFSC  FD8.2
2A84:  GOTO   2A88
.................... 				// some vehicle's like the Pontiac G6 2005 returns non-8 byte messages (which is a violation of  
.................... 				// the specs. So just ignore if not exactly 8  
.................... 			    //gError = ERR_CAN_RX_MESSAGE_LEN_WRONG;  TBD test  
.................... 				//return;  
.................... 			}  
....................   
.................... 			// save	ID of first ECU to respond  
.................... 			if (gVehicleBufCnt == 0)  
.................... 				firstRespECU = newMessageID;  
2A88:  MOVF   21,F
2A8A:  BTFSS  FD8.2
2A8C:  GOTO   2AA4
2A90:  MOVLB  0
2A92:  MOVFF  225,22E
2A96:  MOVFF  224,22D
2A9A:  MOVFF  223,22C
2A9E:  MOVFF  222,22B
2AA2:  MOVLB  2
.................... 			  
.................... 			// what CAN frame type?? 
.................... 			if ((gVehicleBuf[gVehicleBufCnt][3] & 0xF0) == FIRST_FRAME)  
.................... 			{  
2AA4:  CLRF   x43
2AA6:  MOVLB  0
2AA8:  MOVFF  21,242
2AAC:  MOVLB  2
2AAE:  CLRF   x45
2AB0:  MOVLW  0C
2AB2:  MOVWF  x44
2AB4:  MOVLB  0
2AB6:  CALL   0EC6
2ABA:  MOVFF  02,230
2ABE:  MOVFF  01,22F
2AC2:  MOVLW  03
2AC4:  MOVLB  2
2AC6:  ADDWF  01,W
2AC8:  MOVWF  01
2ACA:  MOVLW  00
2ACC:  ADDWFC 02,W
2ACE:  MOVWF  03
2AD0:  MOVF   01,W
2AD2:  ADDLW  41
2AD4:  MOVWF  FE9
2AD6:  MOVLW  00
2AD8:  ADDWFC 03,W
2ADA:  MOVWF  FEA
2ADC:  MOVF   FEF,W
2ADE:  ANDLW  F0
2AE0:  SUBLW  10
2AE2:  BTFSS  FD8.2
2AE4:  GOTO   2C56
....................     			// if vehicle sends a FirstFrame message, respond with a FlowControl message  
.................... 				// must send within <100mS (ISO 15765-4 N_Br)  
.................... 			    CanSend(FLOW_CONTROL_MSG);  
2AE8:  MOVLW  02
2AEA:  MOVWF  x30
2AEC:  MOVLW  10
2AEE:  MOVWF  x2F
2AF0:  MOVLB  0
2AF2:  CALL   26FC
.................... 			    if (gError != ERR_NONE)  
.................... 				    return;  
2AF6:  MOVF   1A,F
2AF8:  BTFSC  FD8.2
2AFA:  GOTO   2B06
2AFE:  MOVLB  2
2B00:  GOTO   2E76
2B04:  MOVLB  0
....................   
.................... 				// get the data length specifying the total user bytes to receive on segmented msg  
....................                 gFirstFrameDataLength[gFirstFrameRespondedECUs] = (gVehicleBuf[gVehicleBufCnt][3] & 0x0F) << 8;  
2B06:  BCF    FD8.0
2B08:  MOVLB  1
2B0A:  RLCF   xFB,W
2B0C:  CLRF   03
2B0E:  ADDLW  CB
2B10:  MOVWF  01
2B12:  MOVLW  01
2B14:  ADDWFC 03,F
2B16:  MOVF   01,W
2B18:  MOVLB  2
2B1A:  MOVWF  x2F
2B1C:  MOVLB  0
2B1E:  MOVFF  03,230
2B22:  MOVLB  2
2B24:  CLRF   x43
2B26:  MOVLB  0
2B28:  MOVFF  21,242
2B2C:  MOVLB  2
2B2E:  CLRF   x45
2B30:  MOVLW  0C
2B32:  MOVWF  x44
2B34:  MOVLB  0
2B36:  CALL   0EC6
2B3A:  MOVFF  01,231
2B3E:  MOVLW  03
2B40:  MOVLB  2
2B42:  ADDWF  01,W
2B44:  MOVWF  01
2B46:  MOVLW  00
2B48:  ADDWFC 02,W
2B4A:  MOVWF  03
2B4C:  MOVF   01,W
2B4E:  ADDLW  41
2B50:  MOVWF  FE9
2B52:  MOVLW  00
2B54:  ADDWFC 03,W
2B56:  MOVWF  FEA
2B58:  MOVF   FEF,W
2B5A:  ANDLW  0F
2B5C:  MOVLW  00
2B5E:  CLRF   03
2B60:  MOVWF  x35
2B62:  MOVLB  0
2B64:  MOVFF  230,FEA
2B68:  MOVFF  22F,FE9
2B6C:  MOVFF  03,FEC
2B70:  MOVF   FED,F
2B72:  MOVFF  235,FEF
....................                 gFirstFrameDataLength[gFirstFrameRespondedECUs] |= gVehicleBuf[gVehicleBufCnt][4];  
2B76:  BCF    FD8.0
2B78:  MOVLB  1
2B7A:  RLCF   xFB,W
2B7C:  CLRF   03
2B7E:  ADDLW  CB
2B80:  MOVWF  01
2B82:  MOVLW  01
2B84:  ADDWFC 03,F
2B86:  MOVF   01,W
2B88:  MOVLB  2
2B8A:  MOVWF  x2F
2B8C:  MOVLB  0
2B8E:  MOVFF  03,230
2B92:  MOVFF  03,FEA
2B96:  MOVFF  22F,FE9
2B9A:  MOVLB  2
2B9C:  CLRF   x32
2B9E:  MOVLB  0
2BA0:  MOVFF  FEF,231
2BA4:  MOVLB  2
2BA6:  CLRF   x43
2BA8:  MOVLB  0
2BAA:  MOVFF  21,242
2BAE:  MOVLB  2
2BB0:  CLRF   x45
2BB2:  MOVLW  0C
2BB4:  MOVWF  x44
2BB6:  MOVLB  0
2BB8:  CALL   0EC6
2BBC:  MOVFF  01,233
2BC0:  MOVLW  04
2BC2:  MOVLB  2
2BC4:  ADDWF  01,W
2BC6:  MOVWF  01
2BC8:  MOVLW  00
2BCA:  ADDWFC 02,W
2BCC:  MOVWF  03
2BCE:  MOVF   01,W
2BD0:  ADDLW  41
2BD2:  MOVWF  FE9
2BD4:  MOVLW  00
2BD6:  ADDWFC 03,W
2BD8:  MOVWF  FEA
2BDA:  MOVF   FEF,W
2BDC:  IORWF  x31,W
2BDE:  MOVWF  00
2BE0:  MOVF   x32,W
2BE2:  MOVWF  03
2BE4:  MOVF   00,W
2BE6:  MOVWF  x35
2BE8:  MOVLB  0
2BEA:  MOVFF  230,FEA
2BEE:  MOVFF  22F,FE9
2BF2:  MOVFF  03,FEC
2BF6:  MOVF   FED,F
2BF8:  MOVFF  235,FEF
.................... 			    gFirstFrameDataLength[gFirstFrameRespondedECUs] -= 6;     // FirstFrame has 6 user data bytes  
2BFC:  BCF    FD8.0
2BFE:  MOVLB  1
2C00:  RLCF   xFB,W
2C02:  CLRF   03
2C04:  ADDLW  CB
2C06:  MOVWF  FE9
2C08:  MOVLW  01
2C0A:  ADDWFC 03,W
2C0C:  MOVWF  FEA
2C0E:  MOVLW  06
2C10:  SUBWF  FEF,W
2C12:  MOVWF  00
2C14:  MOVLW  00
2C16:  SUBWFB FEC,W
2C18:  MOVWF  03
2C1A:  MOVF   00,W
2C1C:  MOVF   FED,F
2C1E:  MOVWF  FEF
2C20:  MOVLB  0
2C22:  MOVFF  03,FEC
....................             	gFirstFrameIdentifier[gFirstFrameRespondedECUs] = newMessageID;  
2C26:  MOVLB  1
2C28:  MOVF   xFB,W
2C2A:  MULLW  04
2C2C:  MOVF   FF3,W
2C2E:  CLRF   03
2C30:  ADDLW  DB
2C32:  MOVWF  FE9
2C34:  MOVLW  01
2C36:  ADDWFC 03,W
2C38:  MOVWF  FEA
2C3A:  MOVLB  0
2C3C:  MOVFF  222,FEF
2C40:  MOVFF  223,FEC
2C44:  MOVFF  224,FEC
2C48:  MOVFF  225,FEC
.................... 				gFirstFrameRespondedECUs++;  
2C4C:  MOVLB  1
2C4E:  INCF   xFB,F
.................... 			}  
.................... 			else if ((gVehicleBuf[gVehicleBufCnt][3] & 0xF0) == CONSECUTIVE_FRAME)  
2C50:  GOTO   2D2A
2C54:  MOVLB  2
.................... 			{  
2C56:  CLRF   x43
2C58:  MOVLB  0
2C5A:  MOVFF  21,242
2C5E:  MOVLB  2
2C60:  CLRF   x45
2C62:  MOVLW  0C
2C64:  MOVWF  x44
2C66:  MOVLB  0
2C68:  CALL   0EC6
2C6C:  MOVFF  02,230
2C70:  MOVFF  01,22F
2C74:  MOVLW  03
2C76:  MOVLB  2
2C78:  ADDWF  01,W
2C7A:  MOVWF  01
2C7C:  MOVLW  00
2C7E:  ADDWFC 02,W
2C80:  MOVWF  03
2C82:  MOVF   01,W
2C84:  ADDLW  41
2C86:  MOVWF  FE9
2C88:  MOVLW  00
2C8A:  ADDWFC 03,W
2C8C:  MOVWF  FEA
2C8E:  MOVF   FEF,W
2C90:  ANDLW  F0
2C92:  SUBLW  20
2C94:  BTFSS  FD8.2
2C96:  GOTO   2D28
.................... 				// search for received message identifier in list  
.................... 				for (ecu=0; ecu<MAX_ECU; ecu++)  
2C9A:  CLRF   x28
2C9C:  MOVF   x28,W
2C9E:  SUBLW  07
2CA0:  BTFSS  FD8.0
2CA2:  GOTO   2D28
.................... 				{  
.................... 					if (newMessageID == gFirstFrameIdentifier[ecu])  
.................... 					{  
2CA6:  MOVF   x28,W
2CA8:  MULLW  04
2CAA:  MOVF   FF3,W
2CAC:  CLRF   03
2CAE:  ADDLW  DB
2CB0:  MOVWF  FE9
2CB2:  MOVLW  01
2CB4:  ADDWFC 03,W
2CB6:  MOVWF  FEA
2CB8:  MOVLB  0
2CBA:  MOVFF  FEF,00
2CBE:  MOVFF  FEC,01
2CC2:  MOVFF  FEC,02
2CC6:  MOVFF  FEC,03
2CCA:  MOVF   00,W
2CCC:  MOVLB  2
2CCE:  SUBWF  x22,W
2CD0:  BTFSS  FD8.2
2CD2:  GOTO   2D22
2CD6:  MOVF   01,W
2CD8:  SUBWF  x23,W
2CDA:  BTFSS  FD8.2
2CDC:  GOTO   2D22
2CE0:  MOVF   02,W
2CE2:  SUBWF  x24,W
2CE4:  BTFSS  FD8.2
2CE6:  GOTO   2D22
2CEA:  MOVF   03,W
2CEC:  SUBWF  x25,W
2CEE:  BTFSS  FD8.2
2CF0:  GOTO   2D22
.................... 						// found idendifier in list, decrement its remaining byte count  
.................... 			    		gFirstFrameDataLength[ecu] -= 7;     // ConsecutiveFrame has, at most, 7 user data bytes  
2CF4:  BCF    FD8.0
2CF6:  RLCF   x28,W
2CF8:  CLRF   03
2CFA:  ADDLW  CB
2CFC:  MOVWF  FE9
2CFE:  MOVLW  01
2D00:  ADDWFC 03,W
2D02:  MOVWF  FEA
2D04:  MOVLW  07
2D06:  SUBWF  FEF,W
2D08:  MOVWF  00
2D0A:  MOVLW  00
2D0C:  SUBWFB FEC,W
2D0E:  MOVWF  03
2D10:  MOVF   00,W
2D12:  MOVF   FED,F
2D14:  MOVWF  FEF
2D16:  MOVLB  0
2D18:  MOVFF  03,FEC
.................... 						break;  
2D1C:  MOVLB  2
2D1E:  GOTO   2D28
.................... 					}  
.................... 				}  
2D22:  INCF   x28,F
2D24:  GOTO   2C9C
2D28:  MOVLB  1
.................... 			}  
....................   
.................... 			// add three bytes of identifier into host message  
....................             gVehicleBuf[gVehicleBufCnt][0]	= (int8)(newMessageID >> 16);  
2D2A:  MOVLB  2
2D2C:  CLRF   x43
2D2E:  MOVLB  0
2D30:  MOVFF  21,242
2D34:  MOVLB  2
2D36:  CLRF   x45
2D38:  MOVLW  0C
2D3A:  MOVWF  x44
2D3C:  MOVLB  0
2D3E:  CALL   0EC6
2D42:  MOVFF  02,230
2D46:  MOVFF  01,22F
2D4A:  MOVLW  41
2D4C:  MOVLB  2
2D4E:  ADDWF  01,W
2D50:  MOVWF  FE9
2D52:  MOVLW  00
2D54:  ADDWFC 02,W
2D56:  MOVWF  FEA
2D58:  MOVLB  0
2D5A:  CLRF   02
2D5C:  CLRF   03
2D5E:  MOVFF  224,FEF
....................             gVehicleBuf[gVehicleBufCnt][1]	= (int8)(newMessageID >> 8);  
2D62:  MOVLB  2
2D64:  CLRF   x43
2D66:  MOVLB  0
2D68:  MOVFF  21,242
2D6C:  MOVLB  2
2D6E:  CLRF   x45
2D70:  MOVLW  0C
2D72:  MOVWF  x44
2D74:  MOVLB  0
2D76:  CALL   0EC6
2D7A:  MOVFF  02,230
2D7E:  MOVFF  01,22F
2D82:  MOVLW  01
2D84:  MOVLB  2
2D86:  ADDWF  01,W
2D88:  MOVWF  01
2D8A:  MOVLW  00
2D8C:  ADDWFC 02,W
2D8E:  MOVWF  03
2D90:  MOVF   01,W
2D92:  ADDLW  41
2D94:  MOVWF  FE9
2D96:  MOVLW  00
2D98:  ADDWFC 03,W
2D9A:  MOVWF  FEA
2D9C:  MOVLB  0
2D9E:  CLRF   03
2DA0:  MOVFF  223,FEF
....................             gVehicleBuf[gVehicleBufCnt][2]	= (int8)(newMessageID);  
2DA4:  MOVLB  2
2DA6:  CLRF   x43
2DA8:  MOVLB  0
2DAA:  MOVFF  21,242
2DAE:  MOVLB  2
2DB0:  CLRF   x45
2DB2:  MOVLW  0C
2DB4:  MOVWF  x44
2DB6:  MOVLB  0
2DB8:  CALL   0EC6
2DBC:  MOVFF  01,22F
2DC0:  MOVLW  02
2DC2:  MOVLB  2
2DC4:  ADDWF  01,W
2DC6:  MOVWF  01
2DC8:  MOVLW  00
2DCA:  ADDWFC 02,W
2DCC:  MOVWF  03
2DCE:  MOVF   01,W
2DD0:  ADDLW  41
2DD2:  MOVWF  FE9
2DD4:  MOVLW  00
2DD6:  ADDWFC 03,W
2DD8:  MOVWF  FEA
2DDA:  MOVLB  0
2DDC:  MOVFF  222,FEF
....................   
.................... 			// if first response enable and not the 1st ECU, then toss this message by not  
.................... 			// incrementing the gVehicleBufCnt below. Only accumulate messages from the  
.................... 			// 1st ECU when host specifies 1st response cmd	  
.................... 			if (gFlags.firstResp && firstRespECU != newMessageID)  
.................... 				continue;  
2DE0:  BTFSS  18.3
2DE2:  GOTO   2E1A
2DE6:  MOVLB  2
2DE8:  MOVF   x22,W
2DEA:  SUBWF  x2B,W
2DEC:  BTFSS  FD8.2
2DEE:  GOTO   2E14
2DF2:  MOVF   x23,W
2DF4:  SUBWF  x2C,W
2DF6:  BTFSS  FD8.2
2DF8:  GOTO   2E14
2DFC:  MOVF   x24,W
2DFE:  SUBWF  x2D,W
2E00:  BTFSS  FD8.2
2E02:  GOTO   2E14
2E06:  MOVF   x25,W
2E08:  SUBWF  x2E,W
2E0A:  BTFSS  FD8.2
2E0C:  BRA    2E14
2E0E:  MOVLB  0
2E10:  GOTO   2E1A
2E14:  MOVLB  0
2E16:  GOTO   28E4
.................... 		  
....................             // successfully obtained a message, inc buffer count  
....................             if (++gVehicleBufCnt >= VEHICLE_MAX_MSGS)  
....................                 break;	   // all buffers full  
2E1A:  INCF   21,F
2E1C:  MOVF   21,W
2E1E:  SUBLW  1F
2E20:  BTFSC  FD8.0
2E22:  GOTO   2E2A
2E26:  GOTO   2E5C
.................... 				            
....................             // if host wants one response message and entire segmented msg, if any, is received  
....................             if (gFlags.firstResp && gFirstFrameDataLength[0] <= 0)  
....................                 break;  
2E2A:  BTFSS  18.3
2E2C:  GOTO   2E58
2E30:  MOVLB  1
2E32:  BTFSC  xCC.7
2E34:  GOTO   2E52
2E38:  MOVF   xCC,F
2E3A:  BTFSC  FD8.2
2E3C:  BRA    2E44
2E3E:  MOVLB  0
2E40:  GOTO   2E58
2E44:  MOVF   xCB,W
2E46:  SUBLW  00
2E48:  BTFSC  FD8.0
2E4A:  BRA    2E52
2E4C:  MOVLB  0
2E4E:  GOTO   2E58
2E52:  MOVLB  0
2E54:  GOTO   2E5C
.................... 		}  
.................... 	}  
2E58:  GOTO   28E4
....................   
....................     // if no CAN message received and no error already set  
....................     if (gVehicleBufCnt == 0 && !gError)  
.................... 	{  
2E5C:  MOVF   21,F
2E5E:  BTFSS  FD8.2
2E60:  GOTO   2E74
2E64:  MOVF   1A,F
2E66:  BTFSS  FD8.2
2E68:  GOTO   2E74
.................... 		// set error and save contents of COMSTAT register  
.................... 	    gError = ERR_CAN_NO_RESPONSE;  
2E6C:  MOVLW  15
2E6E:  MOVWF  1A
.................... 		gErrorExtraData1 = COMSTAT;  
2E70:  MOVFF  F74,1B
2E74:  MOVLB  2
.................... 	}  
.................... }  
2E76:  MOVLB  0
2E78:  GOTO   359C (RETURN)
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: CanSend  
.................... // Description: Send CAN message using the current interface and current   
.................... //  identifier.  
.................... // Parameters:    
.................... //  data - 8 OBD II frame data message to send  
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void CanSend(BYTE* data)  
.................... {  
....................     // is this a standard identifier message?? 
....................     if (IsCmdStandardId(gCurrentCmd))  
.................... 	{  
*
26FC:  MOVFF  22,231
2700:  CALL   1C3A
2704:  MOVF   01,F
2706:  BTFSC  FD8.2
2708:  GOTO   2744
....................         // send standard id CAN message  
.................... 	    if (!CANSendMessage(gIdentifier, data, 8, CAN_TX_PRIORITY_0    
.................... 	                                            & CAN_TX_STD_FRAME  
....................                                                 & CAN_TX_NO_RTR_FRAME))  
....................             gError = ERR_CAN_TX_BUFFER_UNAVAIL;  
270C:  MOVFF  1FF,234
2710:  MOVFF  1FE,233
2714:  MOVFF  1FD,232
2718:  MOVFF  1FC,231
271C:  MOVFF  230,236
2720:  MOVFF  22F,235
2724:  MOVLW  08
2726:  MOVLB  2
2728:  MOVWF  x37
272A:  MOVLW  FC
272C:  MOVWF  x38
272E:  MOVLB  0
2730:  CALL   2576
2734:  MOVF   01,F
2736:  BTFSS  FD8.2
2738:  GOTO   2740
273C:  MOVLW  18
273E:  MOVWF  1A
.................... 	}  
.................... 	else  
.................... 	{  
2740:  GOTO   2778
....................         // send extended id CAN message  
.................... 	    if (!CANSendMessage(gIdentifier, data, 8, CAN_TX_PRIORITY_0    
.................... 	                                            & CAN_TX_XTD_FRAME  
....................                                                 & CAN_TX_NO_RTR_FRAME))  
....................             gError = ERR_CAN_TX_BUFFER_UNAVAIL;  
2744:  MOVFF  1FF,234
2748:  MOVFF  1FE,233
274C:  MOVFF  1FD,232
2750:  MOVFF  1FC,231
2754:  MOVFF  230,236
2758:  MOVFF  22F,235
275C:  MOVLW  08
275E:  MOVLB  2
2760:  MOVWF  x37
2762:  MOVLW  F4
2764:  MOVWF  x38
2766:  MOVLB  0
2768:  CALL   2576
276C:  MOVF   01,F
276E:  BTFSS  FD8.2
2770:  GOTO   2778
2774:  MOVLW  18
2776:  MOVWF  1A
.................... 	}  
.................... }  
2778:  RETLW  00
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: VehRecvCAN  
.................... // Description: Use RBX1 to double buffer RBX0.  
.................... // Parameters:    
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void CanInit()  
.................... {  
....................     // is this a standard id message?? 
....................     if (IsCmdStandardId(gCurrentCmd))  
.................... 	{  
*
2210:  MOVFF  22,231
2214:  CALL   1C3A
2218:  MOVF   01,F
221A:  BTFSC  FD8.2
221C:  GOTO   2358
.................... 	    // is this 250kb?? 
....................         if (IsCmd250kb(gCurrentCmd))  
.................... 		{  
2220:  MOVFF  22,210
2224:  CALL   1CB8
2228:  MOVF   01,F
222A:  BTFSC  FD8.2
222C:  GOTO   2254
.................... 		    // 250kb standard message initialization  
.................... 	        CANInitialize(3, 2, 8, 4, 7, CAN_CONFIG_PHSEG2_PRG_ON   
....................                                          & CAN_CONFIG_SAMPLE_THRICE  
....................                                          & CAN_CONFIG_VALID_STD_MSG  
....................                                          & CAN_CONFIG_DBL_BUFFER_ON);	  
2230:  MOVLW  03
2232:  MOVLB  2
2234:  MOVWF  x10
2236:  MOVLW  02
2238:  MOVWF  x11
223A:  MOVLW  08
223C:  MOVWF  x12
223E:  MOVLW  04
2240:  MOVWF  x13
2242:  MOVLW  07
2244:  MOVWF  x14
2246:  MOVLW  BB
2248:  MOVWF  x15
224A:  MOVLB  0
224C:  CALL   20BA
.................... 		}  
.................... 		else  
.................... 		{  
2250:  GOTO   2274
.................... 		    // 500kb standard message initialization  
....................             CANInitialize(3, 1, 8, 4, 7, CAN_CONFIG_PHSEG2_PRG_ON   
....................                                         & CAN_CONFIG_SAMPLE_THRICE  
....................                                         & CAN_CONFIG_VALID_STD_MSG  
....................                                         & CAN_CONFIG_DBL_BUFFER_ON);  
2254:  MOVLW  03
2256:  MOVLB  2
2258:  MOVWF  x10
225A:  MOVLW  01
225C:  MOVWF  x11
225E:  MOVLW  08
2260:  MOVWF  x12
2262:  MOVLW  04
2264:  MOVWF  x13
2266:  MOVLW  07
2268:  MOVWF  x14
226A:  MOVLW  BB
226C:  MOVWF  x15
226E:  MOVLB  0
2270:  CALL   20BA
.................... 		}  
.................... 									   
....................         // Set CAN module back into the configuration mode									       
.................... 	    CANSetOperationMode(CAN_OP_MODE_CONFIG);		  
2274:  MOVLW  80
2276:  MOVLB  2
2278:  MOVWF  x18
227A:  MOVLB  0
227C:  CALL   1D36
.................... 					  
.................... 		// 11bit ECU Identifier range 0x7e8 to 0x7ef  
.................... 	    CANSetMask(CAN_MASK_B1, gStdMask, CAN_CONFIG_STD_MSG);    
2280:  MOVLB  2
2282:  CLRF   x18
2284:  MOVLB  0
2286:  MOVFF  203,21C
228A:  MOVFF  202,21B
228E:  MOVFF  201,21A
2292:  MOVFF  200,219
2296:  MOVLW  FF
2298:  MOVLB  2
229A:  MOVWF  x1D
229C:  MOVLB  0
229E:  CALL   1FC4
.................... 	    CANSetFilter(CAN_FILTER_B1_F1, gStdFilter, CAN_CONFIG_STD_MSG);  
22A2:  MOVLB  2
22A4:  CLRF   x18
22A6:  MOVLB  0
22A8:  MOVFF  207,21C
22AC:  MOVFF  206,21B
22B0:  MOVFF  205,21A
22B4:  MOVFF  204,219
22B8:  MOVLW  FF
22BA:  MOVLB  2
22BC:  MOVWF  x1D
22BE:  MOVLB  0
22C0:  CALL   2006
....................   
.................... 		// disable all other filters and masks by setting them to opposite  
.................... 		// of the used mask (i.e. used mask is STD, then unused set to XTD)  
.................... 	    CANSetMask(CAN_MASK_B2, 0xFFFFFFFF, CAN_CONFIG_STD_MSG);  
22C4:  MOVLW  01
22C6:  MOVLB  2
22C8:  MOVWF  x18
22CA:  MOVLW  FF
22CC:  MOVWF  x1C
22CE:  MOVWF  x1B
22D0:  MOVWF  x1A
22D2:  MOVWF  x19
22D4:  MOVWF  x1D
22D6:  MOVLB  0
22D8:  CALL   1FC4
.................... 	    CANSetFilter(CAN_FILTER_B1_F2, 0x00000000, CAN_CONFIG_XTD_MSG);  
22DC:  MOVLW  01
22DE:  MOVLB  2
22E0:  MOVWF  x18
22E2:  CLRF   x1C
22E4:  CLRF   x1B
22E6:  CLRF   x1A
22E8:  CLRF   x19
22EA:  MOVLW  F7
22EC:  MOVWF  x1D
22EE:  MOVLB  0
22F0:  CALL   2006
.................... 	    CANSetFilter(CAN_FILTER_B2_F1, 0x00000000, CAN_CONFIG_XTD_MSG);  
22F4:  MOVLW  02
22F6:  MOVLB  2
22F8:  MOVWF  x18
22FA:  CLRF   x1C
22FC:  CLRF   x1B
22FE:  CLRF   x1A
2300:  CLRF   x19
2302:  MOVLW  F7
2304:  MOVWF  x1D
2306:  MOVLB  0
2308:  CALL   2006
.................... 	    CANSetFilter(CAN_FILTER_B2_F2, 0x00000000, CAN_CONFIG_XTD_MSG);  
230C:  MOVLW  03
230E:  MOVLB  2
2310:  MOVWF  x18
2312:  CLRF   x1C
2314:  CLRF   x1B
2316:  CLRF   x1A
2318:  CLRF   x19
231A:  MOVLW  F7
231C:  MOVWF  x1D
231E:  MOVLB  0
2320:  CALL   2006
.................... 	    CANSetFilter(CAN_FILTER_B2_F3, 0x00000000, CAN_CONFIG_XTD_MSG);  
2324:  MOVLW  04
2326:  MOVLB  2
2328:  MOVWF  x18
232A:  CLRF   x1C
232C:  CLRF   x1B
232E:  CLRF   x1A
2330:  CLRF   x19
2332:  MOVLW  F7
2334:  MOVWF  x1D
2336:  MOVLB  0
2338:  CALL   2006
.................... 	    CANSetFilter(CAN_FILTER_B2_F4, 0x00000000, CAN_CONFIG_XTD_MSG);  
233C:  MOVLW  05
233E:  MOVLB  2
2340:  MOVWF  x18
2342:  CLRF   x1C
2344:  CLRF   x1B
2346:  CLRF   x1A
2348:  CLRF   x19
234A:  MOVLW  F7
234C:  MOVWF  x1D
234E:  MOVLB  0
2350:  CALL   2006
.................... 	}  
.................... 	// else extended message  
.................... 	else  
.................... 	{  
2354:  GOTO   248E
.................... 	    // is this 250kb?? 
....................         if (IsCmd250kb(gCurrentCmd))  
.................... 		{  
2358:  MOVFF  22,210
235C:  CALL   1CB8
2360:  MOVF   01,F
2362:  BTFSC  FD8.2
2364:  GOTO   238C
.................... 		    // 250kb extended message initialization  
.................... 	        CANInitialize(3, 2, 8, 4, 7, CAN_CONFIG_PHSEG2_PRG_ON   
....................                                          & CAN_CONFIG_SAMPLE_THRICE  
....................                                          & CAN_CONFIG_VALID_XTD_MSG  
....................                                          & CAN_CONFIG_DBL_BUFFER_ON);	  
2368:  MOVLW  03
236A:  MOVLB  2
236C:  MOVWF  x10
236E:  MOVLW  02
2370:  MOVWF  x11
2372:  MOVLW  08
2374:  MOVWF  x12
2376:  MOVLW  04
2378:  MOVWF  x13
237A:  MOVLW  07
237C:  MOVWF  x14
237E:  MOVLW  DB
2380:  MOVWF  x15
2382:  MOVLB  0
2384:  CALL   20BA
.................... 		}  
.................... 		else  
.................... 		{  
2388:  GOTO   23AC
.................... 		    // 500kb extended message initialization  
....................             CANInitialize(3, 1, 8, 4, 7, CAN_CONFIG_PHSEG2_PRG_ON   
....................                                         & CAN_CONFIG_SAMPLE_THRICE  
....................                                         & CAN_CONFIG_VALID_XTD_MSG  
....................                                         & CAN_CONFIG_DBL_BUFFER_ON);  
238C:  MOVLW  03
238E:  MOVLB  2
2390:  MOVWF  x10
2392:  MOVLW  01
2394:  MOVWF  x11
2396:  MOVLW  08
2398:  MOVWF  x12
239A:  MOVLW  04
239C:  MOVWF  x13
239E:  MOVLW  07
23A0:  MOVWF  x14
23A2:  MOVLW  DB
23A4:  MOVWF  x15
23A6:  MOVLB  0
23A8:  CALL   20BA
.................... 		}  
.................... 										  
....................         // Set CAN module back into the configuration mode										  
....................         CANSetOperationMode(CAN_OP_MODE_CONFIG);					  
23AC:  MOVLW  80
23AE:  MOVLB  2
23B0:  MOVWF  x18
23B2:  MOVLB  0
23B4:  CALL   1D36
....................   
....................         // 29bit ECU Identifier range 18daf100 to 18daf1ff  
.................... 		CANSetMask(CAN_MASK_B1, gXtdMask, CAN_CONFIG_XTD_MSG);	  
23B8:  MOVLB  2
23BA:  CLRF   x18
23BC:  MOVLB  0
23BE:  MOVFF  20B,21C
23C2:  MOVFF  20A,21B
23C6:  MOVFF  209,21A
23CA:  MOVFF  208,219
23CE:  MOVLW  F7
23D0:  MOVLB  2
23D2:  MOVWF  x1D
23D4:  MOVLB  0
23D6:  CALL   1FC4
....................         CANSetFilter(CAN_FILTER_B1_F1, gXtdFilter, CAN_CONFIG_XTD_MSG);  
23DA:  MOVLB  2
23DC:  CLRF   x18
23DE:  MOVLB  0
23E0:  MOVFF  20F,21C
23E4:  MOVFF  20E,21B
23E8:  MOVFF  20D,21A
23EC:  MOVFF  20C,219
23F0:  MOVLW  F7
23F2:  MOVLB  2
23F4:  MOVWF  x1D
23F6:  MOVLB  0
23F8:  CALL   2006
....................   
.................... 		// disable all other filters and masks by setting them to opposite  
.................... 		// of the used mask (i.e. used mask is STD, then unused set to XTD)  
.................... 	    CANSetMask(CAN_MASK_B2, 0xFFFFFFFF, CAN_CONFIG_XTD_MSG);  
23FC:  MOVLW  01
23FE:  MOVLB  2
2400:  MOVWF  x18
2402:  MOVLW  FF
2404:  MOVWF  x1C
2406:  MOVWF  x1B
2408:  MOVWF  x1A
240A:  MOVWF  x19
240C:  MOVLW  F7
240E:  MOVWF  x1D
2410:  MOVLB  0
2412:  CALL   1FC4
.................... 	    CANSetFilter(CAN_FILTER_B1_F2, 0x00000000, CAN_CONFIG_STD_MSG);  
2416:  MOVLW  01
2418:  MOVLB  2
241A:  MOVWF  x18
241C:  CLRF   x1C
241E:  CLRF   x1B
2420:  CLRF   x1A
2422:  CLRF   x19
2424:  MOVLW  FF
2426:  MOVWF  x1D
2428:  MOVLB  0
242A:  CALL   2006
.................... 	    CANSetFilter(CAN_FILTER_B2_F1, 0x00000000, CAN_CONFIG_STD_MSG);  
242E:  MOVLW  02
2430:  MOVLB  2
2432:  MOVWF  x18
2434:  CLRF   x1C
2436:  CLRF   x1B
2438:  CLRF   x1A
243A:  CLRF   x19
243C:  MOVLW  FF
243E:  MOVWF  x1D
2440:  MOVLB  0
2442:  CALL   2006
.................... 	    CANSetFilter(CAN_FILTER_B2_F2, 0x00000000, CAN_CONFIG_STD_MSG);  
2446:  MOVLW  03
2448:  MOVLB  2
244A:  MOVWF  x18
244C:  CLRF   x1C
244E:  CLRF   x1B
2450:  CLRF   x1A
2452:  CLRF   x19
2454:  MOVLW  FF
2456:  MOVWF  x1D
2458:  MOVLB  0
245A:  CALL   2006
.................... 	    CANSetFilter(CAN_FILTER_B2_F3, 0x00000000, CAN_CONFIG_STD_MSG);  
245E:  MOVLW  04
2460:  MOVLB  2
2462:  MOVWF  x18
2464:  CLRF   x1C
2466:  CLRF   x1B
2468:  CLRF   x1A
246A:  CLRF   x19
246C:  MOVLW  FF
246E:  MOVWF  x1D
2470:  MOVLB  0
2472:  CALL   2006
.................... 	    CANSetFilter(CAN_FILTER_B2_F4, 0x00000000, CAN_CONFIG_STD_MSG);  
2476:  MOVLW  05
2478:  MOVLB  2
247A:  MOVWF  x18
247C:  CLRF   x1C
247E:  CLRF   x1B
2480:  CLRF   x1A
2482:  CLRF   x19
2484:  MOVLW  FF
2486:  MOVWF  x1D
2488:  MOVLB  0
248A:  CALL   2006
.................... 	}  
.................... 	  
.................... 	// Set CAN module for normal RX & TX operation  
.................... 	CANSetOperationMode(CAN_OP_MODE_NORMAL);  
248E:  MOVLB  2
2490:  CLRF   x18
2492:  MOVLB  0
2494:  CALL   1D36
....................   
.................... 	// enable CAN output driver  
....................    	output_low(PIN_C3);  
2498:  BCF    F94.3
249A:  BCF    F8B.3
.................... }  
249C:  GOTO   2792 (RETURN)
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: CanDisable  
.................... // Description: Disable CAN module, abort messages, and disable the external   
.................... //	CAN hardware driver chip.  
.................... // Parameters:    
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void CanDisable()  
.................... {  
.................... 	// disable the external CAN output driver MCP2551 chip. This is required  
.................... 	// because the CAN module in sleep or listen is in the wrong logic state  
.................... 	// causing other CAN modules on the bus to complain about being clobbered  
....................    	output_high(PIN_C3);  
*
0128:  BCF    F94.3
012A:  BSF    F8B.3
....................   
.................... 	// abort all pending messages, if any  
.................... 	CANAbortAll();  
012C:  BSF    F6F.4
....................   
.................... 	// put CAN module to sleep  
....................  	// This call makes the adapter lockup sometimes (e.g. Toyota Tacoma 2006), offers no value so no need to use  
.................... 	//CANSetOperationModeNoWait(CAN_OP_MODE_SLEEP);  
....................   
.................... 	// on next CAN message, module needs to be reinitialized  
.................... 	gFlags.forceInitCAN = TRUE;  
012E:  BSF    18.4
.................... }  
0130:  RETLW  00
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: CanEmptyRxBuffer  
.................... // Description: Just discard any messages within the RX buffer.  
.................... // Parameters:    
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void CanEmptyRxBuffer()  
.................... {  
....................     int32 newMessageID;			  
....................     int8 newMessageLen;  
....................     CAN_RX_MSG_FLAGS newMessageFlags;  
.................... 	  
....................     if (IsCmdCAN(gLastCmd))  
....................         // receive and discard a CAN message, if any  
....................         CANReceiveMessage(&newMessageID, 0, &newMessageLen, &newMessageFlags);  
*
0792:  MOVFF  23,278
0796:  CALL   01CE
079A:  MOVF   01,F
079C:  BTFSC  FD8.2
079E:  GOTO   07C6
07A2:  MOVLW  02
07A4:  MOVLB  2
07A6:  MOVWF  x79
07A8:  MOVLW  72
07AA:  MOVWF  x78
07AC:  CLRF   x7B
07AE:  CLRF   x7A
07B0:  MOVLW  02
07B2:  MOVWF  x7D
07B4:  MOVLW  76
07B6:  MOVWF  x7C
07B8:  MOVLW  02
07BA:  MOVWF  x7F
07BC:  MOVLW  77
07BE:  MOVWF  x7E
07C0:  MOVLB  0
07C2:  CALL   055A
.................... }  
07C6:  RETLW  00
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: CanSetMaskFilter  
.................... // Description: Set the STD or XTD mask and filter based upon host message.  
.................... // Parameters:    
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void CanSetMaskFilter()  
.................... {  
.................... 	gFlags.forceInitCAN = TRUE;  
*
2E7C:  BSF    18.4
....................   
.................... 	if (gHostBuf[IDX_HOST_COMMAND] == CMD_CAN_SET_STD_MASK_FILTER)  
.................... 	{  
2E7E:  MOVF   33,W
2E80:  SUBLW  97
2E82:  BTFSS  FD8.2
2E84:  GOTO   2EC8
.................... 		gStdMask = StrToInt32(&gHostBuf[2]);  
2E88:  MOVLB  2
2E8A:  CLRF   x11
2E8C:  MOVLW  34
2E8E:  MOVWF  x10
2E90:  MOVLB  0
2E92:  CALL   24A0
2E96:  MOVFF  03,203
2E9A:  MOVFF  02,202
2E9E:  MOVFF  01,201
2EA2:  MOVFF  00,200
.................... 		gStdFilter = StrToInt32(&gHostBuf[6]);  
2EA6:  MOVLB  2
2EA8:  CLRF   x11
2EAA:  MOVLW  38
2EAC:  MOVWF  x10
2EAE:  MOVLB  0
2EB0:  CALL   24A0
2EB4:  MOVFF  03,207
2EB8:  MOVFF  02,206
2EBC:  MOVFF  01,205
2EC0:  MOVFF  00,204
.................... 	}  
.................... 	else  
.................... 	{  
2EC4:  GOTO   2F04
.................... 		gXtdMask = StrToInt32(&gHostBuf[2]);  
2EC8:  MOVLB  2
2ECA:  CLRF   x11
2ECC:  MOVLW  34
2ECE:  MOVWF  x10
2ED0:  MOVLB  0
2ED2:  CALL   24A0
2ED6:  MOVFF  03,20B
2EDA:  MOVFF  02,20A
2EDE:  MOVFF  01,209
2EE2:  MOVFF  00,208
.................... 		gXtdFilter = StrToInt32(&gHostBuf[6]);  
2EE6:  MOVLB  2
2EE8:  CLRF   x11
2EEA:  MOVLW  38
2EEC:  MOVWF  x10
2EEE:  MOVLB  0
2EF0:  CALL   24A0
2EF4:  MOVFF  03,20F
2EF8:  MOVFF  02,20E
2EFC:  MOVFF  01,20D
2F00:  MOVFF  00,20C
.................... 	}  
.................... }  
2F04:  GOTO   35BC (RETURN)
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: CanSetP2CanTimeout  
.................... // Description: Set P2can timeout value to used to indicate how long the adapter  
.................... //	should wait for incoming ECU messages.  
.................... //  
.................... //  Host should never send any mS value larger than 214748mS otherwise coversion  
.................... //	to ticks with MS_TO_TICKS math will overflow.  
.................... // Parameters:    
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void CanSetP2CanTimeout()  
.................... {  
.................... 	// get host's new mS value  
.................... 	gP2can = StrToInt32(&gHostBuf[2]);  
*
2F76:  MOVLB  2
2F78:  CLRF   x11
2F7A:  MOVLW  34
2F7C:  MOVWF  x10
2F7E:  MOVLB  0
2F80:  CALL   24A0
2F84:  MOVFF  03,1C4
2F88:  MOVFF  02,1C3
2F8C:  MOVFF  01,1C2
2F90:  MOVFF  00,1C1
....................   
.................... 	// convert mS to timer ticks   
.................... 	gP2can = MS_TO_TICKS(gP2can);  
2F94:  MOVFF  1C4,213
2F98:  MOVFF  1C3,212
2F9C:  MOVFF  1C2,211
2FA0:  MOVFF  1C1,210
2FA4:  MOVLB  2
2FA6:  CLRF   x17
2FA8:  CLRF   x16
2FAA:  MOVLW  27
2FAC:  MOVWF  x15
2FAE:  MOVLW  10
2FB0:  MOVWF  x14
2FB2:  MOVLB  0
2FB4:  GOTO   2F08
2FB8:  MOVLB  2
2FBA:  RRCF   03,W
2FBC:  MOVLB  1
2FBE:  MOVWF  xC4
2FC0:  MOVLB  2
2FC2:  RRCF   02,W
2FC4:  MOVLB  1
2FC6:  MOVWF  xC3
2FC8:  MOVLB  2
2FCA:  RRCF   01,W
2FCC:  MOVLB  1
2FCE:  MOVWF  xC2
2FD0:  MOVLB  2
2FD2:  RRCF   00,W
2FD4:  MOVLB  1
2FD6:  MOVWF  xC1
2FD8:  RRCF   xC4,F
2FDA:  RRCF   xC3,F
2FDC:  RRCF   xC2,F
2FDE:  RRCF   xC1,F
2FE0:  RRCF   xC4,F
2FE2:  RRCF   xC3,F
2FE4:  RRCF   xC2,F
2FE6:  RRCF   xC1,F
2FE8:  RRCF   xC4,F
2FEA:  RRCF   xC3,F
2FEC:  RRCF   xC2,F
2FEE:  RRCF   xC1,F
2FF0:  MOVLW  0F
2FF2:  ANDWF  xC4,F
.................... }		     
2FF4:  MOVLB  0
2FF6:  GOTO   35CE (RETURN)
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: CANClearRxErrors  
.................... // Description: Clears any errors and resets the RX receive buffer status.  
.................... //	NOTE: This routine not tested!  
.................... // Parameters:    
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void CanClearRxErrors()  
.................... {  
....................     // Set CAN module back into the configuration mode									       
.................... 	CANSetOperationMode(CAN_OP_MODE_CONFIG);		  
.................... 	  
....................     RXB0CON_RXFUL = 0;  
....................     RXB1CON_RXFUL = 0;  
....................     COMSTAT_RX0OVFL = 0;  
....................     COMSTAT_RX1OVFL = 0;  
....................     PIR3_RXB0IF = 0;  
....................     PIR3_RXB1IF = 0;  
.................... 	  
.................... 	// Set CAN module for normal RX & TX operation  
.................... 	CANSetOperationMode(CAN_OP_MODE_NORMAL);					  
.................... }  
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: CanResetSegmentedRecvStats  
.................... // Description: Reset the segmented message tracking variables.  
.................... // Parameters:   
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void CanResetSegmentedRecvStats()  
.................... {  
.................... 	gFirstFrameRespondedECUs = 0;  
*
2826:  MOVLB  1
2828:  CLRF   xFB
.................... 	gFirstFrameDataLength[0] = 0;  // only the 1st one reset to 0 required  
282A:  CLRF   xCC
282C:  CLRF   xCB
.................... }  
282E:  MOVLB  0
2830:  GOTO   28E4 (RETURN)
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: CanIsSegmentedRecvComplete  
.................... // Description: Returns the status of the segmented message receive (i.e.   
.................... //	ConsecutiveFrames).   
.................... // Parameters:   
.................... // Output Parameters:  
.................... // Return Values: RECV_NONE if no consecutive messages are being tracked,   
.................... //	RECV_PENDING if one or more messages are still arriving, and RECV_COMPLETE  
.................... //	when all segemented messages have arrived.   
.................... //------------------------------------------------------------------------------  
.................... int8 CanIsSegmentedRecvComplete()  
.................... {  
.................... 	int8 cnt;  
.................... 	if (gFirstFrameRespondedECUs == 0)  
.................... 		return RECV_NONE;  
2834:  MOVLB  1
2836:  MOVF   xFB,F
2838:  BTFSS  FD8.2
283A:  GOTO   2846
283E:  MOVLW  00
2840:  MOVWF  01
2842:  GOTO   28A6
....................   
.................... 	// search each segmented message byte count in list to check if all are <= 0   
.................... 	for (cnt=0; cnt<gFirstFrameRespondedECUs; cnt++)  
2846:  MOVLB  2
2848:  CLRF   x2F
284A:  MOVLB  1
284C:  MOVF   xFB,W
284E:  MOVLB  2
2850:  SUBWF  x2F,W
2852:  BTFSC  FD8.0
2854:  GOTO   28A0
.................... 	{  
.................... 		if (gFirstFrameDataLength[cnt] > 0)  
.................... 			return RECV_PENDING;  
2858:  BCF    FD8.0
285A:  RLCF   x2F,W
285C:  CLRF   03
285E:  ADDLW  CB
2860:  MOVWF  FE9
2862:  MOVLW  01
2864:  ADDWFC 03,W
2866:  MOVWF  FEA
2868:  MOVLB  0
286A:  MOVFF  FEC,231
286E:  MOVF   FED,F
2870:  MOVFF  FEF,230
2874:  MOVLB  2
2876:  BTFSC  x31.7
2878:  GOTO   289A
287C:  MOVF   x31,F
287E:  BTFSS  FD8.2
2880:  GOTO   288E
2884:  MOVF   x30,W
2886:  SUBLW  00
2888:  BTFSC  FD8.0
288A:  GOTO   289A
288E:  MOVLW  01
2890:  MOVWF  01
2892:  MOVLB  1
2894:  GOTO   28A6
2898:  MOVLB  2
.................... 	}  
289A:  INCF   x2F,F
289C:  GOTO   284A
.................... 	return RECV_COMPLETE;  
28A0:  MOVLW  02
28A2:  MOVWF  01
28A4:  MOVLB  1
.................... }  
28A6:  MOVLB  0
28A8:  RETLW  00
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: CanErrorIsr  
.................... // Description: Interrupt function to handle CAN bus errors. Sets the global  
.................... //	error flag to be handled by the main loop. Stops the CAN module from  
.................... //	continuing to retry transmissions.   
.................... // Parameters:   
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... #INT_CANERR  
.................... void CanErrorIsr()  
.................... {  
.................... 	// if only warning bits are set, just return and ignore  
.................... 	//if (!(gErrorExtraData1 & 0xF8))  
.................... 	//	return;  
....................   
.................... 	if (gError == ERR_NONE)  
.................... 	{  
*
0132:  MOVF   1A,F
0134:  BTFSS  FD8.2
0136:  GOTO   0142
.................... 		// set error and save contents of COMSTAT register  
.................... 		gError = ERR_CAN_ERROR_INTERRUPT;  
013A:  MOVLW  1A
013C:  MOVWF  1A
.................... 		gErrorExtraData1 = COMSTAT;  
013E:  MOVFF  F74,1B
.................... 	}  
.................... 	  
.................... 	CanDisable();  
0142:  CALL   0128
.................... 	  
.................... 	// clear any overflow errors, if any  
.................... 	bit_clear(COMSTAT, RXB0OVFL);  
0146:  BCF    F74.7
.................... 	bit_clear(COMSTAT, RXB1OVFL);  
0148:  BCF    F74.6
.................... }  
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: CanIrxIsr  
.................... // Description: Interrupt function to handle CAN message TX and RX errors. Sets   
.................... //	the global error flag to be handled by the main loop. Stops the CAN module from  
.................... //	continuing to retry transmissions.  
.................... //  
.................... //	This ISR fires on TX and RX errors. This ISR is used during auto-detection.  
.................... //	This ISRs job is to get off the bus as soon as possible and not clobber   
.................... //	other vehicle's	communcation. When auto-detecting, we may transmit at the   
.................... //	wrong speed and	trash other communications. If we didn't get off the bus   
.................... //	fast enough on the the Mazda 6 2004 we'd generate U0100 and U0121 errors.  
.................... // Parameters:   
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
014A:  BCF    FA4.5
014C:  GOTO   007C
.................... #INT_CANIRX  
.................... void CanIrxIsr()  
.................... {  
.................... 	// only FBGO commands will do a fast bus get off  
....................     if (!IsCmdFBGO(gCurrentCmd))  
.................... 	{  
*
0194:  MOVFF  22,252
0198:  GOTO   0150
019C:  MOVF   01,F
019E:  BTFSS  FD8.2
01A0:  GOTO   01AA
....................     	// acknowledge interrupt by clearing status  
.................... 		bit_clear(PIR3, IRXIF);   
01A4:  BCF    FA4.7
....................         return;  
01A6:  GOTO   01C8
.................... 	}   
....................   
.................... 	if (gError == ERR_NONE)  
.................... 	{  
01AA:  MOVF   1A,F
01AC:  BTFSS  FD8.2
01AE:  GOTO   01C2
.................... 	    gError = ERR_CAN_INVALID_MSG_INTERRUPT;  
01B2:  MOVLW  1B
01B4:  MOVWF  1A
.................... 		gErrorExtraData1 = TXB0CON;  
01B6:  MOVFF  F40,1B
.................... 		gErrorExtraData2 = TXB1CON;  
01BA:  MOVFF  F30,1C
.................... 		gErrorExtraData3 = TXB2CON;  
01BE:  MOVFF  F20,1D
.................... 	}  
....................                 
.................... 	CanDisable();  
01C2:  CALL   0128
....................       
....................     // acknowledge interrupt by clearing status  
....................     bit_clear(PIR3, IRXIF);  
01C6:  BCF    FA4.7
.................... }   
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: CanRx1 CanRx2  
.................... // Description: CAN receive interrupt functions. When the adapter is idle and  
.................... //	not actively obtaining a CAN message, then just discard any received messages.  
.................... //  One of these ISR(s) will fire every time a CAN message arrives. However,  
.................... // 	the adapter receives messages by polling when servicing a host request.  
.................... //	Therefore, these ISRs must be disabled during receive.  
.................... // Parameters:   
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
01C8:  BCF    FA4.7
01CA:  GOTO   007C
.................... #INT_CANRX1  
.................... void CanRx1()  
.................... {  
.................... 	CanEmptyRxBuffer();    
*
07C8:  CALL   0792
.................... }  
07CC:  BCF    FA4.1
07CE:  GOTO   007C
.................... #INT_CANRX0  
.................... void CanRx0()  
.................... {  
.................... 	CanEmptyRxBuffer();    
07D2:  CALL   0792
.................... }  
....................   
....................   
....................   
....................   
....................   
....................   
....................   
....................   
....................   
....................  
.................... #include "Timer.c" 
....................  //------------------------------------------------------------------------------  
.................... // File: Timer  
.................... //  
.................... // Purpose: High speed timer (HST) routines.   
.................... //  
.................... // Change History:  
.................... // Date		Author		Description  
.................... //          Lafreniere	Created  
.................... //------------------------------------------------------------------------------  
.................... #include "Timer.h" 
....................  //------------------------------------------------------------------------------  
.................... // File: Timer  
.................... //  
.................... // Purpose: High speed timer (HST) routines.   
.................... //  
.................... // Change History:  
.................... // Date		Author		Description  
.................... //          Lafreniere	Created  
.................... //------------------------------------------------------------------------------  
.................... #ifndef TIMER_H  
.................... #define TIMER_H  
....................   
.................... #define TIMER1_TIMEOUT          0     // 1.6uS per tick with div set to 8  
.................... #define MS_TO_TICKS(mS) 		((mS * 10000) / 16)	  // 1.6uS per tick  
....................   
.................... // max 16-bit number  
.................... #define HST_TWO_MS              1250  
.................... #define HST_TEN_MS              6250  
.................... #define HST_TWENTY_FIVE_MS      15625  
.................... #define HST_FIFTY_MS            31250  
.................... #define HST_FIVE_HUNDRED_MS		312500	// NOTE: this number exceeds 16-bit timer and must be used with Int32  
.................... #define HST_ONE_S				625000	// NOTE: this number exceeds 16-bit timer and must be used with Int32  
....................   
.................... typedef int16 HstTimer; //TBD DEBUG  
.................... //typedef int32 HstTimer;  
....................               
.................... HstTimer HstGetTicks(void) { return get_timer1(); }  
.................... BOOLEAN HstTestTimer(HstTimer timer, HstTimer ticks);  
.................... BOOLEAN HstTestTimerRetrig(HstTimer *timer, HstTimer ticks);  
.................... HstTimer HstElapsedTime(HstTimer timer);  
....................   
.................... #endif  
....................  
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: HstTestTimer  
.................... // Description: Test a timer for timeout.   
.................... // Parameters: timer - A timer that was read at start of delay.  
.................... //	    ticks - Number of ticks to test.  
.................... // Output Parameters:  
.................... // Return Values: If the number of ticks in 'ticks' has passed since the   
.................... //	    initial reading of 'timer' return TRUE, else return	FALSE.  
.................... //------------------------------------------------------------------------------  
07D6:  BCF    FA4.0
07D8:  GOTO   007C
.................... BOOLEAN HstTestTimer(HstTimer timer, HstTimer ticks)  
.................... {  
....................     // check to see if 'ticks' number of ticks have passed  
....................     if (get_timer1() - timer >= ticks)  
....................         return TRUE;  
*
1988:  MOVF   FCE,W
198A:  MOVFF  FCF,03
198E:  MOVLB  2
1990:  MOVWF  x38
1992:  MOVLB  0
1994:  MOVFF  03,239
1998:  MOVLB  2
199A:  MOVF   x34,W
199C:  SUBWF  x38,W
199E:  MOVWF  x3A
19A0:  MOVF   x35,W
19A2:  SUBWFB x39,W
19A4:  MOVWF  x3B
19A6:  MOVF   x37,W
19A8:  SUBWF  x3B,W
19AA:  BTFSS  FD8.0
19AC:  GOTO   19CC
19B0:  BTFSS  FD8.2
19B2:  GOTO   19C0
19B6:  MOVF   x36,W
19B8:  SUBWF  x3A,W
19BA:  BTFSS  FD8.0
19BC:  GOTO   19CC
19C0:  MOVLW  01
19C2:  MOVWF  01
19C4:  GOTO   19D4
....................     else  
....................         return FALSE;  
19C8:  GOTO   19D4
19CC:  MOVLW  00
19CE:  MOVWF  01
19D0:  GOTO   19D4
.................... }  
19D4:  MOVLB  0
19D6:  RETLW  00
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: HstTestTimerRetrig  
.................... // Description: Test a timer for timeout, retrigger the timer.   
.................... //	    This routine will then retrigger the given timer, so that subsequent reads   
.................... //	    will again read false until the number of ticks in 'ticks' has again passed.  
.................... // Parameters: timer - Pointer to a timer that was read at start of delay.  
.................... //	    ticks - Number of ticks to test.  
.................... // Output Parameters:  
.................... // Return Values: If the number of ticks in 'ticks' has passed since the   
.................... //	    initial reading of 'timer' return TRUE, else return	FALSE.  
.................... //------------------------------------------------------------------------------  
.................... BOOLEAN HstTestTimerRetrig(HstTimer *timer, HstTimer ticks)  
.................... {  
....................     // check to see if 'ticks' number of ticks have passed  
....................     if (get_timer1() - *timer >= ticks)  
....................     {     
....................     	*timer += ticks;      // bring Timer up to date without accumulative errors  
....................         return TRUE;  
....................     }  
....................     else  
....................         return FALSE;  
.................... }  
....................   
.................... //-----------------------------------------------------------------------------  
.................... // Function Name: HstElapsedTime  
.................... // Description: Calculates the elapsed time.   
.................... // Parameters: timer - Pointer to a timer that was read at start of delay.  
.................... // Output Parameters:  
.................... // Return Values: The elapsed time in ticks.   
.................... //------------------------------------------------------------------------------  
.................... HstTimer HstElapsedTime(HstTimer timer)  
.................... {  
....................     return (get_timer1() - timer);  
*
1128:  MOVF   FCE,W
112A:  MOVFF  FCF,03
112E:  MOVLB  2
1130:  MOVWF  x3C
1132:  MOVLB  0
1134:  MOVFF  03,23D
1138:  MOVLB  2
113A:  MOVF   x3A,W
113C:  SUBWF  x3C,W
113E:  MOVWF  00
1140:  MOVF   x3B,W
1142:  SUBWFB x3D,W
1144:  MOVWF  03
1146:  MOVF   00,W
1148:  MOVWF  01
114A:  MOVF   03,W
114C:  MOVWF  02
.................... }  
114E:  MOVLB  0
1150:  RETLW  00
....................   
....................   
....................  
.................... #include "Util.c" 
....................  //------------------------------------------------------------------------------  
.................... // File: Util  
.................... //  
.................... // Purpose: Misc utility routines.   
.................... //  
.................... // Change History:  
.................... // Date		Author		Description  
.................... //          Lafreniere	Created  
.................... //------------------------------------------------------------------------------  
.................... #include "Util.h" 
....................  //------------------------------------------------------------------------------  
.................... // File: Util  
.................... //  
.................... // Purpose: Misc utility routines.   
.................... //  
.................... // Change History:  
.................... // Date		Author		Description  
.................... //          Lafreniere	Created  
.................... //------------------------------------------------------------------------------  
.................... #ifndef UTIL_H  
.................... #define UTIL_H  
....................   
.................... // starting address for the 4-byte EEPOM write protect table  
.................... #define EEPROM_WRITE_PROTECT_TABLE_ADDR 	252  
....................   
.................... // the logical sector size is arbitrary and has nothing to do with the PIC hardware  
.................... #define EEPROM_SECTOR_SIZE 	8  
....................   
.................... void ReadEeprom();  
.................... void ReadEepromLocal(int8 sector);  
.................... void WriteEeprom();  
.................... int8 IsEepromSectorWriteProtected(int8 sector);  
.................... int32 ReadEepromSectorWriteProtectTable();  
.................... void WriteEerpomSectorWriteProtectTable(int32 writeProtectBits);  
.................... void init_ports();  
.................... void Bus_If_Init(void);  
.................... void DecryptBlock(int8 *outbfr, int8 *inbfr);  
.................... int8 IsCmdCAN(int8 cmd);  
.................... int8 IsCmdLocal(int8 cmd);  
.................... int8 IsCmdFBGO(int8 cmd);  
.................... int8 IsCmdListen(int8 cmd);  
.................... int8 IsCmdNoResponse(int8 cmd);  
.................... int8 IsCmdFirstResp(int8 cmd);  
.................... int8 IsCmdStandardId(int8 cmd);  
.................... int8 IsCmd250kb(int8 cmd);  
.................... int8 checksum(int8* pMsg, int8 size);  
.................... int8 crc8(int8* buffer, int8 count);  
.................... int32 StrToInt32(int8* str);  
.................... int8 TraceStr(int8* pMsg, int8 size);  
.................... int8 Trace(int8 msg);  
....................   
.................... #endif  
....................  
....................   
.................... // must be a valid mask, not just any old number. Use different masks for different   
.................... // manufacturers.  
.................... #define LFSR_MASK 0xB38C    // Softworks    		  
.................... //#define LFSR_MASK 0x9C63    // Nology  
....................   
.................... // decryption block size (not including 2-byte Lfsr pad)  
.................... #define BLOCK_SIZE 4				  
....................   
.................... // trace debug port used to view debug chars on HyperTermial   
.................... #use rs232(baud=9600,xmit=PIN_B4,parity=n,bits=8,stream=STREAM_DEBUG)  
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: init_ports  
.................... // Description: Initialize all PIC ports to power-on state.  
.................... // Parameters:   
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void init_ports()   
.................... {  
.................... 	set_tris_a ( 0x55 ); 	// This goes into TRISA, a 1 sets a port pin for input  
*
07DC:  MOVLW  55
07DE:  MOVWF  F92
.................... 							// See hardware.h for definitions of I/O pins & TRIS bits  
.................... 	set_tris_b ( 0x28 );	// This goes into TRISB, a 1 sets a port pin for input  
07E0:  MOVLW  28
07E2:  MOVWF  F93
.................... 	set_tris_c ( 0xB7 );	// This goes into TRISC, a 1 sets a port pin for input  
07E4:  MOVLW  B7
07E6:  MOVWF  F94
.................... 	#USE FAST_IO(a)			// forces compiler to not set port directions on every port write  
.................... 	#USE FAST_IO(b)			// forces compiler to not set port directions on every port write  
.................... 	#USE FAST_IO(c)			// forces compiler to not set port directions on every port write  
....................    
.................... 	port_b_pullups(TRUE);	// disable global Port B pull up resistors   
07E8:  BCF    FF1.7
.................... 							// set all bus outputs inactive (PWM, VPW, ISO & CAN)  
.................... 	output_a(0x08);			// PWM_P_OUT RA3 = 1  
07EA:  MOVLW  08
07EC:  MOVWF  F89
.................... 							// PWM_N_OUT RA0 = 0  
....................   
.................... 	output_b(0x00);			// VPW_4X	 RB0 = 0  
07EE:  CLRF   F8A
.................... 							// VPW_OUT   RB1 = 0  
.................... 							// CAN_TX	 RB2 = 0  
.................... 							// ISO_K_TX  RB6 = 0  
.................... 							// ISO_L_TX  RB7 = 0  
.................... }  
07F0:  GOTO   39CC (RETURN)
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: IsEepromSectorWriteProtected  
.................... // Description: Checks if a EEPROM sector is write protected. The write-protect  
.................... // 	bits are stored at the end of the 256 byte EEPROM range.    
.................... // Parameters: sector - A value from 0 to 30 representing a sector number.  
.................... // Output Parameters:  
.................... // Return Values: 1 if write protected, 0 otherwise.  
.................... //------------------------------------------------------------------------------  
.................... int8 IsEepromSectorWriteProtected(int8 sector)  
.................... {  
.................... 	int32 writeProtectBits;  
....................   
.................... 	writeProtectBits = ReadEepromSectorWriteProtectTable();  
*
310E:  CALL   30A8
3112:  MOVFF  03,21D
3116:  MOVFF  02,21C
311A:  MOVFF  01,21B
311E:  MOVFF  00,21A
....................   
.................... 	// a 1 in the EEPROM bit location within the table means not-write protected,   
.................... 	// a 0 means protected  
.................... 	writeProtectBits = writeProtectBits >> sector;  
3122:  MOVLB  2
3124:  MOVF   x19,W
3126:  MOVWF  x1E
3128:  BTFSC  FD8.2
312A:  GOTO   313E
312E:  BCF    FD8.0
3130:  RRCF   x1D,F
3132:  RRCF   x1C,F
3134:  RRCF   x1B,F
3136:  RRCF   x1A,F
3138:  DECFSZ x1E,F
313A:  GOTO   312E
.................... 	if (writeProtectBits & 1)  
.................... 		return 0;  
313E:  MOVF   x1A,W
3140:  ANDLW  01
3142:  MOVWF  00
3144:  MOVF   x1B,W
3146:  ANDLW  00
3148:  MOVWF  01
314A:  MOVF   x1C,W
314C:  ANDLW  00
314E:  MOVWF  02
3150:  MOVF   x1D,W
3152:  ANDLW  00
3154:  MOVWF  03
3156:  MOVF   00,F
3158:  BTFSS  FD8.2
315A:  GOTO   3176
315E:  MOVF   01,F
3160:  BTFSS  FD8.2
3162:  GOTO   3176
3166:  MOVF   02,F
3168:  BTFSS  FD8.2
316A:  GOTO   3176
316E:  MOVF   03,F
3170:  BTFSC  FD8.2
3172:  GOTO   3182
3176:  MOVLW  00
3178:  MOVWF  01
317A:  GOTO   318A
.................... 	else  
.................... 		return 1;  
317E:  GOTO   318A
3182:  MOVLW  01
3184:  MOVWF  01
3186:  GOTO   318A
.................... }  
318A:  MOVLB  0
318C:  RETLW  00
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: ReadEepromSectorWriteProtectTable  
.................... // Description: Reads the 4-byte write-protect table. Each bit within the table  
.................... //  represents 1 sector (except the last location which is not used). Only  
.................... // 	31 sectors, so 31 bits to represent a write-protect state for each of those  
.................... //	sectors.   
.................... // Parameters:   
.................... // Output Parameters:  
.................... // Return Values: The write-protect table as a int32.   
.................... //------------------------------------------------------------------------------  
.................... int32 ReadEepromSectorWriteProtectTable()  
.................... {  
.................... 	int8 cnt;  
.................... 	int32 writeProtectBits;  
.................... 	for (cnt = 0; cnt<4; cnt++)  
*
30A8:  MOVLB  2
30AA:  CLRF   x1E
30AC:  MOVF   x1E,W
30AE:  SUBLW  03
30B0:  BTFSS  FD8.0
30B2:  GOTO   30FA
.................... 		*(&writeProtectBits + cnt) = read_eeprom(EEPROM_WRITE_PROTECT_TABLE_ADDR + cnt);  
30B6:  MOVLW  1F
30B8:  ADDWF  x1E,W
30BA:  MOVWF  01
30BC:  MOVLW  02
30BE:  MOVWF  03
30C0:  BTFSC  FD8.0
30C2:  INCF   03,F
30C4:  MOVF   01,W
30C6:  MOVWF  FE9
30C8:  MOVLB  0
30CA:  MOVFF  03,FEA
30CE:  MOVLW  FC
30D0:  MOVLB  2
30D2:  ADDWF  x1E,W
30D4:  MOVWF  x25
30D6:  MOVLB  0
30D8:  MOVFF  FF2,226
30DC:  BCF    FF2.7
30DE:  CLRF   FAA
30E0:  MOVFF  225,FA9
30E4:  BCF    FA6.6
30E6:  BCF    FA6.7
30E8:  BSF    FA6.0
30EA:  MOVF   FA8,W
30EC:  MOVLB  2
30EE:  BTFSC  x26.7
30F0:  BSF    FF2.7
30F2:  MOVWF  FEF
30F4:  INCF   x1E,F
30F6:  GOTO   30AC
.................... 	return writeProtectBits;  
30FA:  MOVLB  0
30FC:  MOVFF  21F,00
3100:  MOVFF  220,01
3104:  MOVFF  221,02
3108:  MOVFF  222,03
.................... }  
310C:  RETLW  00
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: WriteEerpomSectorWriteProtectTable  
.................... // Description: Write the 4-byte write-protect table.   
.................... // Parameters: writeProtectBits - a 32-bit integer representing the write-protect  
.................... //	sector table status.  
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void WriteEerpomSectorWriteProtectTable(int32 writeProtectBits)  
.................... {  
.................... 	int8 cnt;  
.................... 	for (cnt = 0; cnt<4; cnt++)  
*
320E:  MOVLB  2
3210:  CLRF   x1D
3212:  MOVF   x1D,W
3214:  SUBLW  03
3216:  BTFSS  FD8.0
3218:  GOTO   3274
.................... 		write_eeprom(EEPROM_WRITE_PROTECT_TABLE_ADDR + cnt, *(&writeProtectBits + cnt));  
321C:  MOVLW  FC
321E:  ADDWF  x1D,W
3220:  MOVWF  x1E
3222:  MOVLW  19
3224:  ADDWF  x1D,W
3226:  MOVWF  01
3228:  MOVLW  02
322A:  MOVWF  03
322C:  BTFSC  FD8.0
322E:  INCF   03,F
3230:  MOVF   01,W
3232:  MOVWF  FE9
3234:  MOVLB  0
3236:  MOVFF  03,FEA
323A:  MOVFF  FEF,21F
323E:  CLRF   FAA
3240:  MOVFF  21E,FA9
3244:  MOVFF  21F,FA8
3248:  BCF    FA6.6
324A:  BCF    FA6.7
324C:  BSF    FA6.2
324E:  MOVF   FF2,W
3250:  MOVWF  00
3252:  BCF    FF2.7
3254:  MOVLB  F
3256:  MOVLW  55
3258:  MOVWF  FA7
325A:  MOVLW  AA
325C:  MOVWF  FA7
325E:  BSF    FA6.1
3260:  BTFSC  FA6.1
3262:  GOTO   3260
3266:  BCF    FA6.2
3268:  MOVF   00,W
326A:  IORWF  FF2,F
326C:  MOVLB  2
326E:  INCF   x1D,F
3270:  GOTO   3212
.................... }  
3274:  MOVLB  0
3276:  GOTO   338A (RETURN)
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: ReadEepromLocal  
.................... // Description: Read PIC EEPROM and do not send to host. EEPROM data will be located in  
.................... //  gVehicleBuf[0][0], eVehicleBuf[0][EEPROM_SECTOR_SIZE].  
.................... //  
.................... //	For Bluetooth, EEPROM sector 0 and sector 1 PIC must be programmed with the Bluetooth   
.................... //  address used by the adapter test fixture. The Bluetooth address is 12 bytes and is used  
.................... //  to automatically pair and connect to the Windows test fixture. This prevents having  
.................... //  to manually pair each Bluetooth adapter to the PC during production. Once production  
.................... //  is done, the test fixture software writes all FF's to this location to prevent the   
.................... //  automatic pairing when used by the customer. The PIC programmer software is used  
.................... //  to modify the HEX file to add the unique 12 byte Bluetooth address and therefore  
.................... //  can be changed without recompiling the program.  
.................... // Parameters:   
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void ReadEepromLocal(int8 sector)  
.................... {  
.................... 	// put the sector in the host buf used by the ReadEeprom() function  
.................... 	gHostBuf[2] = sector;  
.................... }  
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: ReadEeprom  
.................... // Description: Read PIC EEPROM and send to host.   
.................... //	The PIC has 256 bytes of EEPROM. 248 bytes can be accessed by the host. The  
.................... //	space is logically broken into 31 8-byte sections. The last 8-bytes is reserved  
.................... //	for bits to define whether a section is write-protected (i.e. locked) or not.  
.................... //	31 bits are required for the locking table, 1 bit for each section. A 1 means  
.................... //	the section is locked, a 0 means not-locked. Once a section is write-protected,  
.................... //  the host cannot reverse it.   
.................... //  
.................... //	During production, the PIC must be programmed to have the EEPROM programmed to  
.................... //	all locations 0xFF.  
.................... // Parameters:   
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void ReadEeprom()  
.................... {  
.................... 	int8 cnt;  
.................... 	//gFlags.vehicleData = FALSE;  
....................   
.................... 	// only 31 8-byte EEPROM sectors (0 through 30) can be read  
.................... 	if (gHostBuf[2] > 30)    
.................... 	{  
*
318E:  MOVF   34,W
3190:  SUBLW  1E
3192:  BTFSC  FD8.0
3194:  GOTO   31A0
.................... 		gError = ERR_INVALID_NON_VOLATILE_SECTOR;  
3198:  MOVLW  86
319A:  MOVWF  1A
.................... 		return;  
319C:  GOTO   320A
.................... 	}  
....................   
.................... 	// add sector number being read to buffer  
.................... 	gVehicleBuf[0][0] = gHostBuf[2];  
31A0:  MOVFF  34,41
....................   
.................... 	// add write-protect state to buffer  
.................... 	if (IsEepromSectorWriteProtected(gHostBuf[2]))  
.................... 		gVehicleBuf[0][1] = 1;  
31A4:  MOVFF  34,219
31A8:  CALL   310E
31AC:  MOVF   01,F
31AE:  BTFSC  FD8.2
31B0:  GOTO   31BC
31B4:  MOVLW  01
31B6:  MOVWF  42
.................... 	else  
.................... 		gVehicleBuf[0][1] = 0;  
31B8:  GOTO   31BE
31BC:  CLRF   42
....................   
.................... 	// copy 8 bytes if EEPROM data into outgoing host buffer  
.................... 	for (cnt = 0; cnt<EEPROM_SECTOR_SIZE; cnt++)  
31BE:  MOVLB  2
31C0:  CLRF   x10
31C2:  MOVF   x10,W
31C4:  SUBLW  07
31C6:  BTFSS  FD8.0
31C8:  GOTO   3208
.................... 		gVehicleBuf[0][cnt+2] = read_eeprom((gHostBuf[2] * EEPROM_SECTOR_SIZE) + cnt);  
31CC:  MOVLW  02
31CE:  ADDWF  x10,W
31D0:  ADDLW  41
31D2:  MOVWF  FE9
31D4:  CLRF   FEA
31D6:  BTFSC  FD8.0
31D8:  INCF   FEA,F
31DA:  MOVF   34,W
31DC:  MULLW  08
31DE:  MOVF   FF3,W
31E0:  ADDWF  x10,W
31E2:  MOVWF  x15
31E4:  MOVLB  0
31E6:  MOVFF  FF2,216
31EA:  BCF    FF2.7
31EC:  CLRF   FAA
31EE:  MOVFF  215,FA9
31F2:  BCF    FA6.6
31F4:  BCF    FA6.7
31F6:  BSF    FA6.0
31F8:  MOVF   FA8,W
31FA:  MOVLB  2
31FC:  BTFSC  x16.7
31FE:  BSF    FF2.7
3200:  MOVWF  FEF
3202:  INCF   x10,F
3204:  GOTO   31C2
3208:  MOVLB  0
.................... }  
320A:  GOTO   363A (RETURN)
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: WriteEeprom  
.................... // Description: Write to EEPROM values from host.   
.................... // Parameters:   
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void WriteEeprom()  
.................... {  
.................... 	int8 cnt;  
.................... 	int32 writeProtectBits;  
.................... 	int32 bitLocation;  
.................... 	//gFlags.vehicleData = FALSE;  
....................   
.................... 	// only 31 8-byte EEPROM sectors (0 through 30) can be written  
.................... 	if (gHostBuf[2] > 30)  
.................... 	{  
*
327A:  MOVF   34,W
327C:  SUBLW  1E
327E:  BTFSC  FD8.0
3280:  GOTO   328C
.................... 		gError = ERR_INVALID_NON_VOLATILE_SECTOR;  
3284:  MOVLW  86
3286:  MOVWF  1A
.................... 		return;  
3288:  GOTO   3392
.................... 	}  
....................   
.................... 	// error check 8-byte section is not locked  
.................... 	if (IsEepromSectorWriteProtected(gHostBuf[2]))  
.................... 	{  
328C:  MOVFF  34,219
3290:  CALL   310E
3294:  MOVF   01,F
3296:  BTFSC  FD8.2
3298:  GOTO   32A4
.................... 		gError = ERR_NON_VOLATILE_SECTOR_LOCKED;  
329C:  MOVLW  87
329E:  MOVWF  1A
.................... 		return;  
32A0:  GOTO   3392
.................... 	}  
....................   
.................... 	// copy 8 bytes from host message into the appropriate EEPROM sector   
.................... 	for (cnt = 0; cnt<EEPROM_SECTOR_SIZE; cnt++)  
32A4:  MOVLB  2
32A6:  CLRF   x10
32A8:  MOVF   x10,W
32AA:  SUBLW  07
32AC:  BTFSS  FD8.0
32AE:  GOTO   3308
.................... 		write_eeprom((gHostBuf[2] * EEPROM_SECTOR_SIZE) + cnt, gHostBuf[cnt+4]);  
32B2:  MOVF   34,W
32B4:  MULLW  08
32B6:  MOVF   FF3,W
32B8:  ADDWF  x10,W
32BA:  MOVWF  x1A
32BC:  MOVLW  04
32BE:  ADDWF  x10,W
32C0:  CLRF   03
32C2:  ADDLW  32
32C4:  MOVWF  FE9
32C6:  MOVLW  00
32C8:  ADDWFC 03,W
32CA:  MOVWF  FEA
32CC:  MOVLB  0
32CE:  MOVFF  FEF,21C
32D2:  CLRF   FAA
32D4:  MOVFF  21A,FA9
32D8:  MOVFF  21C,FA8
32DC:  BCF    FA6.6
32DE:  BCF    FA6.7
32E0:  BSF    FA6.2
32E2:  MOVF   FF2,W
32E4:  MOVWF  00
32E6:  BCF    FF2.7
32E8:  MOVLB  F
32EA:  MOVLW  55
32EC:  MOVWF  FA7
32EE:  MOVLW  AA
32F0:  MOVWF  FA7
32F2:  BSF    FA6.1
32F4:  BTFSC  FA6.1
32F6:  GOTO   32F4
32FA:  BCF    FA6.2
32FC:  MOVF   00,W
32FE:  IORWF  FF2,F
3300:  MOVLB  2
3302:  INCF   x10,F
3304:  GOTO   32A8
....................   
.................... 	// if host says to write-protect the EEPROM 8-byte section, then do it by  
.................... 	// updating the EEPROM table.   
.................... 	if (gHostBuf[3])  
.................... 	{  
3308:  MOVF   35,F
330A:  BTFSC  FD8.2
330C:  GOTO   338C
.................... 		writeProtectBits = ReadEepromSectorWriteProtectTable();  
3310:  MOVLB  0
3312:  CALL   30A8
3316:  MOVFF  03,214
331A:  MOVFF  02,213
331E:  MOVFF  01,212
3322:  MOVFF  00,211
.................... 		bitLocation = 1;  
3326:  MOVLB  2
3328:  CLRF   x18
332A:  CLRF   x17
332C:  CLRF   x16
332E:  MOVLW  01
3330:  MOVWF  x15
.................... 		bitLocation = bitLocation << gHostBuf[2];  
3332:  MOVF   34,W
3334:  MOVWF  x19
3336:  BTFSC  FD8.2
3338:  GOTO   334C
333C:  BCF    FD8.0
333E:  RLCF   x15,F
3340:  RLCF   x16,F
3342:  RLCF   x17,F
3344:  RLCF   x18,F
3346:  DECFSZ x19,F
3348:  GOTO   333C
.................... 		writeProtectBits &= ~bitLocation;   // set 1 bit to 0. 0 means write-protected  
334C:  MOVF   x15,W
334E:  MOVWF  00
3350:  COMF   00,F
3352:  MOVF   x16,W
3354:  MOVWF  01
3356:  COMF   01,F
3358:  MOVF   x17,W
335A:  MOVWF  02
335C:  COMF   02,F
335E:  MOVF   x18,W
3360:  MOVWF  03
3362:  COMF   03,F
3364:  MOVF   00,W
3366:  ANDWF  x11,F
3368:  MOVF   01,W
336A:  ANDWF  x12,F
336C:  MOVF   02,W
336E:  ANDWF  x13,F
3370:  MOVF   03,W
3372:  ANDWF  x14,F
.................... 		WriteEerpomSectorWriteProtectTable(writeProtectBits);	  
3374:  MOVLB  0
3376:  MOVFF  214,21C
337A:  MOVFF  213,21B
337E:  MOVFF  212,21A
3382:  MOVFF  211,219
3386:  GOTO   320E
338A:  MOVLB  2
.................... 	}  
....................   
.................... 	// add sector number being wrote to buffer   
.................... 	gVehicleBuf[0][0] = gHostBuf[2];  
338C:  MOVLB  0
338E:  MOVFF  34,41
.................... }  
3392:  GOTO   364C (RETURN)
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: Bus_If_Init  
.................... // Description: Bus routines, common variables & timers initialization  
.................... // Parameters: timeout - the timeout in 2mS increments  
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void Bus_If_Init(void) {  
.................... 	LinkFlags = 0;			// clear all local flags  
*
0B58:  CLRF   27
.................... 	LinkControl = 0;  
0B5A:  CLRF   26
.................... 	BusByteCntr = 0;  
0B5C:  CLRF   2B
....................     MaskReg = 0x80;  
0B5E:  MOVLW  80
0B60:  MOVWF  29
....................   
.................... 	setup_timer_0( RTCC_INTERNAL | RTCC_DIV_2 );	//  intialize & start timer0 at 400ns per count  
0B62:  MOVWF  FD5
.................... 	setup_timer_2( T2_DIV_BY_16, 35, 16 );			//  intialize timer2 for 2ms rollover  
0B64:  MOVLW  78
0B66:  MOVWF  01
0B68:  IORLW  06
0B6A:  MOVWF  FCA
0B6C:  MOVLW  23
0B6E:  MOVWF  FCB
.................... }  
0B70:  RETLW  00
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: IsCmdCAN  
.................... // Description:  
.................... // Parameters: cmd - adapter command  
.................... // Output Parameters:  
.................... // Return Values: Return 1 if mode is CAN, 0 otherwise.  
.................... //------------------------------------------------------------------------------  
.................... int8 IsCmdCAN(int8 cmd)  
.................... {  
....................     if (cmd == CMD_CAN_SI_250KB ||  
....................         cmd == CMD_CAN_SI_500KB ||  
.................... 		cmd == CMD_CAN_EI_250KB ||  
.................... 		cmd == CMD_CAN_EI_500KB ||  
....................         cmd == CMD_CAN_SI_250KB_1ST ||  
....................         cmd == CMD_CAN_SI_500KB_1ST ||  
.................... 		cmd == CMD_CAN_EI_250KB_1ST ||  
.................... 		cmd == CMD_CAN_EI_500KB_1ST ||  
.................... 		cmd == CMD_CAN_SI_250KB_FBGO ||  
....................         cmd == CMD_CAN_SI_500KB_FBGO ||  
.................... 		cmd == CMD_CAN_EI_250KB_FBGO ||  
.................... 		cmd == CMD_CAN_EI_500KB_FBGO ||  
.................... 		cmd == CMD_CAN_SI_250KB_LISTEN ||  
....................         cmd == CMD_CAN_SI_500KB_LISTEN ||  
.................... 		cmd == CMD_CAN_EI_250KB_LISTEN ||  
.................... 		cmd == CMD_CAN_EI_500KB_LISTEN ||  
.................... 		cmd == CMD_CAN_SI_250KB_NO_RESPONSE ||  
....................         cmd == CMD_CAN_SI_500KB_NO_RESPONSE ||  
.................... 		cmd == CMD_CAN_EI_250KB_NO_RESPONSE ||  
.................... 		cmd == CMD_CAN_EI_500KB_NO_RESPONSE)  
.................... 		return 1;  
*
01CE:  MOVLB  2
01D0:  MOVF   x78,W
01D2:  SUBLW  08
01D4:  BTFSC  FD8.2
01D6:  GOTO   0298
01DA:  MOVF   x78,W
01DC:  SUBLW  90
01DE:  BTFSC  FD8.2
01E0:  GOTO   0298
01E4:  MOVF   x78,W
01E6:  SUBLW  91
01E8:  BTFSC  FD8.2
01EA:  GOTO   0298
01EE:  MOVF   x78,W
01F0:  SUBLW  92
01F2:  BTFSC  FD8.2
01F4:  GOTO   0298
01F8:  MOVF   x78,W
01FA:  SUBLW  93
01FC:  BTFSC  FD8.2
01FE:  GOTO   0298
0202:  MOVF   x78,W
0204:  SUBLW  94
0206:  BTFSC  FD8.2
0208:  GOTO   0298
020C:  MOVF   x78,W
020E:  SUBLW  95
0210:  BTFSC  FD8.2
0212:  GOTO   0298
0216:  MOVF   x78,W
0218:  SUBLW  96
021A:  BTFSC  FD8.2
021C:  GOTO   0298
0220:  MOVF   x78,W
0222:  SUBLW  9A
0224:  BTFSC  FD8.2
0226:  GOTO   0298
022A:  MOVF   x78,W
022C:  SUBLW  9B
022E:  BTFSC  FD8.2
0230:  GOTO   0298
0234:  MOVF   x78,W
0236:  SUBLW  9C
0238:  BTFSC  FD8.2
023A:  GOTO   0298
023E:  MOVF   x78,W
0240:  SUBLW  9D
0242:  BTFSC  FD8.2
0244:  GOTO   0298
0248:  MOVF   x78,W
024A:  SUBLW  9E
024C:  BTFSC  FD8.2
024E:  GOTO   0298
0252:  MOVF   x78,W
0254:  SUBLW  9F
0256:  BTFSC  FD8.2
0258:  GOTO   0298
025C:  MOVF   x78,W
025E:  SUBLW  A0
0260:  BTFSC  FD8.2
0262:  GOTO   0298
0266:  MOVF   x78,W
0268:  SUBLW  A1
026A:  BTFSC  FD8.2
026C:  GOTO   0298
0270:  MOVF   x78,W
0272:  SUBLW  A2
0274:  BTFSC  FD8.2
0276:  GOTO   0298
027A:  MOVF   x78,W
027C:  SUBLW  A3
027E:  BTFSC  FD8.2
0280:  GOTO   0298
0284:  MOVF   x78,W
0286:  SUBLW  A4
0288:  BTFSC  FD8.2
028A:  GOTO   0298
028E:  MOVF   x78,W
0290:  SUBLW  A5
0292:  BTFSS  FD8.2
0294:  GOTO   02A4
0298:  MOVLW  01
029A:  MOVWF  01
029C:  GOTO   02AC
.................... 	else  
.................... 		return 0;  
02A0:  GOTO   02AC
02A4:  MOVLW  00
02A6:  MOVWF  01
02A8:  GOTO   02AC
.................... }  
02AC:  MOVLB  0
02AE:  RETLW  00
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: IsCmdFBGO  
.................... // Description:  
.................... // Parameters: cmd - adapter command  
.................... // Output Parameters:  
.................... // Return Values: Return 1 if mode is FBGO (fast bus get off), 0 otherwise.  
.................... //------------------------------------------------------------------------------  
.................... int8 IsCmdFBGO(int8 cmd)  
.................... {  
.................... 	if (cmd == CMD_CAN_SI_250KB_FBGO ||  
....................         cmd == CMD_CAN_SI_500KB_FBGO ||  
.................... 		cmd == CMD_CAN_EI_250KB_FBGO ||  
.................... 		cmd == CMD_CAN_EI_500KB_FBGO)  
.................... 		return 1;  
*
0150:  MOVLB  2
0152:  MOVF   x52,W
0154:  SUBLW  9A
0156:  BTFSC  FD8.2
0158:  GOTO   017A
015C:  MOVF   x52,W
015E:  SUBLW  9B
0160:  BTFSC  FD8.2
0162:  GOTO   017A
0166:  MOVF   x52,W
0168:  SUBLW  9C
016A:  BTFSC  FD8.2
016C:  GOTO   017A
0170:  MOVF   x52,W
0172:  SUBLW  9D
0174:  BTFSS  FD8.2
0176:  GOTO   0186
017A:  MOVLW  01
017C:  MOVWF  01
017E:  GOTO   018E
.................... 	else  
.................... 		return 0;  
0182:  GOTO   018E
0186:  MOVLW  00
0188:  MOVWF  01
018A:  GOTO   018E
.................... }  
018E:  MOVLB  0
0190:  GOTO   019C (RETURN)
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: IsCmdListen  
.................... // Description:  
.................... // Parameters: cmd - adapter command  
.................... // Output Parameters:  
.................... // Return Values: Return 1 if mode is listen only, 0 otherwise.  
.................... //------------------------------------------------------------------------------  
.................... int8 IsCmdListen(int8 cmd)  
.................... {  
.................... 	if (cmd == CMD_CAN_SI_250KB_LISTEN ||  
....................         cmd == CMD_CAN_SI_500KB_LISTEN ||  
.................... 		cmd == CMD_CAN_EI_250KB_LISTEN ||  
.................... 		cmd == CMD_CAN_EI_500KB_LISTEN)  
.................... 		return 1;  
*
2532:  MOVLB  2
2534:  MOVF   x10,W
2536:  SUBLW  9E
2538:  BTFSC  FD8.2
253A:  GOTO   255C
253E:  MOVF   x10,W
2540:  SUBLW  9F
2542:  BTFSC  FD8.2
2544:  GOTO   255C
2548:  MOVF   x10,W
254A:  SUBLW  A0
254C:  BTFSC  FD8.2
254E:  GOTO   255C
2552:  MOVF   x10,W
2554:  SUBLW  A1
2556:  BTFSS  FD8.2
2558:  GOTO   2568
255C:  MOVLW  01
255E:  MOVWF  01
2560:  GOTO   2570
.................... 	else  
.................... 		return 0;  
2564:  GOTO   2570
2568:  MOVLW  00
256A:  MOVWF  01
256C:  GOTO   2570
.................... }  
2570:  MOVLB  0
2572:  GOTO   27BE (RETURN)
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: IsCmdNoResponse  
.................... // Description:  
.................... // Parameters: cmd - adapter command  
.................... // Output Parameters:  
.................... // Return Values: Return 1 if mode is no response type, 0 otherwise.  
.................... //------------------------------------------------------------------------------  
.................... int8 IsCmdNoResponse(int8 cmd)  
.................... {  
.................... 	if (cmd == CMD_CAN_SI_250KB_NO_RESPONSE ||  
....................         cmd == CMD_CAN_SI_500KB_NO_RESPONSE ||  
.................... 		cmd == CMD_CAN_EI_250KB_NO_RESPONSE ||  
.................... 		cmd == CMD_CAN_EI_500KB_NO_RESPONSE ||  
.................... 		cmd == CMD_ISO_NO_RESPONSE)  
.................... 		return 1;  
*
27D8:  MOVLB  2
27DA:  MOVF   x10,W
27DC:  SUBLW  A2
27DE:  BTFSC  FD8.2
27E0:  GOTO   280C
27E4:  MOVF   x10,W
27E6:  SUBLW  A3
27E8:  BTFSC  FD8.2
27EA:  GOTO   280C
27EE:  MOVF   x10,W
27F0:  SUBLW  A4
27F2:  BTFSC  FD8.2
27F4:  GOTO   280C
27F8:  MOVF   x10,W
27FA:  SUBLW  A5
27FC:  BTFSC  FD8.2
27FE:  GOTO   280C
2802:  MOVF   x10,W
2804:  SUBLW  A6
2806:  BTFSS  FD8.2
2808:  GOTO   2818
280C:  MOVLW  01
280E:  MOVWF  01
2810:  GOTO   2820
.................... 	else  
.................... 		return 0;  
2814:  GOTO   2820
2818:  MOVLW  00
281A:  MOVWF  01
281C:  GOTO   2820
.................... }  
2820:  MOVLB  0
2822:  GOTO   3590 (RETURN)
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: IsCmdStandardId  
.................... // Description:	Is the CAN command a standard identifier?? 
.................... // Parameters: cmd - adapter command  
.................... // Output Parameters:  
.................... // Return Values: Return 1 if command is standard, else extended.  
.................... //------------------------------------------------------------------------------  
.................... int8 IsCmdStandardId(int8 cmd)  
.................... {  
....................     // is this a standard identifier message?? 
....................     if (cmd == CMD_CAN_SI_250KB ||  
....................         cmd == CMD_CAN_SI_500KB ||  
....................         cmd == CMD_CAN_SI_250KB_1ST ||  
....................         cmd == CMD_CAN_SI_500KB_1ST ||  
.................... 		cmd == CMD_CAN_SI_250KB_FBGO ||  
....................         cmd == CMD_CAN_SI_500KB_FBGO ||  
.................... 		cmd == CMD_CAN_SI_250KB_LISTEN ||  
....................         cmd == CMD_CAN_SI_500KB_LISTEN ||  
.................... 		cmd == CMD_CAN_SI_250KB_NO_RESPONSE ||  
....................         cmd == CMD_CAN_SI_500KB_NO_RESPONSE)  
.................... 		return 1;  
*
1C3A:  MOVLB  2
1C3C:  MOVF   x31,W
1C3E:  SUBLW  08
1C40:  BTFSC  FD8.2
1C42:  GOTO   1CA0
1C46:  MOVF   x31,W
1C48:  SUBLW  90
1C4A:  BTFSC  FD8.2
1C4C:  GOTO   1CA0
1C50:  MOVF   x31,W
1C52:  SUBLW  93
1C54:  BTFSC  FD8.2
1C56:  GOTO   1CA0
1C5A:  MOVF   x31,W
1C5C:  SUBLW  94
1C5E:  BTFSC  FD8.2
1C60:  GOTO   1CA0
1C64:  MOVF   x31,W
1C66:  SUBLW  9A
1C68:  BTFSC  FD8.2
1C6A:  GOTO   1CA0
1C6E:  MOVF   x31,W
1C70:  SUBLW  9B
1C72:  BTFSC  FD8.2
1C74:  GOTO   1CA0
1C78:  MOVF   x31,W
1C7A:  SUBLW  9E
1C7C:  BTFSC  FD8.2
1C7E:  GOTO   1CA0
1C82:  MOVF   x31,W
1C84:  SUBLW  9F
1C86:  BTFSC  FD8.2
1C88:  GOTO   1CA0
1C8C:  MOVF   x31,W
1C8E:  SUBLW  A2
1C90:  BTFSC  FD8.2
1C92:  GOTO   1CA0
1C96:  MOVF   x31,W
1C98:  SUBLW  A3
1C9A:  BTFSS  FD8.2
1C9C:  GOTO   1CAC
1CA0:  MOVLW  01
1CA2:  MOVWF  01
1CA4:  GOTO   1CB4
.................... 	else  
.................... 		return 0;  
1CA8:  GOTO   1CB4
1CAC:  MOVLW  00
1CAE:  MOVWF  01
1CB0:  GOTO   1CB4
.................... }  
1CB4:  MOVLB  0
1CB6:  RETLW  00
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: IsCmd250kb  
.................... // Description:	Is the CAN command a 250kb/sec CAN message?? 
.................... // Parameters: cmd - adapter command  
.................... // Output Parameters:  
.................... // Return Values: Return 1 if command is 250kb, else 500kb or non-CAN command.  
.................... //------------------------------------------------------------------------------  
.................... int8 IsCmd250kb(int8 cmd)  
.................... {  
....................     // is this a 250kb message?? 
....................     if (cmd == CMD_CAN_SI_250KB ||  
.................... 		cmd == CMD_CAN_EI_250KB ||  
....................         cmd == CMD_CAN_SI_250KB_1ST ||  
.................... 		cmd == CMD_CAN_EI_250KB_1ST ||  
.................... 		cmd == CMD_CAN_SI_250KB_FBGO ||  
.................... 		cmd == CMD_CAN_EI_250KB_FBGO ||  
.................... 		cmd == CMD_CAN_SI_250KB_LISTEN ||  
.................... 		cmd == CMD_CAN_EI_250KB_LISTEN ||  
.................... 		cmd == CMD_CAN_SI_250KB_NO_RESPONSE ||  
.................... 		cmd == CMD_CAN_EI_250KB_NO_RESPONSE)  
.................... 		return 1;  
1CB8:  MOVLB  2
1CBA:  MOVF   x10,W
1CBC:  SUBLW  08
1CBE:  BTFSC  FD8.2
1CC0:  GOTO   1D1E
1CC4:  MOVF   x10,W
1CC6:  SUBLW  91
1CC8:  BTFSC  FD8.2
1CCA:  GOTO   1D1E
1CCE:  MOVF   x10,W
1CD0:  SUBLW  93
1CD2:  BTFSC  FD8.2
1CD4:  GOTO   1D1E
1CD8:  MOVF   x10,W
1CDA:  SUBLW  95
1CDC:  BTFSC  FD8.2
1CDE:  GOTO   1D1E
1CE2:  MOVF   x10,W
1CE4:  SUBLW  9A
1CE6:  BTFSC  FD8.2
1CE8:  GOTO   1D1E
1CEC:  MOVF   x10,W
1CEE:  SUBLW  9C
1CF0:  BTFSC  FD8.2
1CF2:  GOTO   1D1E
1CF6:  MOVF   x10,W
1CF8:  SUBLW  9E
1CFA:  BTFSC  FD8.2
1CFC:  GOTO   1D1E
1D00:  MOVF   x10,W
1D02:  SUBLW  A0
1D04:  BTFSC  FD8.2
1D06:  GOTO   1D1E
1D0A:  MOVF   x10,W
1D0C:  SUBLW  A2
1D0E:  BTFSC  FD8.2
1D10:  GOTO   1D1E
1D14:  MOVF   x10,W
1D16:  SUBLW  A4
1D18:  BTFSS  FD8.2
1D1A:  GOTO   1D2A
1D1E:  MOVLW  01
1D20:  MOVWF  01
1D22:  GOTO   1D32
.................... 	else  
.................... 		return 0;  
1D26:  GOTO   1D32
1D2A:  MOVLW  00
1D2C:  MOVWF  01
1D2E:  GOTO   1D32
.................... }  
1D32:  MOVLB  0
1D34:  RETLW  00
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: IsCmdLocal  
.................... // Description:  
.................... // Parameters: cmd - adapter command  
.................... // Output Parameters:  
.................... // Return Values: Return 1 if command is local command, 0 otherwise.  
.................... //------------------------------------------------------------------------------  
.................... int8 IsCmdLocal(int8 cmd)  
.................... {  
....................     if (cmd == CMD_CAN_SET_STD_MASK_FILTER ||  
....................         cmd == CMD_CAN_SET_XTD_MASK_FILTER ||  
.................... 		cmd == CMD_CAN_SET_P2_CAN_TIMEOUT ||  
.................... 		cmd == CMD_READ_BATTERY_VOLTAGE ||  
....................         cmd == CMD_UNLOCK_ADAPTER ||  
.................... 		cmd == CMD_ISO_ENABLE_L_LINE_XMIT ||  
.................... 		cmd == CMD_ISO_SET_9600_BAUD ||  
.................... 		cmd == CMD_ISO_CHECKSUM_ENABLE ||  
.................... 		cmd == CMD_ISO_5MS_BYTE_DELAY_ENABLE ||  
.................... 		cmd == CMD_READ_EEPROM ||  
.................... 		cmd == CMD_WRITE_EEPROM)  
.................... 		return 1;  
*
0944:  MOVLB  2
0946:  MOVF   x10,W
0948:  SUBLW  97
094A:  BTFSC  FD8.2
094C:  GOTO   09B4
0950:  MOVF   x10,W
0952:  SUBLW  98
0954:  BTFSC  FD8.2
0956:  GOTO   09B4
095A:  MOVF   x10,W
095C:  SUBLW  99
095E:  BTFSC  FD8.2
0960:  GOTO   09B4
0964:  MOVF   x10,W
0966:  SUBLW  F0
0968:  BTFSC  FD8.2
096A:  GOTO   09B4
096E:  MOVF   x10,W
0970:  SUBLW  B0
0972:  BTFSC  FD8.2
0974:  GOTO   09B4
0978:  MOVF   x10,W
097A:  SUBLW  A9
097C:  BTFSC  FD8.2
097E:  GOTO   09B4
0982:  MOVF   x10,W
0984:  SUBLW  AB
0986:  BTFSC  FD8.2
0988:  GOTO   09B4
098C:  MOVF   x10,W
098E:  SUBLW  AC
0990:  BTFSC  FD8.2
0992:  GOTO   09B4
0996:  MOVF   x10,W
0998:  SUBLW  AD
099A:  BTFSC  FD8.2
099C:  GOTO   09B4
09A0:  MOVF   x10,W
09A2:  SUBLW  B9
09A4:  BTFSC  FD8.2
09A6:  GOTO   09B4
09AA:  MOVF   x10,W
09AC:  SUBLW  BA
09AE:  BTFSS  FD8.2
09B0:  GOTO   09C0
09B4:  MOVLW  01
09B6:  MOVWF  01
09B8:  GOTO   09C8
.................... 	else  
.................... 		return 0;  
09BC:  GOTO   09C8
09C0:  MOVLW  00
09C2:  MOVWF  01
09C4:  GOTO   09C8
.................... }  
09C8:  MOVLB  0
09CA:  RETLW  00
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: IsCmdFirstResp  
.................... // Description:  
.................... // Parameters: cmd - adapter command  
.................... // Output Parameters:  
.................... // Return Values: Return 1 if command is a 1st response cmd, 0 otherwise.  
.................... //------------------------------------------------------------------------------  
.................... int8 IsCmdFirstResp(int8 cmd)  
.................... {  
....................     if (cmd == CMD_VPW_1ST_RESPONSE ||  
....................         cmd == CMD_PWM_1ST_RESPONSE ||  
....................         cmd == CMD_ISO_1ST_RESPONSE ||  
....................         cmd == CMD_KWP_1ST_RESPONSE ||  
....................         cmd == CMD_CAN_SI_250KB_1ST ||  
.................... 	    cmd == CMD_CAN_SI_500KB_1ST ||  
.................... 		cmd == CMD_CAN_EI_250KB_1ST ||  
.................... 		cmd == CMD_CAN_EI_500KB_1ST )  
.................... 		return TRUE;  
*
0A86:  MOVLB  2
0A88:  MOVF   x10,W
0A8A:  SUBLW  82
0A8C:  BTFSC  FD8.2
0A8E:  GOTO   0AD8
0A92:  MOVF   x10,W
0A94:  SUBLW  84
0A96:  BTFSC  FD8.2
0A98:  GOTO   0AD8
0A9C:  MOVF   x10,W
0A9E:  SUBLW  81
0AA0:  BTFSC  FD8.2
0AA2:  GOTO   0AD8
0AA6:  MOVF   x10,W
0AA8:  SUBLW  89
0AAA:  BTFSC  FD8.2
0AAC:  GOTO   0AD8
0AB0:  MOVF   x10,W
0AB2:  SUBLW  93
0AB4:  BTFSC  FD8.2
0AB6:  GOTO   0AD8
0ABA:  MOVF   x10,W
0ABC:  SUBLW  94
0ABE:  BTFSC  FD8.2
0AC0:  GOTO   0AD8
0AC4:  MOVF   x10,W
0AC6:  SUBLW  95
0AC8:  BTFSC  FD8.2
0ACA:  GOTO   0AD8
0ACE:  MOVF   x10,W
0AD0:  SUBLW  96
0AD2:  BTFSS  FD8.2
0AD4:  GOTO   0AE4
0AD8:  MOVLW  01
0ADA:  MOVWF  01
0ADC:  GOTO   0AEC
.................... 	else  
.................... 		return FALSE;  
0AE0:  GOTO   0AEC
0AE4:  MOVLW  00
0AE6:  MOVWF  01
0AE8:  GOTO   0AEC
.................... }  
0AEC:  MOVLB  0
0AEE:  GOTO   33CC (RETURN)
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: checksum  
.................... // Description: Calculate a checksum over an array of chars.   
.................... // Parameters: pMsg - char array to compute checksum.  
.................... //  size - size of array  
.................... // Output Parameters:  
.................... // Return Values: computed checksum  
.................... //------------------------------------------------------------------------------  
.................... int8 checksum(int8* pMsg, int8 size)  
.................... {  
....................     int8 cs=0;  
*
09CC:  MOVLB  2
09CE:  CLRF   x42
....................     int8 i=0;  
09D0:  CLRF   x43
....................     for (i=0; i<size; i++)  
09D2:  CLRF   x43
09D4:  MOVF   x41,W
09D6:  SUBWF  x43,W
09D8:  BTFSC  FD8.0
09DA:  GOTO   09F6
....................         cs += pMsg[i];  
09DE:  CLRF   03
09E0:  MOVF   x43,W
09E2:  ADDWF  x3F,W
09E4:  MOVWF  FE9
09E6:  MOVF   x40,W
09E8:  ADDWFC 03,W
09EA:  MOVWF  FEA
09EC:  MOVF   FEF,W
09EE:  ADDWF  x42,F
09F0:  INCF   x43,F
09F2:  GOTO   09D4
....................     return cs;  
09F6:  MOVF   x42,W
09F8:  MOVWF  01
.................... }  
09FA:  MOVLB  0
09FC:  RETLW  00
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: crc8  
.................... // Description: Calculate an 8-bit crc over an array of chars.   
.................... //  Interface definition for 8-bit CRC (cyclic redundancy check):  
.................... //     Polynomial:                 1D  
.................... //     Initial CRC register value: FF  
.................... //     Reflected input and output: No  
.................... //     Inverted final output:      Yes  
.................... //     CRC of string "123456789":  4B  
.................... // Parameters: buffer - char array to compute crc.  
.................... //  count - size of array  
.................... // Output Parameters:  
.................... // Return Values: computed crc  
.................... //------------------------------------------------------------------------------  
.................... int8 crc8(int8* buffer, int8 count)  
.................... {  
....................     int8 crc = 0xFF;  
*
0AF2:  MOVLW  FF
0AF4:  MOVLB  2
0AF6:  MOVWF  x4B
....................     int8 value;   
....................     int i;  
....................   
....................     while (count--) {  
0AF8:  MOVF   x4A,W
0AFA:  DECF   x4A,F
0AFC:  XORLW  00
0AFE:  BTFSC  FD8.2
0B00:  GOTO   0B4E
....................         value = *buffer++;  
0B04:  MOVF   x49,W
0B06:  MOVWF  03
0B08:  MOVF   x48,W
0B0A:  INCF   x48,F
0B0C:  BTFSC  FD8.2
0B0E:  INCF   x49,F
0B10:  MOVWF  FE9
0B12:  MOVLB  0
0B14:  MOVFF  03,FEA
0B18:  MOVF   FEF,W
0B1A:  MOVLB  2
0B1C:  MOVWF  x4C
....................   
....................         crc ^= (value << 0);  
0B1E:  MOVF   x4C,W
0B20:  XORWF  x4B,F
....................         for (i = 0; i < 8; i++) {  
0B22:  CLRF   x4D
0B24:  MOVF   x4D,W
0B26:  SUBLW  07
0B28:  BTFSS  FD8.0
0B2A:  GOTO   0B4A
....................             if (crc & 0x80) {  
0B2E:  BTFSS  x4B.7
0B30:  GOTO   0B40
....................                 crc = (crc << 1) ^ 0x1D;  
0B34:  BCF    FD8.0
0B36:  RLCF   x4B,W
0B38:  XORLW  1D
0B3A:  MOVWF  x4B
....................             }  
....................             else {  
0B3C:  GOTO   0B44
....................                 crc <<= 1;  
0B40:  BCF    FD8.0
0B42:  RLCF   x4B,F
....................             }  
....................         }  
0B44:  INCF   x4D,F
0B46:  GOTO   0B24
....................     }  
0B4A:  GOTO   0AF8
....................     return crc ^ 0xFF;  
0B4E:  MOVF   x4B,W
0B50:  XORLW  FF
0B52:  MOVWF  01
.................... }  
0B54:  MOVLB  0
0B56:  RETLW  00
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: crc8  
.................... // Description: Extract binary long packed into a string and return a 32 bit  
.................... //	integer number. String is packed MSB first.  
.................... // Parameters: str - string must be at least 4 bytes long.  
.................... // Output Parameters:  
.................... // Return Values: extracted int32 number from string.  
.................... //------------------------------------------------------------------------------  
.................... int32 StrToInt32(int8* str)  
.................... {  
.................... 	int32 l;  
....................     l = (int32)str[0] << 24;  
*
24A0:  MOVLB  2
24A2:  MOVF   x10,W
24A4:  MOVWF  FE9
24A6:  MOVF   x11,W
24A8:  MOVWF  FEA
24AA:  MOVF   FEF,W
24AC:  CLRF   x19
24AE:  CLRF   x18
24B0:  CLRF   x17
24B2:  MOVWF  x16
24B4:  MOVLB  0
24B6:  MOVFF  216,215
24BA:  MOVLB  2
24BC:  CLRF   x12
24BE:  CLRF   x13
24C0:  CLRF   x14
....................     l |= (int32)str[1] << 16;  
24C2:  MOVLW  01
24C4:  ADDWF  x10,W
24C6:  MOVWF  FE9
24C8:  MOVLW  00
24CA:  ADDWFC x11,W
24CC:  MOVWF  FEA
24CE:  MOVF   FEF,W
24D0:  CLRF   x19
24D2:  CLRF   x18
24D4:  CLRF   x17
24D6:  MOVWF  x16
24D8:  MOVLB  0
24DA:  CLRF   00
24DC:  CLRF   01
24DE:  MOVF   00,W
24E0:  MOVLB  2
24E2:  IORWF  x12,F
24E4:  MOVF   01,W
24E6:  IORWF  x13,F
24E8:  MOVF   x16,W
24EA:  IORWF  x14,F
24EC:  MOVF   x17,W
24EE:  IORWF  x15,F
....................     l |= (int16)str[2] << 8;  
24F0:  MOVLW  02
24F2:  ADDWF  x10,W
24F4:  MOVWF  FE9
24F6:  MOVLW  00
24F8:  ADDWFC x11,W
24FA:  MOVWF  FEA
24FC:  MOVF   FEF,W
24FE:  CLRF   x17
2500:  MOVWF  x16
2502:  MOVLB  0
2504:  MOVLW  00
2506:  MOVLB  2
2508:  IORWF  x12,F
250A:  MOVF   x16,W
250C:  IORWF  x13,F
....................     l |= str[3];  
250E:  MOVLW  03
2510:  ADDWF  x10,W
2512:  MOVWF  FE9
2514:  MOVLW  00
2516:  ADDWFC x11,W
2518:  MOVWF  FEA
251A:  MOVF   FEF,W
251C:  IORWF  x12,F
.................... 	return l;  
251E:  MOVLB  0
2520:  MOVFF  212,00
2524:  MOVFF  213,01
2528:  MOVFF  214,02
252C:  MOVFF  215,03
.................... }  
2530:  RETLW  00
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: Decrypt  
.................... // Description: Decrypt a single byte using a LFSR (linear feedback shift   
.................... //  register).   
.................... // Parameters: cc - encrypted character to decrypt  
.................... // Output Paramters:   
.................... // Return Values: The decrypted character  
.................... //------------------------------------------------------------------------------  
.................... int8 Decrypt(int8 cc)  
.................... {  
.................... /*    int8 cBit;  
....................   
....................     // update LFSR  
....................     cBit = gLfsr & 1;  
....................     gLfsr >>= 1;  
....................   
....................     if (cBit)  
....................       gLfsr ^= LFSR_MASK;  
....................   
....................     // Decrypt byte  
....................     gLast ^= cc ^ (int8)gLfsr ^ (int8)(gLfsr >> 8);  
....................     return gLast;				// return 'Last' which is current character*/  
.................... }  
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: DecryptBlock  
.................... // Description: Decrypt BLOCK_SIZE string of characters. The first two bytes  
.................... //  of the string is the initial Lfsr value. The Lfsr can't be 0. Starting with   
.................... //  the 3rd inbuf byte is the encrypted data.   
.................... // Parameters: inbuf - encrypted string padded with the Lfsr initial value padded  
.................... //  into the first two bytes.  
.................... // Output Paramters: outbfr - the decrypted string minus the two pad bytes.  
.................... // Return Values: The decrypted character  
.................... //------------------------------------------------------------------------------  
.................... void DecryptBlock(int8 *outbfr, int8 *inbfr)  
.................... {  
....................     int8 size = BLOCK_SIZE;  
....................     int8 last = 0;  
....................     int8 cBit;  
....................   
....................     gLfsr = *inbfr++ << 8;  
....................     gLfsr |= *inbfr++;  
....................     last = 0;  
....................   
.................... //    while (size-- > 0)  
.................... //        *outbfr++ = Decrypt(*inbfr++);   
....................    while (size-- > 0)  
....................    {  
....................        cBit = gLfsr & 1;  
....................        gLfsr >>= 1;  
....................   
....................        if (cBit)  
....................           gLfsr ^= LFSR_MASK;  
....................   
....................        // Decrypt byte  
....................        last ^= *inbfr++ ^ (unsigned char)gLfsr ^ (unsigned char)(gLfsr >> 8);  
....................        *outbfr++ = last;  
....................    }  
.................... }  
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: TraceStr  
.................... // Description: Send string to the debug output UART.  
.................... // Parameters: pMsg - char array to send to port.   
.................... //  size - size of array  
.................... // Output Parameters:  
.................... // Return Values:  
.................... //------------------------------------------------------------------------------  
.................... #ifdef DEBUG  
.................... void TraceStr(int8* pMsg, int8 size)  
.................... {  
....................     while(size--)  
....................     {  
....................         fputc(*pMsg++, STREAM_DEBUG);  
....................         delay_ms(1);  
....................     }  
.................... }  
.................... #endif  
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: Trace  
.................... // Description: Send a byte to the debug output UART.  
.................... // Parameters: msg - char to send to port.   
.................... // Output Parameters:  
.................... // Return Values:  
.................... //------------------------------------------------------------------------------  
.................... #ifdef DEBUG  
.................... void Trace(int8 msg)  
.................... {  
....................     fputc(msg, STREAM_DEBUG);  
....................     delay_ms(1);  
.................... }  
.................... #endif  
....................   
....................   
....................   
....................   
....................   
....................   
....................   
....................  
....................   
.................... //------------------------------------------------------------------------------  
.................... // Function Name: main  
.................... // Description: C program main entry point.   
.................... // Parameters:   
.................... // Output Parameters:  
.................... // Return Values:   
.................... //------------------------------------------------------------------------------  
.................... void main()  
.................... {  
*
38C0:  CLRF   FF8
38C2:  BCF    FD0.7
38C4:  BSF    0D.7
38C6:  CLRF   FEA
38C8:  CLRF   FE9
38CA:  MOVLW  06
38CC:  MOVWF  FC1
.................... 	gFlags.adapterLocked = TRUE;  
*
39C0:  BSF    18.6
.................... 	gFlags.enableIso5msByteDelay = TRUE;  
39C2:  BSF    19.1
.................... 	gFlags.enableIsoChecksum = TRUE;  
39C4:  BSF    19.2
.................... 	  
....................     init_ports();  
39C6:  MOVLB  0
39C8:  GOTO   07DC
....................   
.................... 	CanDisable();  
39CC:  CALL   0128
....................   
....................     setup_timer_1 ( T1_INTERNAL | T1_DIV_BY_8 );  
39D0:  MOVLW  B5
39D2:  MOVWF  FCD
....................       
....................     setup_adc_ports(RA0_ANALOG);  
39D4:  MOVLW  8E
39D6:  MOVWF  FC1
....................       
.................... 	gDevid1 = read_program_eeprom(DEVID1_ADDR);  
39D8:  MOVLW  3F
39DA:  MOVWF  FF8
39DC:  MOVLW  FF
39DE:  MOVWF  FF7
39E0:  MOVLW  FE
39E2:  MOVWF  FF6
39E4:  TBLRD*+
39E6:  MOVF   FF5,W
39E8:  TBLRD*
39EA:  MOVFF  FF5,03
39EE:  CLRF   FF8
39F0:  MOVWF  16
.................... 	gDevid2 = read_program_eeprom(DEVID2_ADDR);   
39F2:  MOVLW  3F
39F4:  MOVWF  FF8
39F6:  MOVLW  FF
39F8:  MOVWF  FF7
39FA:  MOVWF  FF6
39FC:  TBLRD*+
39FE:  MOVF   FF5,W
3A00:  TBLRD*
3A02:  MOVFF  FF5,03
3A06:  CLRF   FF8
3A08:  MOVWF  17
.................... 	   
.................... 	// on old 18F248 part use the CCS built-in functions to setup ADC  
.................... 	if (gDevid2 == VER_18F248)  
.................... 	{  
3A0A:  MOVF   17,W
3A0C:  SUBLW  08
3A0E:  BTFSS  FD8.2
3A10:  GOTO   3A2E
.................... 		setup_adc(ADC_CLOCK_DIV_64);  
3A14:  BSF    FC1.6
3A16:  MOVF   FC2,W
3A18:  ANDLW  38
3A1A:  IORLW  81
3A1C:  MOVWF  FC2
.................... 		set_adc_channel(0);  
3A1E:  MOVLW  00
3A20:  MOVWF  01
3A22:  MOVF   FC2,W
3A24:  ANDLW  C7
3A26:  IORWF  01,W
3A28:  MOVWF  FC2
.................... 	}  
.................... 	// on new 18F2480 part must setup manually as the ADC registers have changed  
.................... 	else  
.................... 	{		  
3A2A:  GOTO   3A36
.................... 		ADCON2 = 0xAD;  
3A2E:  MOVLW  AD
3A30:  MOVWF  FC0
.................... 		ADCON0 = 0x01;  
3A32:  MOVLW  01
3A34:  MOVWF  FC2
.................... 	}  
....................     	  
.................... 	enable_interrupts(GLOBAL);  
3A36:  MOVLW  C0
3A38:  IORWF  FF2,F
....................     enable_interrupts(INT_RDA);  
3A3A:  BSF    F9D.5
.................... 	enable_interrupts(INT_CANERR);  
3A3C:  BSF    FA3.5
.................... 	enable_interrupts(INT_CANRX1);  
3A3E:  BSF    FA3.1
.................... 	enable_interrupts(INT_CANRX0);  
3A40:  BSF    FA3.0
.................... 	enable_interrupts(INT_CANIRX);  
3A42:  BSF    FA3.7
....................   
....................    	//output_low(PIN_B4);  
....................    	//output_high(PIN_B4);  
.................... 	//TRACE("A"); // send byte to get debug port initialized  
.................... 	  
.................... #ifdef BLUETOOTH  
.................... 	HostInitBluetooth();  
3A44:  GOTO   0864
.................... #endif  
....................   
....................     // forever loop  
....................     while(1)  
....................     {  
.................... 		// if a complete host message arrived  
....................         if (gHostBufCnt >= HOST_RECV_MSG_SIZE)  
....................         {  
3A48:  MOVF   1E,W
3A4A:  SUBLW  0E
3A4C:  BTFSC  FD8.0
3A4E:  GOTO   3A9E
....................             // ensure serial interrupts don't disturb accurate VPW and PWM timing loops  
....................             disable_interrupts(INT_RDA);  
3A52:  BCF    F9D.5
.................... 					     
.................... 			// incase an ISR set an error while adatper was idle, let's clear it  
.................... 			gError = 0;  
3A54:  CLRF   1A
....................   
....................             // if the incoming message parses successfully  
....................             HostParseMsg();  
3A56:  GOTO   09FE
.................... 			  
....................             // send the host's query message to the vehicle  
....................             if (!gError)  
.................... 		    {  
3A5A:  MOVF   1A,F
3A5C:  BTFSS  FD8.2
3A5E:  GOTO   3A6A
....................             	gCurrentCmd = gHostBuf[IDX_HOST_COMMAND];  
3A62:  MOVFF  33,22
....................                 VehSendRecv();  
3A66:  GOTO   3396
.................... 			}  
....................                   
....................             // if error generated, send host error message  
....................             if (gError)  
....................                 HostSendError();  
3A6A:  MOVF   1A,F
3A6C:  BTFSC  FD8.2
3A6E:  GOTO   3A7A
3A72:  GOTO   3668
....................   
.................... 			// else if vehicle data to send, send host vehicle data message  
....................             else if (!IsCmdLocal(gCurrentCmd))  
3A76:  GOTO   3A96
....................                HostSendVehicleData();  
3A7A:  MOVFF  22,210
3A7E:  CALL   0944
3A82:  MOVF   01,F
3A84:  BTFSS  FD8.2
3A86:  GOTO   3A92
3A8A:  GOTO   36E0
....................   
.................... 			// else local data to send, send host local data message  
.................... 			else  
.................... 				HostSendLocalData();  
3A8E:  GOTO   3A96
3A92:  GOTO   381C
....................   
....................             gHostBufCnt = 0;  
3A96:  CLRF   1E
....................           	gLastCmd = gCurrentCmd;  
3A98:  MOVFF  22,23
....................               
....................             // zero all vehicle buffer bytes for next time  
....................             //memset(gVehicleBuf, 0x00, VEHICLE_MAX_MSGS * VEHICLE_MSG_SIZE);  
....................             enable_interrupts(INT_RDA);  
3A9C:  BSF    F9D.5
....................         }  
....................   
....................         // if more than 25mS between chars, reset buf count. Could happen if  
....................         // an incomplete host message is received or host is slow  
....................         disable_interrupts(INT_RDA);  
3A9E:  BCF    F9D.5
....................         if (HstTestTimer(gHostRecvTimeout, HST_TWENTY_FIVE_MS))  
....................             gHostBufCnt = 0;  
3AA0:  MOVFF  20,235
3AA4:  MOVFF  1F,234
3AA8:  MOVLW  3D
3AAA:  MOVLB  2
3AAC:  MOVWF  x37
3AAE:  MOVLW  09
3AB0:  MOVWF  x36
3AB2:  MOVLB  0
3AB4:  CALL   1988
3AB8:  MOVF   01,F
3ABA:  BTFSC  FD8.2
3ABC:  GOTO   3AC2
3AC0:  CLRF   1E
....................         enable_interrupts(INT_RDA);  
3AC2:  BSF    F9D.5
....................     }   
3AC4:  GOTO   3A48
.................... }  
....................  
3AC8:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0C   NOBROWNOUT WDT128 NOWDT BORV20 PUT
   Word  3: 0000  
   Word  4: 0081   STVREN NODEBUG NOLVP
   Word  5: 8000   PROTECT NOCPD CPB
   Word  6: 8000   WRT NOWRTD WRTB WRTC
   Word  7: 0000   EBTR EBTRB
