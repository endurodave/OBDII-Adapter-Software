 //------------------------------------------------------------------------------  A    1 :V17
// File: Main  A    2 :
//  A    3 :
// Purpose: Main module and C entry point main().  A    4 :
//  A    5 :
//  Notes:   A    6 :
//  Software UART in CCS compiler does not implement a stop bit. Therefore  A    7 :
//  you must timeout a stopbit after a putc call. delay_us(500) has worked.   A    8 :
//  A    9 :
//  TODO:   A   10 :
//  1) Make an ISO command that doesn't wait 5mS per char for faster sampling.   A   11 :
//  2) Check all TBDs  A   12 :
//  3) Check that all commands and errors are used/handled.  A   13 :
//  4) Create a security function and message using encryption.  A   14 :
//  5) VW Pass through mode does no bus message filtering??Or maybe just no init?? A   15 :
//  6) PWM needs to send an IFR.  A   16 :
//  A   17 :
// Change History:  A   18 :
// Date		Author		Description  A   19 :
//          Lafreniere	Created  A   20 :
//  A   21 :
// August 12, 2003 - Updated for compatibility with the PIC18F248, for CAN version of product  A   22 :
// Feburary 26, 2005 - Update to add the B0 adapter unlock command  A   23 :
// August 3, 2007 - Update to add DashDyno code, host UART speed increase and EERPOM commands.  A   24 :
// November, 22, 2008 - Updated to add support for Toyota enhanced KWP 9600 mode.  A   25 :
//------------------------------------------------------------------------------  A   26 :
#case       	// make compiler case sensitive  A   27 :
  A   28 :
// define to enable debug code  A   29 :
//#define DEBUG   1     A   30 :
  A   31 :
// define to compile for DashDyno  A   32 :
#define DASH_DYNO  A   33 :
#define BLUETOOTH  A   34 :
  A   35 :
#include <18F248.h> A   36 :
 //////// Standard Header file for the PIC18F248 device ////////////////  B    1 :I1
#device PIC18F248  B    2 :
#nolist  B    3N:X0
//////// Program memory: 8192x16  Data RAM: 768  Stack: 31  B    4N:
//////// I/O: 22   Analog Pins: 5  B    5N:
//////// Data EEPROM: 256  B    6N:
//////// C Scratch area: 00   ID Location: 2000  B    7N:
//////// Fuses: LP,XT,HS,RC,EC,EC_IO,H4,RC_IO,PROTECT,NOPROTECT,OSCSEN  B    8N:
//////// Fuses: NOOSCSEN,NOBROWNOUT,BROWNOUT,WDT1,WDT2,WDT4,WDT8,WDT16,WDT32  B    9N:
//////// Fuses: WDT64,WDT128,WDT,NOWDT,BORV20,BORV27,BORV42,BORV45,PUT,NOPUT  B   10N:
//////// Fuses: CPD,NOCPD,NOSTVREN,STVREN,NODEBUG,DEBUG,NOLVP,LVP,WRT,NOWRT  B   11N:
//////// Fuses: NOWRTD,WRTD,WRTB,NOWRTB,CPB,NOCPB,WRTC,NOWRTC,EBTR,NOEBTR  B   12N:
//////// Fuses: EBTRB,NOEBTRB  B   13N:
////////   B   14N:
////////////////////////////////////////////////////////////////// I/O  B   15N:
// Discrete I/O Functions: SET_TRIS_x(), OUTPUT_x(), INPUT_x(),  B   16N:
//                         PORT_B_PULLUPS(), INPUT(),  B   17N:
//                         OUTPUT_LOW(), OUTPUT_HIGH(),  B   18N:
//                         OUTPUT_FLOAT(), OUTPUT_BIT()  B   19N:
// Constants used to identify pins in the above are:  B   20N:
  B   21N:
#define PIN_A0  31744  B   22N:
#define PIN_A1  31745  B   23N:
#define PIN_A2  31746  B   24N:
#define PIN_A3  31747  B   25N:
#define PIN_A4  31748  B   26N:
#define PIN_A5  31749  B   27N:
  B   28N:
#define PIN_B0  31752  B   29N:
#define PIN_B1  31753  B   30N:
#define PIN_B2  31754  B   31N:
#define PIN_B3  31755  B   32N:
#define PIN_B4  31756  B   33N:
#define PIN_B5  31757  B   34N:
#define PIN_B6  31758  B   35N:
#define PIN_B7  31759  B   36N:
  B   37N:
#define PIN_C0  31760  B   38N:
#define PIN_C1  31761  B   39N:
#define PIN_C2  31762  B   40N:
#define PIN_C3  31763  B   41N:
#define PIN_C4  31764  B   42N:
#define PIN_C5  31765  B   43N:
#define PIN_C6  31766  B   44N:
#define PIN_C7  31767  B   45N:
  B   46N:
////////////////////////////////////////////////////////////////// Useful defines  B   47N:
#define FALSE 0  B   48N:
#define TRUE 1  B   49N:
  B   50N:
#define BYTE int  B   51N:
#define BOOLEAN short int  B   52N:
  B   53N:
#define getc getch  B   54N:
#define fgetc getch  B   55N:
#define getchar getch  B   56N:
#define putc putchar  B   57N:
#define fputc putchar  B   58N:
#define fgets gets  B   59N:
#define fputs puts  B   60N:
  B   61N:
////////////////////////////////////////////////////////////////// Control  B   62N:
// Control Functions:  RESET_CPU(), SLEEP(), RESTART_CAUSE()  B   63N:
// Constants returned from RESTART_CAUSE() are:  B   64N:
  B   65N:
#define WDT_TIMEOUT      4       B   66N:
#define MCLR_FROM_SLEEP  8       B   67N:
#define NORMAL_POWER_UP  12      B   68N:
#define BROWNOUT_RESTART 14      B   69N:
  B   70N:
////////////////////////////////////////////////////////////////// Timer 0  B   71N:
// Timer 0 (AKA RTCC)Functions: SETUP_COUNTERS() or SETUP_TIMER0(),  B   72N:
//                              SET_TIMER0() or SET_RTCC(),  B   73N:
//                              GET_TIMER0() or GET_RTCC()  B   74N:
// Constants used for SETUP_TIMER0() are:  B   75N:
#define RTCC_INTERNAL   0  B   76N:
#define RTCC_EXT_L_TO_H 32  B   77N:
#define RTCC_EXT_H_TO_L 48  B   78N:
  B   79N:
#define RTCC_DIV_1      8  B   80N:
#define RTCC_DIV_2      0  B   81N:
#define RTCC_DIV_4      1  B   82N:
#define RTCC_DIV_8      2  B   83N:
#define RTCC_DIV_16     3  B   84N:
#define RTCC_DIV_32     4  B   85N:
#define RTCC_DIV_64     5  B   86N:
#define RTCC_DIV_128    6  B   87N:
#define RTCC_DIV_256    7  B   88N:
  B   89N:
#define RTCC_OFF        0x80    B   90N:
  B   91N:
#define RTCC_8_BIT      0x40    B   92N:
  B   93N:
// Constants used for SETUP_COUNTERS() are the above  B   94N:
// constants for the 1st param and the following for  B   95N:
// the 2nd param:  B   96N:
  B   97N:
////////////////////////////////////////////////////////////////// WDT  B   98N:
// Watch Dog Timer Functions: SETUP_WDT() or SETUP_COUNTERS() (see above)  B   99N:
//                            RESTART_WDT()  B  100N:
//  B  101N:
#define WDT_ON      0x100     B  102N:
#define WDT_OFF     0         B  103N:
  B  104N:
////////////////////////////////////////////////////////////////// Timer 1  B  105N:
// Timer 1 Functions: SETUP_TIMER_1, GET_TIMER1, SET_TIMER1  B  106N:
// Constants used for SETUP_TIMER_1() are:  B  107N:
//      (or (via |) together constants from each group)  B  108N:
#define T1_DISABLED         0  B  109N:
#define T1_INTERNAL         0x85  B  110N:
#define T1_EXTERNAL         0x87  B  111N:
#define T1_EXTERNAL_SYNC    0x83  B  112N:
  B  113N:
#define T1_CLK_OUT          8  B  114N:
  B  115N:
#define T1_DIV_BY_1         0  B  116N:
#define T1_DIV_BY_2         0x10  B  117N:
#define T1_DIV_BY_4         0x20  B  118N:
#define T1_DIV_BY_8         0x30  B  119N:
  B  120N:
////////////////////////////////////////////////////////////////// Timer 2  B  121N:
// Timer 2 Functions: SETUP_TIMER_2, GET_TIMER2, SET_TIMER2  B  122N:
// Constants used for SETUP_TIMER_2() are:  B  123N:
#define T2_DISABLED         0  B  124N:
#define T2_DIV_BY_1         4  B  125N:
#define T2_DIV_BY_4         5  B  126N:
#define T2_DIV_BY_16        6  B  127N:
  B  128N:
////////////////////////////////////////////////////////////////// Timer 3  B  129N:
// Timer 3 Functions: SETUP_TIMER_3, GET_TIMER3, SET_TIMER3  B  130N:
// Constants used for SETUP_TIMER_3() are:  B  131N:
//      (or (via |) together constants from each group)  B  132N:
#define T3_DISABLED         0  B  133N:
#define T3_INTERNAL         0x85  B  134N:
#define T3_EXTERNAL         0x87  B  135N:
#define T3_EXTERNAL_SYNC    0x83  B  136N:
  B  137N:
#define T3_DIV_BY_1         0  B  138N:
#define T3_DIV_BY_2         0x10  B  139N:
#define T3_DIV_BY_4         0x20  B  140N:
#define T3_DIV_BY_8         0x30  B  141N:
  B  142N:
////////////////////////////////////////////////////////////////// CCP  B  143N:
// CCP Functions: SETUP_CCPx, SET_PWMx_DUTY  B  144N:
// CCP Variables: CCP_x, CCP_x_LOW, CCP_x_HIGH  B  145N:
// Constants used for SETUP_CCPx() are:  B  146N:
#define CCP_OFF                         0  B  147N:
#define CCP_CAPTURE_FE                  4  B  148N:
#define CCP_CAPTURE_RE                  5  B  149N:
#define CCP_CAPTURE_DIV_4               6  B  150N:
#define CCP_CAPTURE_DIV_16              7  B  151N:
#define CCP_COMPARE_SET_ON_MATCH        8  B  152N:
#define CCP_COMPARE_CLR_ON_MATCH        9  B  153N:
#define CCP_COMPARE_INT                 0xA  B  154N:
#define CCP_COMPARE_INT_AND_TOGGLE      0x2         B  155N:
#define CCP_COMPARE_RESET_TIMER         0xB  B  156N:
#define CCP_PWM                         0xC  B  157N:
#define CCP_PWM_PLUS_1                  0x1c  B  158N:
#define CCP_PWM_PLUS_2                  0x2c  B  159N:
#define CCP_PWM_PLUS_3                  0x3c  B  160N:
#define CCP_USE_TIMER3                  0x100         B  161N:
long CCP_1;  B  162N:V18
#byte   CCP_1    =                      0xfbe         B  163N:
#byte   CCP_1_LOW=                      0xfbe         B  164N:
#byte   CCP_1_HIGH=                     0xfbf         B  165N:V19
////////////////////////////////////////////////////////////////// SPI  B  166N:
// SPI Functions: SETUP_SPI, SPI_WRITE, SPI_READ, SPI_DATA_IN  B  167N:
// Constants used in SETUP_SSP() are:  B  168N:
#define SPI_MASTER       0x20  B  169N:
#define SPI_SLAVE        0x24  B  170N:
#define SPI_L_TO_H       0  B  171N:
#define SPI_H_TO_L       0x10  B  172N:
#define SPI_CLK_DIV_4    0  B  173N:
#define SPI_CLK_DIV_16   1  B  174N:
#define SPI_CLK_DIV_64   2  B  175N:
#define SPI_CLK_T2       3  B  176N:
#define SPI_SS_DISABLED  1  B  177N:
  B  178N:
#define SPI_SAMPLE_AT_END 0x8000  B  179N:
#define SPI_XMIT_L_TO_H  0x4000  B  180N:
  B  181N:
////////////////////////////////////////////////////////////////// ADC  B  182N:
// ADC Functions: SETUP_ADC(), SETUP_ADC_PORTS() (aka SETUP_PORT_A),  B  183N:
//                SET_ADC_CHANNEL(), READ_ADC()  B  184N:
// Constants used in SETUP_ADC_PORTS() are:  B  185N:
#define NO_ANALOGS             0x86         // None  B  186N:
#define ALL_ANALOG             0x80         // A0 A1 A2 A3 A5 E0 E1 E2 Ref=Vdd  B  187N:
#define ANALOG_RA3_REF         0x81         // A0 A1 A2 A5 E0 E1 E2 Ref=A3  B  188N:
#define A_ANALOG               0x82         // A0 A1 A2 A3 A5 Ref=Vdd  B  189N:
#define A_ANALOG_RA3_REF       0x83         // A0 A1 A2 A5 Ref=A3  B  190N:
#define RA0_RA1_RA3_ANALOG     0x84         // A0 A1 A3 Ref=Vdd  B  191N:
#define RA0_RA1_ANALOG_RA3_REF 0x85         // A0 A1 Ref=A3  B  192N:
#define ANALOG_RA3_RA2_REF              0x88   // A0 A1 A5 E0 E1 E2 Ref=A2,A3  B  193N:
#define ANALOG_NOT_RE1_RE2              0x89   // A0 A1 A2 A3 A5 E0 Ref=Vdd  B  194N:
#define ANALOG_NOT_RE1_RE2_REF_RA3      0x8A   // A0 A1 A2 A5 E0 Ref=A3  B  195N:
#define ANALOG_NOT_RE1_RE2_REF_RA3_RA2  0x8B   // A0 A1 A5 E0 Ref=A2,A3  B  196N:
#define A_ANALOG_RA3_RA2_REF            0x8C   // A0 A1 A5 Ref=A2,A3  B  197N:
#define RA0_RA1_ANALOG_RA3_RA2_REF      0x8D   // A0 A1 Ref=A2,A3  B  198N:
#define RA0_ANALOG                      0x8E   // A0  B  199N:
#define RA0_ANALOG_RA3_RA2_REF          0x8F   // A0 Ref=A2,A3  B  200N:
// Constants used for SETUP_ADC() are:  B  201N:
#define ADC_OFF                0              // ADC Off  B  202N:
#define ADC_CLOCK_DIV_2        1  B  203N:
#define ADC_CLOCK_DIV_4    0x101    B  204N:
#define ADC_CLOCK_DIV_8     0x41  B  205N:
#define ADC_CLOCK_DIV_16   0x141    B  206N:
#define ADC_CLOCK_DIV_32    0x81  B  207N:
#define ADC_CLOCK_DIV_64   0x181    B  208N:
#define ADC_CLOCK_INTERNAL  0xc1              // Internal 2-6us  B  209N:
  B  210N:
// Constants used in READ_ADC() are:  B  211N:
#define ADC_START_AND_READ     7   // This is the default if nothing is specified  B  212N:
#define ADC_START_ONLY         1  B  213N:
#define ADC_READ_ONLY          6  B  214N:
  B  215N:
////////////////////////////////////////////////////////////////// INT  B  216N:
// Interrupt Functions: ENABLE_INTERRUPTS(), DISABLE_INTERRUPTS(),  B  217N:
//                      EXT_INT_EDGE()  B  218N:
//  B  219N:
// Constants used in EXT_INT_EDGE() are:  B  220N:
#define L_TO_H              0x40  B  221N:
#define H_TO_L                 0  B  222N:
// Constants used in ENABLE/DISABLE_INTERRUPTS() are:  B  223N:
#define GLOBAL                    0xF2C0  B  224N:
#define INT_RTCC                  0xF220  B  225N:
#define INT_TIMER0                0xF220  B  226N:
#define INT_TIMER1                0x9D01  B  227N:
#define INT_TIMER2                0x9D02  B  228N:
#define INT_TIMER3                0xA002  B  229N:
#define INT_EXT                   0xF210  B  230N:
#define INT_EXT1                  0xF008  B  231N:
#define INT_EXT2                  0xF010  B  232N:
#define INT_RB                    0xF208  B  233N:
#define INT_AD                    0x9D40  B  234N:
#define INT_RDA                   0x9D20  B  235N:
#define INT_TBE                   0x9D10  B  236N:
#define INT_SSP                   0x9D08  B  237N:
#define INT_CCP1                  0x9D04  B  238N:
#define INT_BUSCOL                0xA008  B  239N:
#define INT_LOWVOLT               0xA004  B  240N:
#define INT_CANIRX                0xA380  B  241N:
#define INT_CANWAKE               0xA340  B  242N:
#define INT_CANERR                0xA320  B  243N:
#define INT_EEPROM                0xA010  B  244N:
#define INT_TBE0                  0xA304  B  245N:
#define INT_TBE1                  0xA308  B  246N:
#define INT_TBE2                  0xA310  B  247N:
#define INT_RDA0                  0xA301  B  248N:
#define INT_RDA1                  0xA302  B  249N:
#define INT_CANTX2                0xA310  B  250N:
#define INT_CANTX1                0xA308  B  251N:
#define INT_CANTX0                0xA304  B  252N:
#define INT_CANRX1                0xA302  B  253N:
#define INT_CANRX0                0xA301  B  254N:
  B  255N:
#list  B  256 :X1E
 B  256 :
#device ADC=10  // setup A/D for 10 bits  A   37 :
  A   38 :
#include "a_18F248.h" A   39 :
 #ifndef _18F248_H  C    1 :I2
#define _18F248_H  C    2 :
  C    3 :
#NOLIST  C    4N:X0
  C    5N:
// This header file defines configurations, registers, and other useful bits of  C    6N:
// information for the PIC18F248 microcontroller.  These names are taken to match   C    7N:
// the data sheets as closely as possible.    C    8N:
//  C    9N:
//==========================================================================  C   10N:
//  C   11N:
//       Revision History  C   12N:
//  C   13N:
//==========================================================================  C   14N:
//Rev:   Date:        Details:                                         Who:  C   15N:
//0.90  15 May 2001   Preliminary Release                               dzb  C   16N:
//0.99  29 June2001   Rev 1                                             dzb  C   17N:
//1.00  29 Oct.2001   Corrections & Additions			       cjh  C   18N:
//1.10  25 Jun 2002   Added CFGS as EECON1 bit 6 name                   pas   C   19N:
//1.20  29 Jul 2003   Converted to operate with the CCS compiler		Bernie Lafreniere  C   20N:
//1.30  09 Mar 2004   Modified to operate with CCS						David Lafreniere  C   21N:
//  C   22N:
//==========================================================================  C   23N:
//       18Fxxx Family        Defines  C   24N:
//==========================================================================  C   25N:
  C   26N:
#define FSR0             0  C   27N:
#define FSR1             1  C   28N:
#define FSR2             2  C   29N:
  C   30N:
#define FAST             1  C   31N:
  C   32N:
#define W                0  C   33N:
#define A                0  C   34N:
#define ACCESS           0  C   35N:
#define BANKED		     1  C   36N:
  C   37N:
//==========================================================================  C   38N:
//       16Cxxx/17Cxxx Substitutions  C   39N:
//==========================================================================  C   40N:
  C   41N:
  #define clrw clrf WREG       // PIC16Cxxx code substitution (WREG is addressable)  C   42N:
  #define CLRW CLRF WREG       // PIC16Cxxx code substitution (WREG is addressable)  C   43N:
  #define negw negf WREG       // PIC16Cxxx code substitution (WREG is addressable)  C   44N:
  #define NEGW NEGF WREG       // PIC16Cxxx code substitution (WREG is addressable)  C   45N:
  C   46N:
//==========================================================================  C   47N:
//  C   48N:
//       Register Definitions  C   49N:
//  C   50N:
//==========================================================================  C   51N:
  C   52N:
//----- Register Files -----------------------------------------------------  C   53N:
#byte TOSU              = 0x0FFF  C   54N:V20
#byte TOSH              = 0x0FFE  C   55N:V21
#byte TOSL              = 0x0FFD  C   56N:V22
#byte STKPTR            = 0x0FFC  C   57N:V23
#byte PCLATU            = 0x0FFB  C   58N:V24
#byte PCLATH            = 0x0FFA  C   59N:V25
#byte PCL               = 0x0FF9  C   60N:V26
#byte TBLPTRU           = 0x0FF8  C   61N:V27
#byte TBLPTRH           = 0x0FF7  C   62N:V28
#byte TBLPTRL           = 0x0FF6  C   63N:V29
#byte TABLAT            = 0x0FF5  C   64N:V30
#byte PRODH             = 0x0FF4  C   65N:V31
#byte PRODL             = 0x0FF3  C   66N:V32
  C   67N:
#byte INTCON            = 0x0FF2  C   68N:V33
#byte INTCON1           = 0x0FF2  C   69N:V34
#byte INTCON2           = 0x0FF1  C   70N:V35
#byte INTCON3           = 0x0FF0  C   71N:V36
  C   72N:
#byte INDF0             = 0x0FEF  C   73N:V37
#byte POSTINC0          = 0x0FEE  C   74N:V38
#byte POSTDEC0          = 0x0FED  C   75N:V39
#byte PREINC0           = 0x0FEC  C   76N:V40
#byte PLUSW0            = 0x0FEB  C   77N:V41
#byte FSR0H             = 0x0FEA  C   78N:V42
#byte FSR0L             = 0x0FE9  C   79N:V43
#byte WREG              = 0x0FE8  C   80N:V44
  C   81N:
#byte INDF1             = 0x0FE7  C   82N:V45
#byte POSTINC1          = 0x0FE6  C   83N:V46
#byte POSTDEC1          = 0x0FE5  C   84N:V47
#byte PREINC1           = 0x0FE4  C   85N:V48
#byte PLUSW1            = 0x0FE3  C   86N:V49
#byte FSR1H             = 0x0FE2  C   87N:V50
#byte FSR1L             = 0x0FE1  C   88N:V51
#byte BSR               = 0x0FE0  C   89N:V52
  C   90N:
#byte INDF2             = 0x0FDF  C   91N:V53
#byte POSTINC2          = 0x0FDE  C   92N:V54
#byte POSTDEC2          = 0x0FDD  C   93N:V55
#byte PREINC2           = 0x0FDC  C   94N:V56
#byte PLUSW2            = 0x0FDB  C   95N:V57
#byte FSR2H             = 0x0FDA  C   96N:V58
#byte FSR2L             = 0x0FD9  C   97N:V59
#byte STATUS            = 0x0FD8  C   98N:V60
  C   99N:
#byte TMR0H             = 0x0FD7  C  100N:V61
#byte TMR0L             = 0x0FD6  C  101N:V62
#byte T0CON             = 0x0FD5  C  102N:V63
  C  103N:
//RESERVED_0FD4     0x0FD4  C  104N:
  C  105N:
#byte OSCCON            = 0x0FD3  C  106N:V64
#byte LVDCON            = 0x0FD2  C  107N:V65
#byte WDTCON            = 0x0FD1  C  108N:V66
#byte RCON              = 0x0FD0  C  109N:V67
  C  110N:
#byte TMR1H             = 0x0FCF  C  111N:V68
#byte TMR1L             = 0x0FCE  C  112N:V69
#byte T1CON             = 0x0FCD  C  113N:V70
#byte TMR2              = 0x0FCC  C  114N:V71
#byte PR2               = 0x0FCB  C  115N:V72
#byte T2CON             = 0x0FCA  C  116N:V73
  C  117N:
#byte SSPBUF            = 0x0FC9  C  118N:V74
#byte SSPADD            = 0x0FC8  C  119N:V75
#byte SSPSTAT           = 0x0FC7  C  120N:V76
#byte SSPCON1           = 0x0FC6  C  121N:V77
#byte SSPCON2           = 0x0FC5  C  122N:V78
  C  123N:
#byte ADRESH            = 0x0FC4  C  124N:V79
#byte ADRESL            = 0x0FC3  C  125N:V80
#byte ADCON0            = 0x0FC2  C  126N:V81
#byte ADCON1            = 0x0FC1  C  127N:V82
#byte ADCON2            = 0x0FC0  C  128N:V83
  C  129N:
#byte CCPR1H            = 0x0FBF  C  130N:V84
#byte CCPR1L            = 0x0FBE  C  131N:V85
#byte CCP1CON           = 0x0FBD  C  132N:V86
#byte ECCPR1H           = 0x0FBC  C  133N:V87
#byte ECCPR1L           = 0x0FBB  C  134N:V88
#byte ECCP1CON          = 0x0FBA  C  135N:V89
  C  136N:
#byte ECCP1DEL          = 0x0FB7  C  137N:V90
#byte ECCPAS            = 0x0FB6  C  138N:V91
#byte CVRCON            = 0x0FB5  C  139N:V92
#byte CMCON             = 0x0FB4  C  140N:V93
  C  141N:
#byte TMR3H             = 0x0FB3  C  142N:V94
#byte TMR3L             = 0x0FB2  C  143N:V95
#byte T3CON             = 0x0FB1  C  144N:V96
  C  145N:
#byte PSPCON            = 0x0FB0  C  146N:V97
  C  147N:
#byte SPBRG             = 0x0FAF  C  148N:V98
#byte RCREG             = 0x0FAE  C  149N:V99
#byte TXREG             = 0x0FAD  C  150N:V100
#byte TXSTA             = 0x0FAC  C  151N:V101
#byte RCSTA             = 0x0FAB  C  152N:V102
  C  153N:
#byte EEADR             = 0x0FA9  C  154N:V103
#byte EEDATA            = 0x0FA8  C  155N:V104
#byte EECON2            = 0x0FA7  C  156N:V105
#byte EECON1            = 0x0FA6  C  157N:V106
#byte IPR3              = 0x0FA5  C  158N:V107
#byte PIR3              = 0x0FA4  C  159N:V108
#byte PIE3              = 0x0FA3  C  160N:V109
  C  161N:
#byte IPR2              = 0x0FA2  C  162N:V110
#byte PIR2              = 0x0FA1  C  163N:V111
#byte PIE2              = 0x0FA0  C  164N:V112
#byte IPR1              = 0x0F9F  C  165N:V113
#byte PIR1              = 0x0F9E  C  166N:V114
#byte PIE1              = 0x0F9D  C  167N:V115
  C  168N:
#byte TRISC             = 0x0F94  C  169N:V116
#byte TRISB             = 0x0F93  C  170N:V117
#byte TRISA             = 0x0F92  C  171N:V118
  C  172N:
#byte LATC              = 0x0F8B  C  173N:V119
#byte LATB              = 0x0F8A  C  174N:V120
#byte LATA              = 0x0F89  C  175N:V121
  C  176N:
#byte PORTC             = 0x0F82  C  177N:V122
#byte PORTB             = 0x0F81  C  178N:V123
#byte PORTA             = 0x0F80  C  179N:V124
  C  180N:
#byte TXERRCNT          = 0x0F76  C  181N:V125
#byte RXERRCNT          = 0x0F75  C  182N:V126
#byte COMSTAT           = 0x0F74  C  183N:V127
#byte CIOCON            = 0x0F73  C  184N:V128
#byte BRGCON3           = 0x0F72  C  185N:V129
#byte BRGCON2           = 0x0F71  C  186N:V130
#byte BRGCON1           = 0x0F70  C  187N:V131
  C  188N:
#byte CANCON            = 0x0F6F  C  189N:V132
#byte CANSTAT           = 0x0F6E  C  190N:V133
#byte RXB0D7            = 0x0F6D  C  191N:V134
#byte RXB0D6            = 0x0F6C  C  192N:V135
#byte RXB0D5            = 0x0F6B  C  193N:V136
#byte RXB0D4            = 0x0F6A  C  194N:V137
#byte RXB0D3            = 0x0F69  C  195N:V138
#byte RXB0D2            = 0x0F68  C  196N:V139
#byte RXB0D1            = 0x0F67  C  197N:V140
#byte RXB0D0            = 0x0F66  C  198N:V141
#byte RXB0DLC           = 0x0F65  C  199N:V142
#byte RXB0EIDL          = 0x0F64  C  200N:V143
#byte RXB0EIDH          = 0x0F63  C  201N:V144
#byte RXB0SIDL          = 0x0F62  C  202N:V145
#byte RXB0SIDH          = 0x0F61  C  203N:V146
#byte RXB0CON           = 0x0F60  C  204N:V147
  C  205N:
#byte CANSTATRO1        = 0x0F5E  C  206N:V148
#byte RXB1D7            = 0x0F5D  C  207N:V149
#byte RXB1D6            = 0x0F5C  C  208N:V150
#byte RXB1D5            = 0x0F5B  C  209N:V151
#byte RXB1D4            = 0x0F5A  C  210N:V152
#byte RXB1D3            = 0x0F59  C  211N:V153
#byte RXB1D2            = 0x0F58  C  212N:V154
#byte RXB1D1            = 0x0F57  C  213N:V155
#byte RXB1D0            = 0x0F56  C  214N:V156
#byte RXB1DLC           = 0x0F55  C  215N:V157
#byte RXB1EIDL          = 0x0F54  C  216N:V158
#byte RXB1EIDH          = 0x0F53  C  217N:V159
#byte RXB1SIDL          = 0x0F52  C  218N:V160
#byte RXB1SIDH          = 0x0F51  C  219N:V161
#byte RXB1CON           = 0x0F50  C  220N:V162
  C  221N:
#byte CANSTATRO2        = 0x0F4E  C  222N:V163
#byte TXB0D7            = 0x0F4D  C  223N:V164
#byte TXB0D6            = 0x0F4C  C  224N:V165
#byte TXB0D5            = 0x0F4B  C  225N:V166
#byte TXB0D4            = 0x0F4A  C  226N:V167
#byte TXB0D3            = 0x0F49  C  227N:V168
#byte TXB0D2            = 0x0F48  C  228N:V169
#byte TXB0D1            = 0x0F47  C  229N:V170
#byte TXB0D0            = 0x0F46  C  230N:V171
#byte TXB0DLC           = 0x0F45  C  231N:V172
#byte TXB0EIDL          = 0x0F44  C  232N:V173
#byte TXB0EIDH          = 0x0F43  C  233N:V174
#byte TXB0SIDL          = 0x0F42  C  234N:V175
#byte TXB0SIDH          = 0x0F41  C  235N:V176
#byte TXB0CON           = 0x0F40  C  236N:V177
  C  237N:
#byte CANSTATRO3        = 0x0F3E  C  238N:V178
#byte TXB1D7            = 0x0F3D  C  239N:V179
#byte TXB1D6            = 0x0F3C  C  240N:V180
#byte TXB1D5            = 0x0F3B  C  241N:V181
#byte TXB1D4            = 0x0F3A  C  242N:V182
#byte TXB1D3            = 0x0F39  C  243N:V183
#byte TXB1D2            = 0x0F38  C  244N:V184
#byte TXB1D1            = 0x0F37  C  245N:V185
#byte TXB1D0            = 0x0F36  C  246N:V186
#byte TXB1DLC           = 0x0F35  C  247N:V187
#byte TXB1EIDL          = 0x0F34  C  248N:V188
#byte TXB1EIDH          = 0x0F33  C  249N:V189
#byte TXB1SIDL          = 0x0F32  C  250N:V190
#byte TXB1SIDH          = 0x0F31  C  251N:V191
#byte TXB1CON           = 0x0F30  C  252N:V192
  C  253N:
#byte CANSTATRO4        = 0x0F2E  C  254N:V193
#byte TXB2D7            = 0x0F2D  C  255N:V194
#byte TXB2D6            = 0x0F2C  C  256N:V195
#byte TXB2D5            = 0x0F2B  C  257N:V196
#byte TXB2D4            = 0x0F2A  C  258N:V197
#byte TXB2D3            = 0x0F29  C  259N:V198
#byte TXB2D2            = 0x0F28  C  260N:V199
#byte TXB2D1            = 0x0F27  C  261N:V200
#byte TXB2D0            = 0x0F26  C  262N:V201
#byte TXB2DLC           = 0x0F25  C  263N:V202
#byte TXB2EIDL          = 0x0F24  C  264N:V203
#byte TXB2EIDH          = 0x0F23  C  265N:V204
#byte TXB2SIDL          = 0x0F22  C  266N:V205
#byte TXB2SIDH          = 0x0F21  C  267N:V206
#byte TXB2CON           = 0x0F20  C  268N:V207
  C  269N:
#byte RXM1EIDL          = 0x0F1F  C  270N:V208
#byte RXM1EIDH          = 0x0F1E  C  271N:V209
#byte RXM1SIDL          = 0x0F1D  C  272N:V210
#byte RXM1SIDH          = 0x0F1C  C  273N:V211
  C  274N:
#byte RXM0EIDL          = 0x0F1B  C  275N:V212
#byte RXM0EIDH          = 0x0F1A  C  276N:V213
#byte RXM0SIDL          = 0x0F19  C  277N:V214
#byte RXM0SIDH          = 0x0F18  C  278N:V215
  C  279N:
#byte RXF5EIDL          = 0x0F17  C  280N:V216
#byte RXF5EIDH          = 0x0F16  C  281N:V217
#byte RXF5SIDL          = 0x0F15  C  282N:V218
#byte RXF5SIDH          = 0x0F14  C  283N:V219
  C  284N:
#byte RXF4EIDL          = 0x0F13  C  285N:V220
#byte RXF4EIDH          = 0x0F12  C  286N:V221
#byte RXF4SIDL          = 0x0F11  C  287N:V222
#byte RXF4SIDH          = 0x0F10  C  288N:V223
  C  289N:
#byte RXF3EIDL          = 0x0F0F  C  290N:V224
#byte RXF3EIDH          = 0x0F0E  C  291N:V225
#byte RXF3SIDL          = 0x0F0D  C  292N:V226
#byte RXF3SIDH          = 0x0F0C  C  293N:V227
  C  294N:
#byte RXF2EIDL          = 0x0F0B  C  295N:V228
#byte RXF2EIDH          = 0x0F0A  C  296N:V229
#byte RXF2SIDL          = 0x0F09  C  297N:V230
#byte RXF2SIDH          = 0x0F08  C  298N:V231
  C  299N:
#byte RXF1EIDL          = 0x0F07  C  300N:V232
#byte RXF1EIDH          = 0x0F06  C  301N:V233
#byte RXF1SIDL          = 0x0F05  C  302N:V234
#byte RXF1SIDH          = 0x0F04  C  303N:V235
  C  304N:
#byte RXF0EIDL          = 0x0F03  C  305N:V236
#byte RXF0EIDH          = 0x0F02  C  306N:V237
#byte RXF0SIDL          = 0x0F01  C  307N:V238
#byte RXF0SIDH          = 0x0F00  C  308N:V239
  C  309N:
//----- STKPTR Bits --------------------------------------------------------  C  310N:
#define STKFUL            0x0007  C  311N:
#define STKUNF            0x0006  C  312N:
#define SP4	         	0x0004  C  313N:
#define SP3	          	0x0003  C  314N:
#define SP2	          	0x0002  C  315N:
#define SP1	         	 0x0001  C  316N:
#define SP0	         	 0x0000  C  317N:
  C  318N:
//----- INTCON Bits --------------------------------------------------------  C  319N:
#define GIE               0x0007  C  320N:
#define GIEH              0x0007  C  321N:
#define PEIE              0x0006  C  322N:
#define GIEL              0x0006  C  323N:
#define TMR0IE            0x0005  C  324N:
#define T0IE              0x0005      // For backward compatibility  C  325N:
#define INT0IE            0x0004  C  326N:
#define INT0E             0x0004      // For backward compatibility  C  327N:
#define RBIE              0x0003  C  328N:
#define TMR0IF            0x0002  C  329N:
#define T0IF              0x0002      // For backward compatibility  C  330N:
#define INT0IF            0x0001  C  331N:
#define INT0F             0x0001      // For backward compatibility  C  332N:
#define RBIF              0x0000  C  333N:
  C  334N:
//----- INTCON2 Bits --------------------------------------------------------  C  335N:
#define NOT_RBPU          0x0007  C  336N:
#define RBPU              0x0007  C  337N:
#define INTEDG0           0x0006  C  338N:
#define INTEDG1           0x0005  C  339N:
#define TMR0IP            0x0002  C  340N:
#define T0IP              0x0002      // For compatibility with T0IE and T0IF  C  341N:
#define RBIP              0x0000  C  342N:
  C  343N:
//----- INTCON3 Bits --------------------------------------------------------  C  344N:
#define INT2IP		  0x0007  C  345N:
#define INT2P		  0x0007  C  346N:
#define INT1IP            0x0006  C  347N:
#define INT1P             0x0006  C  348N:
#define INT2IE		  0x0004  C  349N:
#define INT2E		  0x0004  C  350N:
#define INT1IE            0x0003  C  351N:
#define INT1E             0x0003  C  352N:
#define INT2IF		  0x0001  C  353N:
#define INT2F		  0x0001  C  354N:
#define INT1IF            0x0000  C  355N:
#define INT1F             0x0000  C  356N:
  C  357N:
//----- STATUS Bits --------------------------------------------------------  C  358N:
#define N                 0x0004  C  359N:
#define OV                0x0003  C  360N:
#define Z                 0x0002  C  361N:
#define DC                0x0001  C  362N:
#define C                 0x0000  C  363N:
  C  364N:
//----- T0CON Bits ---------------------------------------------------------  C  365N:
#define TMR0ON            0x0007  C  366N:
#define T08BIT            0x0006  C  367N:
#define T0CS              0x0005  C  368N:
#define T0SE              0x0004  C  369N:
#define PSA               0x0003  C  370N:
#define T0PS2             0x0002  C  371N:
#define T0PS1             0x0001  C  372N:
#define T0PS0             0x0000  C  373N:
  C  374N:
//----- OSCCON Bits ---------------------------------------------------------  C  375N:
#define SCS               0x0000  C  376N:
  C  377N:
//----- LVDCON Bits ---------------------------------------------------------  C  378N:
#define IVRST             0x0005  C  379N:
#define LVDEN             0x0004  C  380N:
#define LVDL3             0x0003  C  381N:
#define LVDL2             0x0002  C  382N:
#define LVDL1             0x0001  C  383N:
#define LVDL0             0x0000  C  384N:
  C  385N:
//----- WDTCON Bits ---------------------------------------------------------  C  386N:
#define SWDTE             0x0000  C  387N:
#define SWDTEN            0x0000  C  388N:
  C  389N:
//----- RCON Bits -----------------------------------------------------------  C  390N:
#define IPEN              0x0007  C  391N:
#define NOT_RI            0x0004  C  392N:
#define RI                0x0004  C  393N:
#define NOT_TO            0x0003  C  394N:
#define TO                0x0003  C  395N:
#define NOT_PD            0x0002  C  396N:
#define PD                0x0002  C  397N:
#define NOT_POR           0x0001  C  398N:
#define POR               0x0001  C  399N:
#define NOT_BOR           0x0000  C  400N:
#define BOR               0x0000  C  401N:
  C  402N:
//----- T1CON Bits ---------------------------------------------------------  C  403N:
#define RD16              0x0007  C  404N:
#define T1CKPS1           0x0005  C  405N:
#define T1CKPS0           0x0004  C  406N:
#define T1OSCEN           0x0003  C  407N:
#define NOT_T1SYNC        0x0002  C  408N:
#define T1SYNC            0x0002  C  409N:
#define T1INSYNC          0x0002    // Backward compatibility only  C  410N:
#define TMR1CS            0x0001  C  411N:
#define TMR1ON            0x0000  C  412N:
  C  413N:
//----- T2CON Bits ---------------------------------------------------------  C  414N:
#define TOUTPS3           0x0006  C  415N:
#define TOUTPS2           0x0005  C  416N:
#define TOUTPS1           0x0004  C  417N:
#define TOUTPS0           0x0003  C  418N:
#define TMR2ON            0x0002  C  419N:
#define T2CKPS1           0x0001  C  420N:
#define T2CKPS0           0x0000  C  421N:
  C  422N:
//----- SSPSTAT Bits -------------------------------------------------------  C  423N:
#define SMP               0x0007  C  424N:
#define CKE               0x0006  C  425N:
#define D                 0x0005  C  426N:
#define I2C_DAT           0x0005  C  427N:
#define NOT_A             0x0005  C  428N:
#define NOT_ADDRESS       0x0005  C  429N:
#define D_A               0x0005  C  430N:
#define DATA_ADDRESS      0x0005  C  431N:
#define P                 0x0004  C  432N:
#define I2C_STOP          0x0004  C  433N:
#define S                 0x0003  C  434N:
#define I2C_START         0x0003  C  435N:
#define R                 0x0002  C  436N:
#define I2C_READ          0x0002  C  437N:
#define NOT_W             0x0002  C  438N:
#define NOT_WRITE         0x0002  C  439N:
#define R_W               0x0002  C  440N:
#define READ_WRITE        0x0002  C  441N:
#define UA                0x0001  C  442N:
#define BF                0x0000  C  443N:
  C  444N:
//----- SSPCON1 Bits --------------------------------------------------------  C  445N:
#define WCOL              0x0007  C  446N:
#define SSPOV             0x0006  C  447N:
#define SSPEN             0x0005  C  448N:
#define CKP               0x0004  C  449N:
#define SSPM3             0x0003  C  450N:
#define SSPM2             0x0002  C  451N:
#define SSPM1             0x0001  C  452N:
#define SSPM0             0x0000  C  453N:
  C  454N:
//----- SSPCON2 Bits --------------------------------------------------------  C  455N:
#define GCEN              0x0007  C  456N:
#define ACKSTAT           0x0006  C  457N:
#define ACKDT             0x0005  C  458N:
#define ACKEN             0x0004  C  459N:
#define RCEN              0x0003  C  460N:
#define PEN               0x0002  C  461N:
#define RSEN              0x0001  C  462N:
#define SEN               0x0000  C  463N:
  C  464N:
//----- ADCON0 Bits --------------------------------------------------------  C  465N:
#define ADCS1             0x0007  C  466N:
#define ADCS0             0x0006  C  467N:
#define CHS2              0x0005  C  468N:
#define CHS1              0x0004  C  469N:
#define CHS0              0x0003  C  470N:
#define GO                0x0002  C  471N:
#define NOT_DONE          0x0002  C  472N:
#define DONE              0x0002  C  473N:
#define GO_DONE           0x0002  C  474N:
#define ADON              0x0000  C  475N:
  C  476N:
//----- ADCON1 Bits --------------------------------------------------------  C  477N:
#define ADFM              0x0007  C  478N:
#define ADCS2             0x0006  C  479N:
#define PCFG3             0x0003  C  480N:
#define PCFG2             0x0002  C  481N:
#define PCFG1             0x0001  C  482N:
#define PCFG0             0x0000  C  483N:
  C  484N:
//----- CCP1CON Bits -------------------------------------------------------  C  485N:
#define DC1B1             0x0005  C  486N:
#define CCP1X             0x0005      // For backward compatibility  C  487N:
#define DC1B0             0x0004  C  488N:
#define CCP1Y             0x0004      // For backward compatibility  C  489N:
#define CCP1M3            0x0003  C  490N:
#define CCP1M2            0x0002  C  491N:
#define CCP1M1            0x0001  C  492N:
#define CCP1M0            0x0000  C  493N:
  C  494N:
//----- ECCP1CON Bits ------------------------------------------------------  C  495N:
#define EPWM1M1           0x0007  C  496N:
#define EPWM1M0           0x0006  C  497N:
#define EDC2B1            0x0005  C  498N:
#define EDC2B0            0x0004  C  499N:
#define ECCP1M3           0x0003  C  500N:
#define ECCP1M2           0x0002  C  501N:
#define ECCP1M1           0x0001  C  502N:
#define ECCP1M0           0x0000  C  503N:
  C  504N:
//----- ECCPAS Bits --------------------------------------------------------  C  505N:
#define ECCPASE           0x0007  C  506N:
#define ECCPAS2           0x0006  C  507N:
#define ECCPAS1           0x0005  C  508N:
#define ECCPAS0           0x0004  C  509N:
#define PSSAC1            0x0003  C  510N:
#define PSSAC0            0x0002  C  511N:
#define PSSBD1            0x0001  C  512N:
#define PSSBD0            0x0000  C  513N:
  C  514N:
//----- CVRCON Bits --------------------------------------------------------  C  515N:
#define CVREN             0x0007  C  516N:
#define CVROE             0x0006      // For backward compatibility  C  517N:
#define CVRR              0x0005  C  518N:
#define CVRSS             0x0004      // For backward compatibility  C  519N:
#define CVR3              0x0003  C  520N:
#define CVR2              0x0002  C  521N:
#define CVR1              0x0001  C  522N:
#define CVR0              0x0000  C  523N:
  C  524N:
//----- CMCON Bits ---------------------------------------------------------  C  525N:
#define C2OUT             0x0007  C  526N:
#define C1OUT             0x0006      // For backward compatibility  C  527N:
#define C2INV             0x0005  C  528N:
#define C1INV             0x0004      // For backward compatibility  C  529N:
#define CIS               0x0003  C  530N:
#define CM2               0x0002  C  531N:
#define CM1               0x0001  C  532N:
#define CM0               0x0000  C  533N:
  C  534N:
//----- T3CON Bits ---------------------------------------------------------  C  535N:
//#define RD16              0x0007 (duplicate definition with T1CON  C  536N:
#define T3ECCP1           0x0006  C  537N:
#define T3CKPS1           0x0005  C  538N:
#define T3CKPS0           0x0004  C  539N:
#define T3CCP1            0x0003  C  540N:
#define NOT_T3SYNC        0x0002  C  541N:
#define T3SYNC            0x0002  C  542N:
#define T3INSYNC          0x0002    // Backward compatibility only  C  543N:
#define TMR3CS            0x0001  C  544N:
#define TMR3ON            0x0000  C  545N:
  C  546N:
//----- PSPCON Bits --------------------------------------------------------  C  547N:
#define IBF               0x0007  C  548N:
#define OBF               0x0006  C  549N:
#define IBOV              0x0005  C  550N:
#define PSPMODE           0x0004  C  551N:
  C  552N:
//----- TXSTA Bits ---------------------------------------------------------  C  553N:
#define CSRC              0x0007  C  554N:
#define TX9               0x0006  C  555N:
#define NOT_TX8           0x0006    // Backward compatibility only  C  556N:
#define TX8_9             0x0006    // Backward compatibility only  C  557N:
#define TXEN              0x0005  C  558N:
#define SYNC              0x0004  C  559N:
#define BRGH              0x0002  C  560N:
#define TRMT              0x0001  C  561N:
#define TX9D              0x0000  C  562N:
#define TXD8              0x0000    // Backward compatibility only  C  563N:
  C  564N:
//----- RCSTA Bits ---------------------------------------------------------  C  565N:
#define SPEN              0x0007  C  566N:
#define RX9               0x0006  C  567N:
#define RC9               0x0006    // Backward compatibility only  C  568N:
#define NOT_RC8           0x0006    // Backward compatibility only  C  569N:
#define RC8_9             0x0006    // Backward compatibility only  C  570N:
#define SREN              0x0005  C  571N:
#define CREN              0x0004  C  572N:
#define ADDEN             0x0003  C  573N:
#define FERR              0x0002  C  574N:
#define OERR              0x0001  C  575N:
#define RX9D              0x0000  C  576N:
#define RCD8              0x0000    // Backward compatibility only  C  577N:
  C  578N:
//----- EECON1 Bits --------------------------------------------------------  C  579N:
#define EEPGD             0x0007  C  580N:
#define EEFS              0x0006    // Backward compatability only  C  581N:
#define CFGS              0x0006  C  582N:
#define FREE              0x0004  C  583N:
#define WRERR             0x0003  C  584N:
#define WREN              0x0002  C  585N:
#define WR                0x0001  C  586N:
#define RD                0x0000  C  587N:
  C  588N:
//----- IPR3 Bits ----------------------------------------------------------  C  589N:
#define IRXIP             0x0007  C  590N:
#define WAKIP             0x0006  C  591N:
#define ERRIP             0x0005  C  592N:
#define TXB2IP            0x0004  C  593N:
#define TXB1IP            0x0003  C  594N:
#define TXB0IP            0x0002  C  595N:
#define RXB1IP            0x0001  C  596N:
#define RXB0IP            0x0000  C  597N:
  C  598N:
//----- PIR3 Bits ----------------------------------------------------------  C  599N:
#define IRXIF             0x0007  C  600N:
#define WAKIF             0x0006  C  601N:
#define ERRIF             0x0005  C  602N:
#define TXB2IF            0x0004  C  603N:
#define TXB1IF            0x0003  C  604N:
#define TXB0IF            0x0002  C  605N:
#define RXB1IF            0x0001  C  606N:
#define RXB0IF            0x0000  C  607N:
  C  608N:
//----- PIE3 Bits ----------------------------------------------------------  C  609N:
#define IRXIE             0x0007  C  610N:
#define WAKIE             0x0006  C  611N:
#define ERRIE             0x0005  C  612N:
#define TXB2IE            0x0004  C  613N:
#define TXB1IE            0x0003  C  614N:
#define TXB0IE            0x0002  C  615N:
#define RXB1IE            0x0001  C  616N:
#define RXB0IE            0x0000  C  617N:
  C  618N:
//----- IPR2 Bits ----------------------------------------------------------  C  619N:
#define CMIP              0x0006  C  620N:
#define EEIP              0x0004  C  621N:
#define BCLIP             0x0003  C  622N:
#define LVDIP             0x0002  C  623N:
#define TMR3IP            0x0001  C  624N:
#define ECCP1IP           0x0000  C  625N:
  C  626N:
//----- PIR2 Bits ----------------------------------------------------------  C  627N:
#define CMIF              0x0006  C  628N:
#define EEIF              0x0004  C  629N:
#define BCLIF             0x0003  C  630N:
#define LVDIF             0x0002  C  631N:
#define TMR3IF            0x0001  C  632N:
#define ECCP1IF           0x0000  C  633N:
  C  634N:
//----- PIE2 Bits ----------------------------------------------------------  C  635N:
#define CMIE              0x0006  C  636N:
#define EEIE              0x0004  C  637N:
#define BCLIE             0x0003  C  638N:
#define LVDIE             0x0002  C  639N:
#define TMR3IE            0x0001  C  640N:
#define ECCP1IE           0x0000  C  641N:
  C  642N:
//----- IPR1 Bits ----------------------------------------------------------  C  643N:
#define PSPIP             0x0007  C  644N:
#define ADIP              0x0006  C  645N:
#define RCIP              0x0005  C  646N:
#define TXIP              0x0004  C  647N:
#define SSPIP             0x0003  C  648N:
#define CCP1IP            0x0002  C  649N:
#define TMR2IP            0x0001  C  650N:
#define TMR1IP            0x0000  C  651N:
  C  652N:
//----- PIR1 Bits ----------------------------------------------------------  C  653N:
#define PSPIF             0x0007  C  654N:
#define ADIF              0x0006  C  655N:
#define RCIF              0x0005  C  656N:
#define TXIF              0x0004  C  657N:
#define SSPIF             0x0003  C  658N:
#define CCP1IF            0x0002  C  659N:
#define TMR2IF            0x0001  C  660N:
#define TMR1IF            0x0000  C  661N:
  C  662N:
//----- PIE1 Bits ----------------------------------------------------------  C  663N:
#define PSPIE             0x0007  C  664N:
#define ADIE              0x0006  C  665N:
#define RCIE              0x0005  C  666N:
#define TXIE              0x0004  C  667N:
#define SSPIE             0x0003  C  668N:
#define CCP1IE            0x0002  C  669N:
#define TMR2IE            0x0001  C  670N:
#define TMR1IE            0x0000  C  671N:
  C  672N:
//----- COMSTAT Bits ---------------------------------------------------------  C  673N:
#define RX1OVFL           0x0007  C  674N:
#define RXB0OVFL          0x0007  C  675N:
#define RX2OVFL           0x0006  C  676N:
#define RXB1OVFL          0x0006  C  677N:
#define TXBO              0x0005  C  678N:
#define TXBP              0x0004  C  679N:
#define RXBP              0x0003  C  680N:
#define TXWARN            0x0002  C  681N:
#define RXWARN            0x0001  C  682N:
#define EWARN             0x0000  C  683N:
  C  684N:
//----- CIOCON Bits -----------------------------------------------------------  C  685N:
#define ENDRHI            0x0005  C  686N:
#define CANCAP            0x0004  C  687N:
  C  688N:
//----- BRGCON3 Bits ----------------------------------------------------------  C  689N:
#define WAKFIL            0x0006  C  690N:
#define SEG2PH2           0x0002  C  691N:
#define SEG2PH1           0x0001  C  692N:
#define SEG2PH0           0x0000  C  693N:
  C  694N:
//----- BRGCON2 Bits -----------------------------------------------------------  C  695N:
#define SEG2PHTS          0x0007  C  696N:
#define SAM               0x0006  C  697N:
#define SEG1PH2           0x0005  C  698N:
#define SEG1PH1           0x0004  C  699N:
#define SEG1PH0           0x0003  C  700N:
#define PRSEG2            0x0002  C  701N:
#define PRSEG1            0x0001  C  702N:
#define PRSEG0            0x0000  C  703N:
  C  704N:
//----- BRGCON1 Bits ------------------------------------------------------------  C  705N:
#define SJW1              0x0007  C  706N:
#define SJW0              0x0006  C  707N:
#define BRP5              0x0005  C  708N:
#define BRP4              0x0004  C  709N:
#define BRP3              0x0003  C  710N:
#define BRP2              0x0002  C  711N:
#define BRP1              0x0001  C  712N:
#define BRP0              0x0000  C  713N:
  C  714N:
//----- CANCON Bits --------------------------------------------------------  C  715N:
#define REQOP2            0x0007  C  716N:
#define REQOP1            0x0006  C  717N:
#define REQOP0            0x0005  C  718N:
#define ABAT              0x0004  C  719N:
#define WIN2              0x0003  C  720N:
#define WIN1              0x0002  C  721N:
#define WIN0              0x0001  C  722N:
  C  723N:
//----- CANSTAT Bits -------------------------------------------------------  C  724N:
#define OPMODE2           0x0007  C  725N:
#define OPMODE1           0x0006  C  726N:
#define OPMODE0           0x0005  C  727N:
#define ICODE2            0x0003  C  728N:
#define ICODE1            0x0002  C  729N:
#define ICODE0            0x0001  C  730N:
  C  731N:
//----- RXBnCON Bits -------------------------------------------------------  C  732N:
#define RXFUL             0x0007  C  733N:
#define RXM1              0x0006  C  734N:
#define RXM0              0x0005  C  735N:
#define RXRTRRO           0x0003  C  736N:
#define RXB0DBEN          0x0002  C  737N:
#define FILHIT2           0x0002  C  738N:
#define JTOFF             0x0001  C  739N:
#define FILHIT1           0x0001  C  740N:
#define FILHIT0           0x0000  C  741N:
  C  742N:
//----- TXBnCON Bits -------------------------------------------------------  C  743N:
#define TXABT             0x0006  C  744N:
#define TXLARB            0x0005  C  745N:
#define TXERR             0x0004  C  746N:
#define TXREQ             0x0003  C  747N:
#define TXPRI1            0x0001  C  748N:
#define TXPRI0            0x0000  C  749N:
  C  750N:
//----- TXERRCNT Bits ----------------------------------------------------------  C  751N:
#define TEC7              0x0007  C  752N:
#define TEC6              0x0006  C  753N:
#define TEC5              0x0005  C  754N:
#define TEC4              0x0004  C  755N:
#define TEC3              0x0003  C  756N:
#define TEC2              0x0002  C  757N:
#define TEC1              0x0001  C  758N:
#define TEC0              0x0000  C  759N:
  C  760N:
//----- RXERRCNT Bits ----------------------------------------------------------  C  761N:
#define REC7              0x0007  C  762N:
#define REC6              0x0006  C  763N:
#define REC5              0x0005  C  764N:
#define REC4              0x0004  C  765N:
#define REC3              0x0003  C  766N:
#define REC2              0x0002  C  767N:
#define REC1              0x0001  C  768N:
#define REC0              0x0000  C  769N:
  C  770N:
//----- RXBnDLC and TXBnDLC Bits -----------------------------------------------  C  771N:
#define RXRTR             0x0006  C  772N:
#define TXRTR             0x0006  C  773N:
#define RESB1             0x0005  C  774N:
#define RESB0             0x0004  C  775N:
#define DLC3              0x0003  C  776N:
#define DLC2              0x0002  C  777N:
#define DLC1              0x0001  C  778N:
#define DLC0              0x0000  C  779N:
  C  780N:
//----- RXBnEIDL, RXFnEIDL, RXMnEIDL, and TXBnEIDL Bits -------------------------  C  781N:
#define EID7              0x0007  C  782N:
#define EID6              0x0006  C  783N:
#define EID5              0x0005  C  784N:
#define EID4              0x0004  C  785N:
#define EID3              0x0003  C  786N:
#define EID2              0x0002  C  787N:
#define EID1              0x0001  C  788N:
#define EID0              0x0000  C  789N:
  C  790N:
//----- RXBnEIDH, RXFnEIDH, RXMnEIDH, and TXBnEIDH Bits -------------------------  C  791N:
#define EID15             0x0007  C  792N:
#define EID14             0x0006  C  793N:
#define EID13             0x0005  C  794N:
#define EID12             0x0004  C  795N:
#define EID11             0x0003  C  796N:
#define EID10             0x0002  C  797N:
#define EID9              0x0001  C  798N:
#define EID8              0x0000  C  799N:
  C  800N:
//----- RXBnSIDL, RXFnSIDL, RXMnSIDL, and TXBnSIDL Bits ----------------------  C  801N:
#define SID2              0x0007  C  802N:
#define SID1              0x0006  C  803N:
#define SID0              0x0005  C  804N:
#define SRR               0x0004  C  805N:
#define EXID              0x0003  C  806N:
#define EXIDE             0x0003  C  807N:
#define EXIDEN            0x0003  C  808N:
#define EID17             0x0001  C  809N:
#define EID16             0x0000  C  810N:
  C  811N:
//----- RXBnSIDH, RXFnSIDH, RXMnSIDH, and TXBnSIDH Bits ----------------------  C  812N:
#define SID10             0x0007  C  813N:
#define SID9              0x0006  C  814N:
#define SID8              0x0005  C  815N:
#define SID7              0x0004  C  816N:
#define SID6              0x0003  C  817N:
#define SID5              0x0002  C  818N:
#define SID4              0x0001  C  819N:
#define SID3              0x0001  C  820N:
  C  821N:
//----- RXB0D7 Bits ----------------------------------------------------------  C  822N:
#define RB0D77            0x0007  C  823N:
#define RB0D76            0x0006  C  824N:
#define RB0D75            0x0005  C  825N:
#define RB0D74            0x0004  C  826N:
#define RB0D73            0x0003  C  827N:
#define RB0D72            0x0002  C  828N:
#define RB0D71            0x0001  C  829N:
#define RB0D70            0x0000  C  830N:
  C  831N:
//----- RXB0D6 Bits ----------------------------------------------------------  C  832N:
#define RB0D67            0x0007  C  833N:
#define RB0D66            0x0006  C  834N:
#define RB0D65            0x0005  C  835N:
#define RB0D64            0x0004  C  836N:
#define RB0D63            0x0003  C  837N:
#define RB0D62            0x0002  C  838N:
#define RB0D61            0x0001  C  839N:
#define RB0D60            0x0000  C  840N:
  C  841N:
//----- RXB0D5 Bits ----------------------------------------------------------  C  842N:
#define RB0D57            0x0007  C  843N:
#define RB0D56            0x0006  C  844N:
#define RB0D55            0x0005  C  845N:
#define RB0D54            0x0004  C  846N:
#define RB0D53            0x0003  C  847N:
#define RB0D52            0x0002  C  848N:
#define RB0D51            0x0001  C  849N:
#define RB0D50            0x0000  C  850N:
  C  851N:
//----- RXB0D4 Bits ----------------------------------------------------------  C  852N:
#define RB0D47            0x0007  C  853N:
#define RB0D46            0x0006  C  854N:
#define RB0D45            0x0005  C  855N:
#define RB0D44            0x0004  C  856N:
#define RB0D43            0x0003  C  857N:
#define RB0D42            0x0002  C  858N:
#define RB0D41            0x0001  C  859N:
#define RB0D40            0x0000  C  860N:
  C  861N:
//----- RXB0D3 Bits ----------------------------------------------------------  C  862N:
#define RB0D37            0x0007  C  863N:
#define RB0D36            0x0006  C  864N:
#define RB0D35            0x0005  C  865N:
#define RB0D34            0x0004  C  866N:
#define RB0D33            0x0003  C  867N:
#define RB0D32            0x0002  C  868N:
#define RB0D31            0x0001  C  869N:
#define RB0D30            0x0000  C  870N:
  C  871N:
//----- RXB0D2 Bits ----------------------------------------------------------  C  872N:
#define RB0D27            0x0007  C  873N:
#define RB0D26            0x0006  C  874N:
#define RB0D25            0x0005  C  875N:
#define RB0D24            0x0004  C  876N:
#define RB0D23            0x0003  C  877N:
#define RB0D22            0x0002  C  878N:
#define RB0D21            0x0001  C  879N:
#define RB0D20            0x0000  C  880N:
  C  881N:
//----- RXB0D1 Bits ----------------------------------------------------------  C  882N:
#define RB0D17            0x0007  C  883N:
#define RB0D16            0x0006  C  884N:
#define RB0D15            0x0005  C  885N:
#define RB0D14            0x0004  C  886N:
#define RB0D13            0x0003  C  887N:
#define RB0D12            0x0002  C  888N:
#define RB0D11            0x0001  C  889N:
#define RB0D10            0x0000  C  890N:
  C  891N:
//----- RXB0D0 Bits ----------------------------------------------------------  C  892N:
#define RB0D07            0x0007  C  893N:
#define RB0D06            0x0006  C  894N:
#define RB0D05            0x0005  C  895N:
#define RB0D04            0x0004  C  896N:
#define RB0D03            0x0003  C  897N:
#define RB0D02            0x0002  C  898N:
#define RB0D01            0x0001  C  899N:
#define RB0D00            0x0000  C  900N:
  C  901N:
//----- RXB1D7 Bits ----------------------------------------------------------  C  902N:
#define RXB1D77            0x0007  C  903N:
#define RXB1D76            0x0006  C  904N:
#define RXB1D75            0x0005  C  905N:
#define RXB1D74            0x0004  C  906N:
#define RXB1D73            0x0003  C  907N:
#define RXB1D72            0x0002  C  908N:
#define RXB1D71            0x0001  C  909N:
#define RXB1D70            0x0000  C  910N:
  C  911N:
//----- RXB1D6 Bits ----------------------------------------------------------  C  912N:
#define RXB1D67            0x0007  C  913N:
#define RXB1D66            0x0006  C  914N:
#define RXB1D65            0x0005  C  915N:
#define RXB1D64            0x0004  C  916N:
#define RXB1D63            0x0003  C  917N:
#define RXB1D62            0x0002  C  918N:
#define RXB1D61            0x0001  C  919N:
#define RXB1D60            0x0000  C  920N:
  C  921N:
//----- RXB1D5 Bits ----------------------------------------------------------  C  922N:
#define RXB1D57            0x0007  C  923N:
#define RXB1D56            0x0006  C  924N:
#define RXB1D55            0x0005  C  925N:
#define RXB1D54            0x0004  C  926N:
#define RXB1D53            0x0003  C  927N:
#define RXB1D52            0x0002  C  928N:
#define RXB1D51            0x0001  C  929N:
#define RXB1D50            0x0000  C  930N:
  C  931N:
  C  932N:
//----- RXB1D4 Bits ----------------------------------------------------------  C  933N:
#define RXB1D47            0x0007  C  934N:
#define RXB1D46            0x0006  C  935N:
#define RXB1D45            0x0005  C  936N:
#define RXB1D44            0x0004  C  937N:
#define RXB1D43            0x0003  C  938N:
#define RXB1D42            0x0002  C  939N:
#define RXB1D41            0x0001  C  940N:
#define RXB1D40            0x0000  C  941N:
  C  942N:
  C  943N:
//----- RXB1D3 Bits ----------------------------------------------------------  C  944N:
#define RXB1D37            0x0007  C  945N:
#define RXB1D36            0x0006  C  946N:
#define RXB1D35            0x0005  C  947N:
#define RXB1D34            0x0004  C  948N:
#define RXB1D33            0x0003  C  949N:
#define RXB1D32            0x0002  C  950N:
#define RXB1D31            0x0001  C  951N:
#define RXB1D30            0x0000  C  952N:
  C  953N:
  C  954N:
//----- RXB1D2 Bits ----------------------------------------------------------  C  955N:
#define RXB1D27            0x0007  C  956N:
#define RXB1D26            0x0006  C  957N:
#define RXB1D25            0x0005  C  958N:
#define RXB1D24            0x0004  C  959N:
#define RXB1D23            0x0003  C  960N:
#define RXB1D22            0x0002  C  961N:
#define RXB1D21            0x0001  C  962N:
#define RXB1D20            0x0000  C  963N:
  C  964N:
  C  965N:
//----- RXB1D1 Bits ----------------------------------------------------------  C  966N:
#define RXB1D17            0x0007  C  967N:
#define RXB1D16            0x0006  C  968N:
#define RXB1D15            0x0005  C  969N:
#define RXB1D14            0x0004  C  970N:
#define RXB1D13            0x0003  C  971N:
#define RXB1D12            0x0002  C  972N:
#define RXB1D11            0x0001  C  973N:
#define RXB1D10            0x0000  C  974N:
  C  975N:
//----- RXB1D0 Bits ----------------------------------------------------------  C  976N:
#define RXB1D07            0x0007  C  977N:
#define RXB1D06            0x0006  C  978N:
#define RXB1D05            0x0005  C  979N:
#define RXB1D04            0x0004  C  980N:
#define RXB1D03            0x0003  C  981N:
#define RXB1D02            0x0002  C  982N:
#define RXB1D01            0x0001  C  983N:
#define RXB1D00            0x0000  C  984N:
  C  985N:
  C  986N:
//----- TXB2D7 Bits ----------------------------------------------------------  C  987N:
#define TXB2D77            0x0007  C  988N:
#define TXB2D76            0x0006  C  989N:
#define TXB2D75            0x0005  C  990N:
#define TXB2D74            0x0004  C  991N:
#define TXB2D73            0x0003  C  992N:
#define TXB2D72            0x0002  C  993N:
#define TXB2D71            0x0001  C  994N:
#define TXB2D70            0x0000  C  995N:
  C  996N:
//----- TXB2D6 Bits ----------------------------------------------------------  C  997N:
#define TXB2D67            0x0007  C  998N:
#define TXB2D66            0x0006  C  999N:
#define TXB2D65            0x0005  C 1000N:
#define TXB2D64            0x0004  C 1001N:
#define TXB2D63            0x0003  C 1002N:
#define TXB2D62            0x0002  C 1003N:
#define TXB2D61            0x0001  C 1004N:
#define TXB2D60            0x0000  C 1005N:
  C 1006N:
//----- TXB2D5 Bits ----------------------------------------------------------  C 1007N:
#define TXB2D57            0x0007  C 1008N:
#define TXB2D56            0x0006  C 1009N:
#define TXB2D55            0x0005  C 1010N:
#define TXB2D54            0x0004  C 1011N:
#define TXB2D53            0x0003  C 1012N:
#define TXB2D52            0x0002  C 1013N:
#define TXB2D51            0x0001  C 1014N:
#define TXB2D50            0x0000  C 1015N:
  C 1016N:
//----- TXB2D4 Bits ----------------------------------------------------------  C 1017N:
#define TXB2D47            0x0007  C 1018N:
#define TXB2D46            0x0006  C 1019N:
#define TXB2D45            0x0005  C 1020N:
#define TXB2D44            0x0004  C 1021N:
#define TXB2D43            0x0003  C 1022N:
#define TXB2D42            0x0002  C 1023N:
#define TXB2D41            0x0001  C 1024N:
#define TXB2D40            0x0000  C 1025N:
  C 1026N:
//----- TXB2D3 Bits ----------------------------------------------------------  C 1027N:
#define TXB2D37            0x0007  C 1028N:
#define TXB2D36            0x0006  C 1029N:
#define TXB2D35            0x0005  C 1030N:
#define TXB2D34            0x0004  C 1031N:
#define TXB2D33            0x0003  C 1032N:
#define TXB2D32            0x0002  C 1033N:
#define TXB2D31            0x0001  C 1034N:
#define TXB2D30            0x0000  C 1035N:
  C 1036N:
//----- TXB2D2 Bits ----------------------------------------------------------  C 1037N:
#define TXB2D27            0x0007  C 1038N:
#define TXB2D26            0x0006  C 1039N:
#define TXB2D25            0x0005  C 1040N:
#define TXB2D24            0x0004  C 1041N:
#define TXB2D23            0x0003  C 1042N:
#define TXB2D22            0x0002  C 1043N:
#define TXB2D21            0x0001  C 1044N:
#define TXB2D20            0x0000  C 1045N:
  C 1046N:
//----- TXB2D1 Bits ----------------------------------------------------------  C 1047N:
#define TXB2D17            0x0007  C 1048N:
#define TXB2D16            0x0006  C 1049N:
#define TXB2D15            0x0005  C 1050N:
#define TXB2D14            0x0004  C 1051N:
#define TXB2D13            0x0003  C 1052N:
#define TXB2D12            0x0002  C 1053N:
#define TXB2D11            0x0001  C 1054N:
#define TXB2D10            0x0000  C 1055N:
  C 1056N:
//----- TXB2D0 Bits ----------------------------------------------------------  C 1057N:
#define TXB2D07            0x0007  C 1058N:
#define TXB2D06            0x0006  C 1059N:
#define TXB2D05            0x0005  C 1060N:
#define TXB2D04            0x0004  C 1061N:
#define TXB2D03            0x0003  C 1062N:
#define TXB2D02            0x0002  C 1063N:
#define TXB2D01            0x0001  C 1064N:
#define TXB2D00            0x0000  C 1065N:
  C 1066N:
  C 1067N:
//----- TXB1D7 Bits ----------------------------------------------------------  C 1068N:
#define TXB1D77            0x0007  C 1069N:
#define TXB1D76            0x0006  C 1070N:
#define TXB1D75            0x0005  C 1071N:
#define TXB1D74            0x0004  C 1072N:
#define TXB1D73            0x0003  C 1073N:
#define TXB1D72            0x0002  C 1074N:
#define TXB1D71            0x0001  C 1075N:
#define TXB1D70            0x0000  C 1076N:
  C 1077N:
//----- TXB1D6 Bits ----------------------------------------------------------  C 1078N:
#define TXB1D67            0x0007  C 1079N:
#define TXB1D66            0x0006  C 1080N:
#define TXB1D65            0x0005  C 1081N:
#define TXB1D64            0x0004  C 1082N:
#define TXB1D63            0x0003  C 1083N:
#define TXB1D62            0x0002  C 1084N:
#define TXB1D61            0x0001  C 1085N:
#define TXB1D60            0x0000  C 1086N:
  C 1087N:
//----- TXB1D5 Bits ----------------------------------------------------------  C 1088N:
#define TXB1D57            0x0007  C 1089N:
#define TXB1D56            0x0006  C 1090N:
#define TXB1D55            0x0005  C 1091N:
#define TXB1D54            0x0004  C 1092N:
#define TXB1D53            0x0003  C 1093N:
#define TXB1D52            0x0002  C 1094N:
#define TXB1D51            0x0001  C 1095N:
#define TXB1D50            0x0000  C 1096N:
  C 1097N:
//----- TXB1D4 Bits ----------------------------------------------------------  C 1098N:
#define TXB1D47            0x0007  C 1099N:
#define TXB1D46            0x0006  C 1100N:
#define TXB1D45            0x0005  C 1101N:
#define TXB1D44            0x0004  C 1102N:
#define TXB1D43            0x0003  C 1103N:
#define TXB1D42            0x0002  C 1104N:
#define TXB1D41            0x0001  C 1105N:
#define TXB1D40            0x0000  C 1106N:
  C 1107N:
//----- TXB1D3 Bits ----------------------------------------------------------  C 1108N:
#define TXB1D37            0x0007  C 1109N:
#define TXB1D36            0x0006  C 1110N:
#define TXB1D35            0x0005  C 1111N:
#define TXB1D34            0x0004  C 1112N:
#define TXB1D33            0x0003  C 1113N:
#define TXB1D32            0x0002  C 1114N:
#define TXB1D31            0x0001  C 1115N:
#define TXB1D30            0x0000  C 1116N:
  C 1117N:
//----- TXB1D2 Bits ----------------------------------------------------------  C 1118N:
#define TXB1D27            0x0007  C 1119N:
#define TXB1D26            0x0006  C 1120N:
#define TXB1D25            0x0005  C 1121N:
#define TXB1D24            0x0004  C 1122N:
#define TBB1D23            0x0003  C 1123N:
#define TXB1D22            0x0002  C 1124N:
#define TXB1D21            0x0001  C 1125N:
#define TXB1D20            0x0000  C 1126N:
  C 1127N:
//----- TXB1D1 Bits ----------------------------------------------------------  C 1128N:
#define TXB1D17            0x0007  C 1129N:
#define TXB1D16            0x0006  C 1130N:
#define TXB1D15            0x0005  C 1131N:
#define TXB1D14            0x0004  C 1132N:
#define TXB1D13            0x0003  C 1133N:
#define TXB1D12            0x0002  C 1134N:
#define TXB1D11            0x0001  C 1135N:
#define TXB1D10            0x0000  C 1136N:
  C 1137N:
//----- TXB1D0 Bits ----------------------------------------------------------  C 1138N:
#define TXB1D07            0x0007  C 1139N:
#define TXB1D06            0x0006  C 1140N:
#define TXB1D05            0x0005  C 1141N:
#define TXB1D04            0x0004  C 1142N:
#define TXB1D03            0x0003  C 1143N:
#define TXB1D02            0x0002  C 1144N:
#define TXB1D01            0x0001  C 1145N:
#define TXB1D00            0x0000  C 1146N:
  C 1147N:
  C 1148N:
//----- TXB0D7 Bits ----------------------------------------------------------  C 1149N:
#define TXB0D77            0x0007  C 1150N:
#define TXB0D76            0x0006  C 1151N:
#define TXB0D75            0x0005  C 1152N:
#define TXB0D74            0x0004  C 1153N:
#define TXB0D73            0x0003  C 1154N:
#define TXB0D72            0x0002  C 1155N:
#define TXB0D71            0x0001  C 1156N:
#define TXB0D70            0x0000  C 1157N:
  C 1158N:
//----- TXB0D6 Bits ----------------------------------------------------------  C 1159N:
#define TXB0D67            0x0007  C 1160N:
#define TXB0D66            0x0006  C 1161N:
#define TXB0D65            0x0005  C 1162N:
#define TXB0D64            0x0004  C 1163N:
#define TXB0D63            0x0003  C 1164N:
#define TXB0D62            0x0002  C 1165N:
#define TXB0D61            0x0001  C 1166N:
#define TXB0D60            0x0000  C 1167N:
  C 1168N:
//----- TXB0D5 Bits ----------------------------------------------------------  C 1169N:
#define TXB0D57            0x0007  C 1170N:
#define TXB0D56            0x0006  C 1171N:
#define TXB0D55            0x0005  C 1172N:
#define TXB0D54            0x0004  C 1173N:
#define TXB0D53            0x0003  C 1174N:
#define TXB0D52            0x0002  C 1175N:
#define TXB0D51            0x0001  C 1176N:
#define TXB0D50            0x0000  C 1177N:
  C 1178N:
//----- TXB0D4 Bits ----------------------------------------------------------  C 1179N:
#define TXB0D47            0x0007  C 1180N:
#define TXB0D46            0x0006  C 1181N:
#define TXB0D45            0x0005  C 1182N:
#define TXB0D44            0x0004  C 1183N:
#define TXB0D43            0x0003  C 1184N:
#define TXB0D42            0x0002  C 1185N:
#define TXB0D41            0x0001  C 1186N:
#define TXB0D40            0x0000  C 1187N:
  C 1188N:
//----- TXB0D3 Bits ----------------------------------------------------------  C 1189N:
#define TXB0D37            0x0007  C 1190N:
#define TXB0D36            0x0006  C 1191N:
#define TXB0D35            0x0005  C 1192N:
#define TXB0D34            0x0004  C 1193N:
#define TXB0D33            0x0003  C 1194N:
#define TXB0D32            0x0002  C 1195N:
#define TXB0D31            0x0001  C 1196N:
#define TXB0D30            0x0000  C 1197N:
  C 1198N:
//----- TXB0D2 Bits ----------------------------------------------------------  C 1199N:
#define TXB0D27            0x0007  C 1200N:
#define TXB0D26            0x0006  C 1201N:
#define TXB0D25            0x0005  C 1202N:
#define TXB0D24            0x0004  C 1203N:
#define TXB0D23            0x0003  C 1204N:
#define TXB0D22            0x0002  C 1205N:
#define TXB0D21            0x0001  C 1206N:
#define TXB0D20            0x0000  C 1207N:
  C 1208N:
//----- TXB0D1 Bits ----------------------------------------------------------  C 1209N:
#define TXB0D17            0x0007  C 1210N:
#define TXB0D16            0x0006  C 1211N:
#define TXB0D15            0x0005  C 1212N:
#define TXB0D14            0x0004  C 1213N:
#define TXB0D13            0x0003  C 1214N:
#define TXB0D12            0x0002  C 1215N:
#define TXB0D11            0x0001  C 1216N:
#define TXB0D10            0x0000  C 1217N:
  C 1218N:
//----- TXB0D0 Bits ----------------------------------------------------------  C 1219N:
#define TXB0D07            0x0007  C 1220N:
#define TXB0D06            0x0006  C 1221N:
#define TXB0D05            0x0005  C 1222N:
#define TXB0D04            0x0004  C 1223N:
#define TXB0D03            0x0003  C 1224N:
#define TXB0D02            0x0002  C 1225N:
#define TXB0D01            0x0001  C 1226N:
#define TXB0D00            0x0000  C 1227N:
  C 1228N:
  C 1229N:
//==========================================================================  C 1230N:
//  C 1231N:
//       I/O Pin Name Definitions  C 1232N:
//  C 1233N:
//==========================================================================  C 1234N:
  C 1235N:
//----- PORTA ------------------------------------------------------------------  C 1236N:
#define RA0               0  C 1237N:
#define AN0               0  C 1238N:
#define RA1               1  C 1239N:
#define AN1               1  C 1240N:
#define RA2               2  C 1241N:
#define AN2               2  C 1242N:
#define VREFM             2  C 1243N:
#define RA3               3  C 1244N:
#define AN3               3  C 1245N:
#define VREFP             3  C 1246N:
#define RA4               4  C 1247N:
#define T0CKI             4  C 1248N:
#define RA5               5  C 1249N:
#define AN4               5  C 1250N:
#define SS                5  C 1251N:
#define NOT_SS            5  C 1252N:
#define LVDIN             5  C 1253N:
#define RA6               6  C 1254N:
#define OSC2              6  C 1255N:
#define CLKO              6  C 1256N:
  C 1257N:
//----- PORTB ------------------------------------------------------------------  C 1258N:
#define RB0               0  C 1259N:
#define INT0              0  C 1260N:
#define RB1               1  C 1261N:
#define INT1              1  C 1262N:
#define RB2               2  C 1263N:
#define CANTX             2  C 1264N:
#define RB3               3  C 1265N:
#define CANRX             3  C 1266N:
#define RB4               4  C 1267N:
#define RB5               5  C 1268N:
#define PGM               5  C 1269N:
#define RB6               6  C 1270N:
#define PGC               6  C 1271N:
#define RB7               7  C 1272N:
#define PGD               7  C 1273N:
  C 1274N:
//----- PORTC ------------------------------------------------------------------  C 1275N:
#define RC0               0  C 1276N:
#define T1OSO             0  C 1277N:
#define T1CKI             0  C 1278N:
#define RC1               1  C 1279N:
#define T1OSI             1  C 1280N:
#define RC2               2  C 1281N:
#define CCP1              2  C 1282N:
#define RC3               3  C 1283N:
#define SCK               3  C 1284N:
#define SCL               3  C 1285N:
#define RC4               4  C 1286N:
#define SDI               4  C 1287N:
#define SDA               4  C 1288N:
#define RC5               5  C 1289N:
#define SDO               5  C 1290N:
#define RC6               6  C 1291N:
#define TX                6  C 1292N:
#define CK                6  C 1293N:
#define RC7               7  C 1294N:
#define RX                7  C 1295N:
//****DT                7      //*** Not Available due to conflict with  C 1296N:
                                 //***    Define Table (DT) directive  C 1297N:
  C 1298N:
//==========================================================================  C 1299N:
//  C 1300N:
//       RAM Definition  C 1301N:
//  C 1302N:
//==========================================================================  C 1303N:
  C 1304N:
//	__MAXRAM 0xFFF  C 1305N:
//	__BADRAM 0x300-0xEFF  C 1306N:
//	__BADRAM 0xFD4,0xFC0,0xFB9,0xFB8,0xFAA,0xF97-0xF9C  C 1307N:
//	__BADRAM 0xF8E-0xF91,0xF85-0xF88, 0xF79-0xF7F,0xF77  C 1308N:
//	__BADRAM 0xF5F,0xF4F,0xF3F,0xF2F  C 1309N:
//  C 1310N:
//==========================================================================  C 1311N:
//  C 1312N:
//       Configuration Bits  C 1313N:
//  C 1314N:
//     Data Sheet    Include File                  Address  C 1315N:
//     CONFIG1H    = Configuration Byte 1H         300001h  C 1316N:
//     CONFIG2L    = Configuration Byte 2L         300002h  C 1317N:
//     CONFIG2H    = Configuration Byte 2H         300003h  C 1318N:
//     CONFIG4L    = Configuration Byte 4L         300006h  C 1319N:
//  C 1320N:
//==========================================================================  C 1321N:
  C 1322N:
//Configuration Byte 1H Options  C 1323N:
#define _OSCS_ON_1H         0xDF	// Oscillator Switch enable  C 1324N:
#define _OSCS_OFF_1H        0xFF  C 1325N:
  C 1326N:
#define _LP_OSC_1H          0xF8	// Oscillator type  C 1327N:
#define _XT_OSC_1H          0xF9  C 1328N:
#define _HS_OSC_1H          0xFA  C 1329N:
#define _RC_OSC_1H          0xFB  C 1330N:
#define _EC_OSC_1H          0xFC	// External Clock w/OSC2 output divide by 4  C 1331N:
#define _ECIO_OSC_1H        0xFD	// w/OSC2 as an IO pin (RA6)  C 1332N:
#define _HSPLL_OSC_1H       0xFE	// HS PLL  C 1333N:
#define _RCIO_OSC_1H        0xFF	// RC w/OSC2 as an IO pin (RA6)  C 1334N:
  C 1335N:
//Configuration Byte 2L Options  C 1336N:
#define _BOR_ON_2L          0xFF	// Brown-Out Reset enable  C 1337N:
#define _BOR_OFF_2L         0xFD  C 1338N:
#define _PWRT_OFF_2L        0xFF	// Power-Up Timer enable  C 1339N:
#define _PWRT_ON_2L         0xFE  C 1340N:
#define _BORV_25_2L         0xFF	// BOR Voltage - 2.5v  C 1341N:
#define _BORV_27_2L         0xFB	//               2.7v  C 1342N:
#define _BORV_42_2L         0xF7 	//               4.2v  C 1343N:
#define _BORV_45_2L         0xF3	//               4.5v  C 1344N:
  C 1345N:
//Configuration Byte 2H Options  C 1346N:
#define _WDT_ON_2H          0xFF	// Watch Dog Timer enable  C 1347N:
#define _WDT_OFF_2H         0xFE  C 1348N:
#define _WDTPS_128_2H       0xFF	// Watch Dog Timer PostScaler count  C 1349N:
#define _WDTPS_64_2H        0xFD  C 1350N:
#define _WDTPS_32_2H        0xFB  C 1351N:
#define _WDTPS_16_2H        0xF9  C 1352N:
#define _WDTPS_8_2H         0xF7  C 1353N:
#define _WDTPS_4_2H         0xF5  C 1354N:
#define _WDTPS_2_2H         0xF3  C 1355N:
#define _WDTPS_1_2H         0xF1  C 1356N:
  C 1357N:
//Configuration Byte 4L Options  C 1358N:
#define _DEBUG_ON_4L        0x7F    // Enabled  C 1359N:
#define _DEBUG_OFF_4L       0xFF    // Disabled  C 1360N:
  C 1361N:
#define _LVP_ON_4L          0xFF    // Enabled  C 1362N:
#define _LVP_OFF_4L         0xFB    // Disabled  C 1363N:
  C 1364N:
#define _STVR_ON_4L         0xFF	// Stack over/underflow Reset enable  C 1365N:
#define _STVR_OFF_4L        0xFE  C 1366N:
  C 1367N:
//Configuration Byte 5L Options  C 1368N:
#define _CP0_ON_5L             0xFE    // Enabled  C 1369N:
#define _CP0_OFF_5L            0xFF    // Disabled  C 1370N:
  C 1371N:
#define _CP1_ON_5L             0xFD    // Enabled  C 1372N:
#define _CP1_OFF_5L            0xFF    // Disabled  C 1373N:
  C 1374N:
//Configuration Byte 5H Options  C 1375N:
#define _CPB_ON_5H             0xBF    // Enabled  C 1376N:
#define _CPB_OFF_5H            0xFF    // Disabled  C 1377N:
  C 1378N:
#define _CPD_ON_5H             0x7F    // Enabled  C 1379N:
#define _CPD_OFF_5H            0xFF    // Disabled  C 1380N:
  C 1381N:
//Configuration Byte 6L Options  C 1382N:
#define _WRT0_ON_6L            0xFE    // Enabled  C 1383N:
#define _WRT0_OFF_6L           0xFF    // Disabled  C 1384N:
  C 1385N:
#define _WRT1_ON_6L            0xFD    // Enabled  C 1386N:
#define _WRT1_OFF_6L           0xFF    // Disabled  C 1387N:
  C 1388N:
//Configuration Byte 6H Options  C 1389N:
#define _WRTB_ON_6H            0xBF    // Enabled  C 1390N:
#define _WRTB_OFF_6H           0xFF    // Disabled  C 1391N:
  C 1392N:
#define _WRTC_ON_6H            0xDF    // Enabled  C 1393N:
#define _WRTC_OFF_6H           0xFF    // Disabled  C 1394N:
  C 1395N:
#define _WRTD_ON_6H            0x7F    // Enabled  C 1396N:
#define _WRTD_OFF_6H           0xFF    // Disabled  C 1397N:
  C 1398N:
//Configuration Byte 7L Options  C 1399N:
#define _EBTR0_ON_7L           0xFE    // Enabled  C 1400N:
#define _EBTR0_OFF_7L          0xFF    // Disabled  C 1401N:
  C 1402N:
#define _EBTR1_ON_7L           0xFD    // Enabled  C 1403N:
#define _EBTR1_OFF_7L          0xFF    // Disabled  C 1404N:
  C 1405N:
//Configuration Byte 7H Options  C 1406N:
#define _EBTRB_ON_7H           0xBF    // Enabled  C 1407N:
#define _EBTRB_OFF_7H          0xFF    // Disabled  C 1408N:
  C 1409N:
// To use the Configuration Bits, place the following lines in your source code  C 1410N:
//  in the following format, and change the configuration value to the desired   C 1411N:
//  setting (such as _BOR_ON_2L).  These are currently commented out here  C 1412N:
//  and each __CONFIG line should have the preceding semicolon removed when  C 1413N:
//  pasted into your source code.  C 1414N:
  C 1415N:
//  The following is a assignment of address values for all of the configuration  C 1416N:
//  registers for the purpose of table reads  C 1417N:
#define _CONFIG1H           0x300001  C 1418N:
#define _CONFIG2L           0x300002  C 1419N:
#define _CONFIG2H           0x300003  C 1420N:
#define _CONFIG4L           0x300006  C 1421N:
#define _CONFIG5L           0x300008  C 1422N:
#define _CONFIG5H           0x300009  C 1423N:
#define _CONFIG6L           0x30000A  C 1424N:
#define _CONFIG6H           0x30000B  C 1425N:
#define _CONFIG7L           0x30000C  C 1426N:
#define _CONFIG7H           0x30000D  C 1427N:
#define _DEVID1             0x3FFFFE  C 1428N:
#define _DEVID2             0x3FFFFF  C 1429N:
#define _IDLOC0             0x200000  C 1430N:
#define _IDLOC1             0x200001  C 1431N:
#define _IDLOC2             0x200002  C 1432N:
#define _IDLOC3             0x200003  C 1433N:
#define _IDLOC4             0x200004  C 1434N:
#define _IDLOC5             0x200005  C 1435N:
#define _IDLOC6             0x200006  C 1436N:
#define _IDLOC7             0x200007  C 1437N:
  C 1438N:
//Program Configuration Register 1H  C 1439N:
//		__CONFIG    _CONFIG1H, _OSCS_OFF_1H & _RCIO_OSC_1H  C 1440N:
  C 1441N:
//Program Configuration Register 2L  C 1442N:
//		__CONFIG    _CONFIG2L, _BOR_ON_2L & _BORV_25_2L & _PWRT_OFF_2L  C 1443N:
  C 1444N:
//Program Configuration Register 2H  C 1445N:
//		__CONFIG    _CONFIG2H, _WDT_ON_2H & _WDTPS_128_2H  C 1446N:
  C 1447N:
//Program Configuration Register 4L  C 1448N:
//		__CONFIG    _CONFIG4L, _STVR_ON_4L  C 1449N:
  C 1450N:
//ID Locations Register 0  C 1451N:
//		__IDLOCS    _IDLOC0, <expression>  C 1452N:
  C 1453N:
//ID Locations Register 1  C 1454N:
//		__IDLOCS    _IDLOC1, <expression>  C 1455N:
  C 1456N:
//ID Locations Register 2  C 1457N:
//		__IDLOCS    _IDLOC2, <expression>  C 1458N:
  C 1459N:
//ID Locations Register 3  C 1460N:
//		__IDLOCS    _IDLOC3, <expression>  C 1461N:
  C 1462N:
//ID Locations Register 4  C 1463N:
//		__IDLOCS    _IDLOC4, <expression>  C 1464N:
  C 1465N:
//ID Locations Register 5  C 1466N:
//		__IDLOCS    _IDLOC5, <expression>  C 1467N:
  C 1468N:
//ID Locations Register 6  C 1469N:
//		__IDLOCS    _IDLOC6, <expression>  C 1470N:
  C 1471N:
//ID Locations Register 7  C 1472N:
//		__IDLOCS    _IDLOC7, <expression>  C 1473N:
  C 1474N:
//Device ID registers hold device ID and revision number and can only be read  C 1475N:
//Device ID Register 1  C 1476N:
//               DEV2, DEV1, DEV0, REV4, REV3, REV2, REV1, REV0  C 1477N:
//Device ID Register 2  C 1478N:
//               DEV10, DEV9, DEV8, DEV7, DEV6, DEV5, DEV4, DEV3  C 1479N:
  C 1480N:
  C 1481N:
//==========================================================================  C 1482N:
#LIST  C 1483 :X1
  C 1484 :
#endif  C 1485 :E
 C 1485 :
#include "hardware.h" A   40 :
 #NOLIST  D    1N:I3X0
//  Revised July 29, 2003 for CAN bus and PIC18F248 processor  D    2N:
//   D    3N:
// ******************  HARDWARE SETUP DEFINITIONS ********************  D    4N:
//   D    5N:
//   This file: 	hardware.h   D    6N:
// 	Is the file that defines the pin / function assignments  D    7N:
// 	and the internal peripheral hardware feature assignments  D    8N:
// 	for use in the Auterra OBDII Scan Tool Adapter.  D    9N:
//   D   10N:
//   D   11N:
//     I/O Port A Pinout:  D   12N:
// 	RA0	VBATT-A/D	A to D input to measure battery voltage (Multiply A/D Reading by 4.743)  D   13N:
// 	RA1	PWM_N_Out	PWM- output, goes high for Active Bus 	  D   14N:
// 	RA2	PWM_In+		This is the PWM input from the external LM393 comparator  D   15N:
// 	RA3	PWM_P_Out	PWM+ output, goes low for Active Bus	  D   16N:
// 	RA4	VPW_In		VPW mode input from the Moto MC33390 chip  D   17N:
// 	RA5	unused		Set as an output for potential debug usage  D   18N:
// 	RA6	XTAL_OSC2	Crystal Output Will use a 20Mhz crystal  D   19N:
// 	---	XTAL_OSC1	Crystal Input (not RA7 which the PIC18F248 does not have)  D   20N:
//  D   21N:
// SET_TRIS_A ( 0x55 ); 	// This goes into TRISA, a 1 sets a port pin for input  D   22N:
							// Ports are actually setup by "init_ports()" function  D   23N:
  D   24N:
//     I/O Port B Pinout:  D   25N:
// 	RB0	VPW_4x		Output, The 4X loop control for the Moto MC33390 VPW I/F chip  D   26N:
// 	RB1	VPW_Out		Goes high for active bus  D   27N:
// 	RB2	CAN-TX		CAN bus interface output pin  D   28N:
// 	RB3	CAN-RX		CAN bus interface input pin  D   29N:
// 	RB4	unused		set as an output for debugging purposes  D   30N:
// 	RB5	ISO_K_RX	K line input, and in-crcuit programming Clock Input  D   31N:
// 	RB6	ISO_K_TX	K line output, goes high for active bus  D   32N:
// 	RB7	ISO_L_TX	L line output, goes high for active bus  D   33N:
//	  D   34N:
   D   35N:
// SET_TRIS_B ( 0x28 );	  	// This goes into TRISB, a 1 sets a port pin for input  D   36N:
							// Ports are actually setup by "init_ports()" function  D   37N:
  D   38N:
//     I/O Port C Pinout:  D   39N:
// 	RC0	unused  D   40N:
// 	RC1	unused  D   41N:
// 	RC2	unused  D   42N:
// 	RC3	unused  D   43N:
// 	RC4	unused		  D   44N:
// 	RC5	unused  D   45N:
// 	RC6	TX_OUT		Serial Port Output, to the Palm / PC serial interface  D   46N:
// 	RC7	RX_In		Serial Port Input, from the Palm / PC serial interface  D   47N:
//	  D   48N:
   D   49N:
// SET_TRIS_C ( 0xBF );	  	// This goes into TRISC, a 1 sets a port pin for input  D   50N:
							// Ports are actually setup by "init_ports()" function  D   51N:
  D   52N:
//   D   53N:
//   Signal Name / Value Defines  D   54N:
   D   55N:
// 	Port RA:  D   56N:
#bit	PWM_In = 0x0F80.2	// PWM bus input pin on PORTA  D   57N:V240
#define PWM_P_Out		3	// A zero sets the bus active  D   58N:
#define	PWM_N_Out		1	// A one sets the bus active (these two bits are used together)  D   59N:
#define	VPW_In			4	// VPW input pin  D   60N:
  D   61N:
// 	Port RB:  D   62N:
#define	VPW_4x			0	// A one selects the VPW 4X speed mode (leave at Zero)  D   63N:
#define	VPW_Out			1	// A one sets bus active  D   64N:
//		CAN_TX			2	// CAN controller TX output  D   65N:
//		CAN_RX			3	// CAN controller RX input  D   66N:
//		TX_debug		4	// Debug mode RS232 output on PORTB  D   67N:
#define	ISO_K_TX		6	// A one sets bus active  D   68N:
#define	ISO_K_RX		5	// ISO K input pin  D   69N:
#define	ISO_L_TX		7	// A one sets bus active  D   70N:
  D   71N:
//  D   72N:
//    CLOCK Speed / Delay:  D   73N:
#use delay (clock=20000000)  D   74N:V242V244
  D   75N:
   D   76N:
//    PIC18F248 TIMER USAGE:  D   77N:
// 	Timer 0 is used by the PWM, VPW & ISO Routines  D   78N:
//			In 8 bit mode, Timer0 is equivalent to Timer0 in the PIC16F628.  D   79N:
// 	Timer 1 is used by the main "C" code program  D   80N:
//			Timer1 is equivalent to Timer1 in the PIC16F628  D   81N:
// 	Timer 2 is used by the VPW Routine  D   82N:
//			Timer2 is equivalent to Timer2 in the PIC16F628  D   83N:
//	Timer 3 is new with the PIC18F248 and is not currently used  D   84N:
//   D   85N:
//    EEPROM:  D   86N:
// 	May be used to store device serial numbers or other non-volatile variables.  D   87N:
//   D   88N:
//    Hardware USART:  D   89N:
// 	Is under the control of the Main "C" code program.  The USART has its own  D   90N:
// 	baud rate generator timer, and does not require the use of Timers 0,1,2 or 3.  D   91N:
//   D   92N:
//    RAM File Allocation:  D   93N:
// 	To maximize the speed of the PWM bus protocol interface, the bus  D   94N:
// 	interface subroutines will have first priority of RAM utilization in  D   95N:
// 	Bank 0.  This minimizes the number of delays that are required for  D   96N:
// 	switching Bank select bits to access variables and hardware registers.  D   97N:
//  D   98N:
//	The PIC18 part has several limprovements over the PIC16 in regards to static RAM  D   99N:
//	accessing.  For one, all the Special Function Registers now exist in bank-15, and  D  100N:
//	are not co-mingled with chunks of RAM.  Each RAM bank is 256 bytes in size.  D  101N:
//   D  102N:
//   D  103N:
// Processor Configuration Words, 6 words, or 12 bytes of configuration data.  D  104N:
// See page 265 of the PIC18FXX8 data sheet for full details.  D  105N:
// See 18F248.h header file for list of CCS compiler settable fuses.  D  106N:
// Location 300000 and up  (This is programed into the part above normal memory space)  D  107N:
//  D  108N:
  D  109N:
//#fuses HS, PROTECT, NOOSCSEN, NOBROWNOUT, NOWDT, PUT, CPD, NOLVP, WRT, WRTD, WRTB, CPB, WRTC, EBTR, EBTRB  D  110N:
#fuses HS, PROTECT, NOOSCSEN, NOBROWNOUT, NOWDT, PUT, NOLVP, WRT, WRTB, CPB, WRTC, EBTR, EBTRB  // removed CPD and WRTD to read/write EEPROM  D  111N:
  D  112N:
	// declares the processor configuration bits  D  113N:
//   D  114N:
//  D  115N:
// *************** End of hardware.h  *************************  D  116N:
#LIST	  D  117 :X1E
 D  117 :
#include "Const.h" A   41 :
 //------------------------------------------------------------------------------  E    1 :I4
// File: Const  E    2 :
//  E    3 :
// Purpose: Project constants.  E    4 :
//  E    5 :
// Change History:  E    6 :
// Date		Author		Description  E    7 :
//          Lafreniere	Created  E    8 :
//------------------------------------------------------------------------------  E    9 :
#ifndef CONST_H  E   10 :
#define CONST_H  E   11 :
  E   12 :
#ifdef DEBUG  E   13 :
    #define TRACE(char) Trace(char);  E   14 :
#else  E   15 :
    #define TRACE(char)   E   16 :
#endif  E   17 :
  E   18 :
// software revision  E   19 :
#define SOFTWARE_REV            0x08  E   20 :
  E   21 :
#define MAX_ECU				8 	// per ISO 15675-4 7.3.3. max ECUs is 8  E   22 :
  E   23 :
#define DEVID1_ADDR 0x3FFFFEL  E   24 :
#define DEVID2_ADDR 0x3FFFFFL   E   25 :
  E   26 :
// The old 18F248 and the new 18F2480 have some differences, mostly in the analog  E   27 :
// to digital converter. Using _DEVID2 check the processor version.   E   28 :
#define VER_18F248				0x08  E   29 :
//#define VER_18F2480 					  E   30 :
  E   31 :
// destination address  E   32 :
#define DESTINATION_ADDR        0x2d  E   33 :
  E   34 :
// from host msg byte positions  E   35 :
#define IDX_HOST_DESTINATION        0  E   36 :
#define IDX_HOST_COMMAND            1  E   37 :
#define IDX_HOST_BYTE_COUNT         2  E   38 :
#define IDX_HOST_START_DATA         3  E   39 :
#define IDX_HOST_CHECKSUM           14  E   40 :
  E   41 :
// to host msg byte positions  E   42 :
#define IDX_VEHICLE_DESTINATION     0  E   43 :
#define IDX_VEHICLE_COMMAND         1  E   44 :
#define IDX_VEHICLE_CHECKSUM        13  E   45 :
  E   46 :
// max size of all messages  E   47 :
#define HOST_RECV_MSG_SIZE          15      // from host size including all non-OBD II bytes  E   48 :
#define HOST_SEND_MSG_SIZE          14      // to host size  E   49 :
#define VEHICLE_MSG_SIZE            12      // to/from max vehicle size, not as sent to host (RSP byte not included)   E   50 :
#define VEHICLE_MAX_MSGS            32      // number of VEHICLE_MSG_SIZE we can store in RAM  E   51 :
  E   52 :
// error codes returned to host  E   53 :
#define ERR_NONE                        0x00   // ERR_NONE must be 0!  E   54 :
#define ERR_NOT_IMPLEMENTED             0x01  E   55 :
#define ERR_BAD_CHECKSUM                0x02  E   56 :
#define ERR_ISO_NO_SYNC                 0x03  E   57 :
#define ERR_ISO_INCORRECT_INV_ADDR      0x04  E   58 :
#define ERR_ISO_NO_RESPONSE             0x05  E   59 :
#define ERR_J1850_NO_RESPONSE           0x07  E   60 :
#define ERR_ISO_BAD_CHECKSUM            0x08  E   61 :
#define ERR_J1850_BAD_CRC               0x09      E   62 :
#define ERR_KWP_BAUD_TOO_SLOW           0x0b    // not used  E   63 :
#define ERR_KWP_NO_RESPONSE             0x0c    // not used  E   64 :
#define ERR_KWP_INCORRECT_SYNC          0x0d    // not used  E   65 :
#define ERR_ISO_NOT_ENABLED             0x10    // not used  E   66 :
#define ERR_J1850_VPW_NOT_ENABLED       0x11    // not used  E   67 :
#define ERR_J1850_PWM_NOT_ENABLED       0x12    // not used  E   68 :
#define ERR_KWP_NOT_ENABLED             0x13    // not used  E   69 :
#define ERR_VW_PASS_THRU_NOT_ENABLED    0x14    // not used  E   70 :
#define ERR_CAN_NO_RESPONSE             0x15	// COMSTAT CAN register returned as extra data  E   71 :
#define ERR_CAN_RX_OVERFLOW             0x16  E   72 :
#define ERR_CAN_TX_BUFFER_UNAVAIL       0x18  E   73 :
#define ERR_CAN_RX_MESSAGE_LEN_WRONG    0x19  E   74 :
#define ERR_CAN_ERROR_INTERRUPT			0x1A	// COMSTAT CAN register returned as extra data  E   75 :
#define ERR_CAN_INVALID_MSG_INTERRUPT   0x1B    // TXBnCON CAN register returned as extra data 1, 2 and 3  E   76 :
#define ERR_ISO_INV_ADDR_NOT_RECEIVED	0x1F  E   77 :
#define ERR_ISO_SYNC_BYTE_NOT_RECEIVED	0x20  E   78 :
  E   79 :
#define ERR_WRONG_DESTINATION           0x80      E   80 :
#define ERR_BYTE_COUNT_TOO_LARGE        0x81  E   81 :
#define ERR_J1850_FRAMING_ERROR         0x82  E   82 :
#define ERR_J1850_MSG_OVERFLOW          0x83   E   83 :
#define ERR_ISO_NO_KEYBYTE              0x84  E   84 :
#define ERR_ADAPTER_LOCKED              0x85  E   85 :
#define ERR_INVALID_NON_VOLATILE_SECTOR 0x86  E   86 :
#define ERR_NON_VOLATILE_SECTOR_LOCKED  0x87  E   87 :
  E   88 :
// host-to-adapter commands  E   89 :
#define CMD_ISO_WITH_5_BAUD             0x01  E   90 :
#define CMD_VPW                         0x02  E   91 :
#define CMD_PWM                         0x04  E   92 :
#define CMD_CAN_SI_250KB                0x08      E   93 :
#define CMD_ISO                         0x10  E   94 :
#define CMD_VW_PASS_THRU_WITH_5_BAUD    0x20    // not used  E   95 :
#define CMD_VW_PASS_THRU_WITHOUT_5_BAUD 0x40    // not used  E   96 :
#define CMD_PWM_WITH_IFR                0x80  E   97 :
#define CMD_ISO_1ST_RESPONSE            0x81  E   98 :
#define CMD_VPW_1ST_RESPONSE            0x82  E   99 :
#define CMD_ATOD_CONVERSION             0x83    // not used  E  100 :
#define CMD_PWM_1ST_RESPONSE            0x84  E  101 :
#define CMD_KWP_WITH_5_BAUD             0x85  E  102 :
#define CMD_KWP_REPORT_KW1_KW2          0x86    // not used  E  103 :
#define CMD_KWP_FAST_INIT               0x87  E  104 :
#define CMD_KWP                         0x88  E  105 :
#define CMD_KWP_1ST_RESPONSE            0x89  E  106 :
#define CMD_CAN_SI_500KB                0x90  E  107 :
#define CMD_CAN_EI_250KB                0x91  E  108 :
#define CMD_CAN_EI_500KB                0x92  E  109 :
#define CMD_CAN_SI_250KB_1ST            0x93  E  110 :
#define CMD_CAN_SI_500KB_1ST            0x94  E  111 :
#define CMD_CAN_EI_250KB_1ST            0x95  E  112 :
#define CMD_CAN_EI_500KB_1ST            0x96  E  113 :
#define CMD_CAN_SET_STD_MASK_FILTER		0x97  E  114 :
#define CMD_CAN_SET_XTD_MASK_FILTER		0x98  E  115 :
#define CMD_CAN_SET_P2_CAN_TIMEOUT		0x99  E  116 :
#define CMD_CAN_SI_250KB_FBGO			0x9A	// FBGO = fast bus get off  E  117 :
#define CMD_CAN_SI_500KB_FBGO			0x9B	// FBGO = fast bus get off  E  118 :
#define CMD_CAN_EI_250KB_FBGO			0x9C	// FBGO = fast bus get off  E  119 :
#define CMD_CAN_EI_500KB_FBGO			0x9D	// FBGO = fast bus get off  E  120 :
#define CMD_CAN_SI_250KB_LISTEN			0x9E	  E  121 :
#define CMD_CAN_SI_500KB_LISTEN			0x9F	  E  122 :
#define CMD_CAN_EI_250KB_LISTEN			0xA0	  E  123 :
#define CMD_CAN_EI_500KB_LISTEN			0xA1  E  124 :
#define CMD_CAN_SI_250KB_NO_RESPONSE	0xA2	  E  125 :
#define CMD_CAN_SI_500KB_NO_RESPONSE	0xA3	  E  126 :
#define CMD_CAN_EI_250KB_NO_RESPONSE	0xA4	  E  127 :
#define CMD_CAN_EI_500KB_NO_RESPONSE	0xA5  E  128 :
#define CMD_ISO_NO_RESPONSE				0xA6  E  129 :
#define CMD_ISO_ENABLE_L_LINE_XMIT		0xA9  E  130 :
#define CMD_ISO_SET_9600_BAUD			0xAB  E  131 :
#define CMD_ISO_CHECKSUM_ENABLE			0xAC  E  132 :
#define CMD_ISO_5MS_BYTE_DELAY_ENABLE	0xAD  E  133 :
#define CMD_UNLOCK_ADAPTER              0xB0	  E  134 :
#define CMD_READ_EEPROM					0xB9  E  135 :
#define CMD_WRITE_EEPROM				0xBA  E  136 :
#define CMD_KWP_FAST_INIT_9600			0xC4  E  137 :
#define CMD_READ_BATTERY_VOLTAGE		0xF0  E  138 :
  E  139 :
// adapter-to-host commands  E  140 :
#define CMD_ERROR                       0x80  E  141 :
#define CMD_ISO_MSG                     0x81  E  142 :
#define CMD_VPW_MSG                     0x82  E  143 :
#define CMD_PWM_MSG                     0x84  E  144 :
#define CMD_CAN_MSG                     0x88  E  145 :
#define CMD_KWP_MSG                     0x01  E  146 :
#define CMD_LOCAL_DATA					0x40  E  147 :
  E  148 :
// transmit modes (must fit in 3-bits!)  E  149 :
#define MODE_ISO                 0x00  E  150 :
#define MODE_VPW                 0x01  E  151 :
#define MODE_PWM                 0x02  E  152 :
#define MODE_KWP                 0x03  E  153 :
#define MODE_CAN                 0x04  E  154 :
  E  155 :
// interface capabilites (i.e. what com modes does the adapter support)  E  156 :
#define CAP_ISO         0x01  E  157 :
#define CAP_VPW         0x02  E  158 :
#define CAP_PWM         0x04  E  159 :
#define CAP_KWP         0x08  E  160 :
#define CAP_CAN         0x10  E  161 :
#define CAP_DUAL_CAN	0x20  E  162 :
#define DASH_DYNO_VER	0x40  E  163 :
#ifdef DASH_DYNO  E  164 :
#define CAP_INTERFACE   (CAP_ISO | CAP_VPW | CAP_PWM | CAP_KWP | CAP_CAN | DASH_DYNO_VER)  E  165 :
#else  E  166 :
#define CAP_INTERFACE   (CAP_ISO | CAP_VPW | CAP_PWM | CAP_KWP | CAP_CAN)  E  167 :
#endif  E  168 :
  E  169 :
#endif   E  170 :E
 E  170 :
#include "Globals.h" A   42 :
 //------------------------------------------------------------------------------  F    1 :I5
// File: Globals  F    2 :
//  F    3 :
// Purpose: Project global variables.  F    4 :
//  F    5 :
// Change History:  F    6 :
// Date		Author		Description  F    7 :
//          Lafreniere	Created  F    8 :
//------------------------------------------------------------------------------  F    9 :
#ifndef GLOBALS_H  F   10 :
#define GLOBALS_H  F   11 :
  F   12 :
#include "Const.h" F   13 :
 //------------------------------------------------------------------------------  E    1 :I4
// File: Const  E    2 :
//  E    3 :
// Purpose: Project constants.  E    4 :
//  E    5 :
// Change History:  E    6 :
// Date		Author		Description  E    7 :
//          Lafreniere	Created  E    8 :
//------------------------------------------------------------------------------  E    9 :
#ifndef CONST_H  E   10 :
#define CONST_H  E   11 :
  E   12 :
#ifdef DEBUG  E   13 :
    #define TRACE(char) Trace(char);  E   14 :
#else  E   15 :
    #define TRACE(char)   E   16 :
#endif  E   17 :
  E   18 :
// software revision  E   19 :
#define SOFTWARE_REV            0x08  E   20 :
  E   21 :
#define MAX_ECU				8 	// per ISO 15675-4 7.3.3. max ECUs is 8  E   22 :
  E   23 :
#define DEVID1_ADDR 0x3FFFFEL  E   24 :
#define DEVID2_ADDR 0x3FFFFFL   E   25 :
  E   26 :
// The old 18F248 and the new 18F2480 have some differences, mostly in the analog  E   27 :
// to digital converter. Using _DEVID2 check the processor version.   E   28 :
#define VER_18F248				0x08  E   29 :
//#define VER_18F2480 					  E   30 :
  E   31 :
// destination address  E   32 :
#define DESTINATION_ADDR        0x2d  E   33 :
  E   34 :
// from host msg byte positions  E   35 :
#define IDX_HOST_DESTINATION        0  E   36 :
#define IDX_HOST_COMMAND            1  E   37 :
#define IDX_HOST_BYTE_COUNT         2  E   38 :
#define IDX_HOST_START_DATA         3  E   39 :
#define IDX_HOST_CHECKSUM           14  E   40 :
  E   41 :
// to host msg byte positions  E   42 :
#define IDX_VEHICLE_DESTINATION     0  E   43 :
#define IDX_VEHICLE_COMMAND         1  E   44 :
#define IDX_VEHICLE_CHECKSUM        13  E   45 :
  E   46 :
// max size of all messages  E   47 :
#define HOST_RECV_MSG_SIZE          15      // from host size including all non-OBD II bytes  E   48 :
#define HOST_SEND_MSG_SIZE          14      // to host size  E   49 :
#define VEHICLE_MSG_SIZE            12      // to/from max vehicle size, not as sent to host (RSP byte not included)   E   50 :
#define VEHICLE_MAX_MSGS            32      // number of VEHICLE_MSG_SIZE we can store in RAM  E   51 :
  E   52 :
// error codes returned to host  E   53 :
#define ERR_NONE                        0x00   // ERR_NONE must be 0!  E   54 :
#define ERR_NOT_IMPLEMENTED             0x01  E   55 :
#define ERR_BAD_CHECKSUM                0x02  E   56 :
#define ERR_ISO_NO_SYNC                 0x03  E   57 :
#define ERR_ISO_INCORRECT_INV_ADDR      0x04  E   58 :
#define ERR_ISO_NO_RESPONSE             0x05  E   59 :
#define ERR_J1850_NO_RESPONSE           0x07  E   60 :
#define ERR_ISO_BAD_CHECKSUM            0x08  E   61 :
#define ERR_J1850_BAD_CRC               0x09      E   62 :
#define ERR_KWP_BAUD_TOO_SLOW           0x0b    // not used  E   63 :
#define ERR_KWP_NO_RESPONSE             0x0c    // not used  E   64 :
#define ERR_KWP_INCORRECT_SYNC          0x0d    // not used  E   65 :
#define ERR_ISO_NOT_ENABLED             0x10    // not used  E   66 :
#define ERR_J1850_VPW_NOT_ENABLED       0x11    // not used  E   67 :
#define ERR_J1850_PWM_NOT_ENABLED       0x12    // not used  E   68 :
#define ERR_KWP_NOT_ENABLED             0x13    // not used  E   69 :
#define ERR_VW_PASS_THRU_NOT_ENABLED    0x14    // not used  E   70 :
#define ERR_CAN_NO_RESPONSE             0x15	// COMSTAT CAN register returned as extra data  E   71 :
#define ERR_CAN_RX_OVERFLOW             0x16  E   72 :
#define ERR_CAN_TX_BUFFER_UNAVAIL       0x18  E   73 :
#define ERR_CAN_RX_MESSAGE_LEN_WRONG    0x19  E   74 :
#define ERR_CAN_ERROR_INTERRUPT			0x1A	// COMSTAT CAN register returned as extra data  E   75 :
#define ERR_CAN_INVALID_MSG_INTERRUPT   0x1B    // TXBnCON CAN register returned as extra data 1, 2 and 3  E   76 :
#define ERR_ISO_INV_ADDR_NOT_RECEIVED	0x1F  E   77 :
#define ERR_ISO_SYNC_BYTE_NOT_RECEIVED	0x20  E   78 :
  E   79 :
#define ERR_WRONG_DESTINATION           0x80      E   80 :
#define ERR_BYTE_COUNT_TOO_LARGE        0x81  E   81 :
#define ERR_J1850_FRAMING_ERROR         0x82  E   82 :
#define ERR_J1850_MSG_OVERFLOW          0x83   E   83 :
#define ERR_ISO_NO_KEYBYTE              0x84  E   84 :
#define ERR_ADAPTER_LOCKED              0x85  E   85 :
#define ERR_INVALID_NON_VOLATILE_SECTOR 0x86  E   86 :
#define ERR_NON_VOLATILE_SECTOR_LOCKED  0x87  E   87 :
  E   88 :
// host-to-adapter commands  E   89 :
#define CMD_ISO_WITH_5_BAUD             0x01  E   90 :
#define CMD_VPW                         0x02  E   91 :
#define CMD_PWM                         0x04  E   92 :
#define CMD_CAN_SI_250KB                0x08      E   93 :
#define CMD_ISO                         0x10  E   94 :
#define CMD_VW_PASS_THRU_WITH_5_BAUD    0x20    // not used  E   95 :
#define CMD_VW_PASS_THRU_WITHOUT_5_BAUD 0x40    // not used  E   96 :
#define CMD_PWM_WITH_IFR                0x80  E   97 :
#define CMD_ISO_1ST_RESPONSE            0x81  E   98 :
#define CMD_VPW_1ST_RESPONSE            0x82  E   99 :
#define CMD_ATOD_CONVERSION             0x83    // not used  E  100 :
#define CMD_PWM_1ST_RESPONSE            0x84  E  101 :
#define CMD_KWP_WITH_5_BAUD             0x85  E  102 :
#define CMD_KWP_REPORT_KW1_KW2          0x86    // not used  E  103 :
#define CMD_KWP_FAST_INIT               0x87  E  104 :
#define CMD_KWP                         0x88  E  105 :
#define CMD_KWP_1ST_RESPONSE            0x89  E  106 :
#define CMD_CAN_SI_500KB                0x90  E  107 :
#define CMD_CAN_EI_250KB                0x91  E  108 :
#define CMD_CAN_EI_500KB                0x92  E  109 :
#define CMD_CAN_SI_250KB_1ST            0x93  E  110 :
#define CMD_CAN_SI_500KB_1ST            0x94  E  111 :
#define CMD_CAN_EI_250KB_1ST            0x95  E  112 :
#define CMD_CAN_EI_500KB_1ST            0x96  E  113 :
#define CMD_CAN_SET_STD_MASK_FILTER		0x97  E  114 :
#define CMD_CAN_SET_XTD_MASK_FILTER		0x98  E  115 :
#define CMD_CAN_SET_P2_CAN_TIMEOUT		0x99  E  116 :
#define CMD_CAN_SI_250KB_FBGO			0x9A	// FBGO = fast bus get off  E  117 :
#define CMD_CAN_SI_500KB_FBGO			0x9B	// FBGO = fast bus get off  E  118 :
#define CMD_CAN_EI_250KB_FBGO			0x9C	// FBGO = fast bus get off  E  119 :
#define CMD_CAN_EI_500KB_FBGO			0x9D	// FBGO = fast bus get off  E  120 :
#define CMD_CAN_SI_250KB_LISTEN			0x9E	  E  121 :
#define CMD_CAN_SI_500KB_LISTEN			0x9F	  E  122 :
#define CMD_CAN_EI_250KB_LISTEN			0xA0	  E  123 :
#define CMD_CAN_EI_500KB_LISTEN			0xA1  E  124 :
#define CMD_CAN_SI_250KB_NO_RESPONSE	0xA2	  E  125 :
#define CMD_CAN_SI_500KB_NO_RESPONSE	0xA3	  E  126 :
#define CMD_CAN_EI_250KB_NO_RESPONSE	0xA4	  E  127 :
#define CMD_CAN_EI_500KB_NO_RESPONSE	0xA5  E  128 :
#define CMD_ISO_NO_RESPONSE				0xA6  E  129 :
#define CMD_ISO_ENABLE_L_LINE_XMIT		0xA9  E  130 :
#define CMD_ISO_SET_9600_BAUD			0xAB  E  131 :
#define CMD_ISO_CHECKSUM_ENABLE			0xAC  E  132 :
#define CMD_ISO_5MS_BYTE_DELAY_ENABLE	0xAD  E  133 :
#define CMD_UNLOCK_ADAPTER              0xB0	  E  134 :
#define CMD_READ_EEPROM					0xB9  E  135 :
#define CMD_WRITE_EEPROM				0xBA  E  136 :
#define CMD_KWP_FAST_INIT_9600			0xC4  E  137 :
#define CMD_READ_BATTERY_VOLTAGE		0xF0  E  138 :
  E  139 :
// adapter-to-host commands  E  140 :
#define CMD_ERROR                       0x80  E  141 :
#define CMD_ISO_MSG                     0x81  E  142 :
#define CMD_VPW_MSG                     0x82  E  143 :
#define CMD_PWM_MSG                     0x84  E  144 :
#define CMD_CAN_MSG                     0x88  E  145 :
#define CMD_KWP_MSG                     0x01  E  146 :
#define CMD_LOCAL_DATA					0x40  E  147 :
  E  148 :
// transmit modes (must fit in 3-bits!)  E  149 :
#define MODE_ISO                 0x00  E  150 :
#define MODE_VPW                 0x01  E  151 :
#define MODE_PWM                 0x02  E  152 :
#define MODE_KWP                 0x03  E  153 :
#define MODE_CAN                 0x04  E  154 :
  E  155 :
// interface capabilites (i.e. what com modes does the adapter support)  E  156 :
#define CAP_ISO         0x01  E  157 :
#define CAP_VPW         0x02  E  158 :
#define CAP_PWM         0x04  E  159 :
#define CAP_KWP         0x08  E  160 :
#define CAP_CAN         0x10  E  161 :
#define CAP_DUAL_CAN	0x20  E  162 :
#define DASH_DYNO_VER	0x40  E  163 :
#ifdef DASH_DYNO  E  164 :
#define CAP_INTERFACE   (CAP_ISO | CAP_VPW | CAP_PWM | CAP_KWP | CAP_CAN | DASH_DYNO_VER)  E  165 :
#else  E  166 :
#define CAP_INTERFACE   (CAP_ISO | CAP_VPW | CAP_PWM | CAP_KWP | CAP_CAN)  E  167 :
#endif  E  168 :
  E  169 :
#endif   E  170 :E
 E  170 :
#include "Timer.h" F   14 :
 //------------------------------------------------------------------------------  G    1 :I6
// File: Timer  G    2 :
//  G    3 :
// Purpose: High speed timer (HST) routines.   G    4 :
//  G    5 :
// Change History:  G    6 :
// Date		Author		Description  G    7 :
//          Lafreniere	Created  G    8 :
//------------------------------------------------------------------------------  G    9 :
#ifndef TIMER_H  G   10 :
#define TIMER_H  G   11 :
  G   12 :
#define TIMER1_TIMEOUT          0     // 1.6uS per tick with div set to 8  G   13 :
#define MS_TO_TICKS(mS) 		((mS * 10000) / 16)	  // 1.6uS per tick  G   14 :
  G   15 :
// max 16-bit number  G   16 :
#define HST_TWO_MS              1250  G   17 :
#define HST_TEN_MS              6250  G   18 :
#define HST_TWENTY_FIVE_MS      15625  G   19 :
#define HST_FIFTY_MS            31250  G   20 :
#define HST_FIVE_HUNDRED_MS		312500	// NOTE: this number exceeds 16-bit timer and must be used with Int32  G   21 :
#define HST_ONE_S				625000	// NOTE: this number exceeds 16-bit timer and must be used with Int32  G   22 :
  G   23 :
typedef int16 HstTimer; //TBD DEBUG  G   24 :V245
//typedef int32 HstTimer;  G   25 :
              G   26 :
HstTimer HstGetTicks(void) { return get_timer1(); }  G   27 :f1499{16}19
BOOLEAN HstTestTimer(HstTimer timer, HstTimer ticks);  G   28 :f1500V249V250P1500
BOOLEAN HstTestTimerRetrig(HstTimer *timer, HstTimer ticks);  G   29 :f1503V252V253P1503
HstTimer HstElapsedTime(HstTimer timer);  G   30 :f1504V255P1504
  G   31 :
#endif  G   32 :E
 G   32 :
                   F   15 :
typedef struct   F   16 :
{  F   17 :
    int8 comType : 3;  F   18 :T256
    int8 firstResp : 1;  F   19 :
	int8 forceInitCAN : 1;  F   20 :
    int8 canModeChanged : 1;  // true when mode changes (e.g. 250kb to 500kb, or SI to EI)  F   21 :
    int8 adapterLocked : 1;  F   22 :
	int8 enableLLineXmit : 1; 		// transmit at 10.4 on both K and L lines (default is K line only)  F   23 :
	int8 enableIso9600Baud : 1;		// transmit ISO at 9600 if true, false means 10.4k (default is 10.4k)  F   24 :
	int8 enableIso5msByteDelay : 1; // true means 5mS between each byte sent to vehicle, false no delay (default is true)  F   25 :
	int8 enableIsoChecksum : 1;		// add checksum byte to ISO messages if true, no byte added if false (default is true)  F   26 :
} Flags;  F   27 :
  F   28 :
int8 gDevid1;  F   29 :V267
int8 gDevid2;  F   30 :V268
  F   31 :
Flags gFlags = { MODE_ISO, FALSE };  F   32 :V269
int8 gError = ERR_NONE;  F   33 :V270
int8 gErrorExtraData1 = 0;  F   34 :V271
int8 gErrorExtraData2 = 0;  F   35 :V272
int8 gErrorExtraData3 = 0;  F   36 :V273
  F   37 :
int8 gHostBuf[HOST_RECV_MSG_SIZE];  F   38 :V274
//*** #locate gHostBuf=0x2d  // pic18f248 should not require ram to be managed  F   39 :
int8 gHostBufCnt = 0;  F   40 :V275
int16 gHostRecvTimeout = 0;  F   41 :V276
  F   42 :
int8 gVehicleBuf[VEHICLE_MAX_MSGS][VEHICLE_MSG_SIZE];  F   43 :V277
//*** #locate gVehicleBuf=0xa0  F   44 :
  F   45 :
int8 gVehicleBufCnt = 0;  F   46 :V279
  F   47 :
int8 gCurrentCmd = 0;   // current command sent from host  F   48 :V280
int8 gLastCmd = 0;      // last command sent from host  F   49 :V281
  F   50 :
int32 gP2can = HST_FIFTY_MS;  F   51 :V282
  F   52 :
// decyption variables  F   53 :
int16  gLfsr;  F   54 :V283
//int8 gLast;  F   55 :
  F   56 :
#endif  F   57 :E
 F   57 :
  A   43 :
#include "PWM-02.c" A   44 :
 //------------------------------------------------------------------------------  H    1 :I7
// File: pwm-01.c  H    2 :
//  H    3 :
// Purpose: PWM Bus Interface  H    4 :
//  H    5 :
// Change History:  H    6 :
// Date		Author		Description  H    7 :
//          Bernie		Created  H    8 :
// August 2003 - updated for operation with the PIC18F248   H    9 :
//------------------------------------------------------------------------------  H   10 :
  H   11 :
#include "glob_bus.h" H   12 :
 //------------------------------------------------------------------------------  I    1 :I8
// File: Glob_bus.h  I    2 :
//  I    3 :
// Purpose: Bus Interface global variables.  I    4 :
//  I    5 :
// Change History:  I    6 :
// Date		Author		Description  I    7 :
//          Bernie		Created  I    8 :
//------------------------------------------------------------------------------  I    9 :
#ifndef GLOB_BUS_H  I   10 :
#define GLOB_BUS_H  I   11 :
  I   12 :
  I   13 :
//  ************ Global Bus Protocol Variable for VPW & PWM Routines ****************  I   14 :
  I   15 :
  I   16 :
int8	LinkControl;		// Data Link Control & Status Register  I   17 :V284
#locate LinkControl=0x26  I   18 :
	/* defines for the LinkControl variable bit positions */  I   19 :
#bit MsgRecvd = LinkControl.0		// An incomming message was received  I   20 :
#bit FrError = LinkControl.1		// A framing error was detected  I   21 :V285
#bit InFrResp = LinkControl.2		// An inframe response was received  I   22 :V286
#bit MsgSent = LinkControl.3		// The TX message has been sent  I   23 :V287
#bit MsgOverflow = LinkControl.4 	// A received message is longer than VEHICLE_MSG_SIZE  I   24 :V288
#bit NoBusActivity = LinkControl.5 	// Bus stuck, maximum bus acccess time exceeded  I   25 :V289
  I   26 :
  I   27 :
int8	LinkFlags;			// Local Data Link operation flags  I   28 :V290V291
#locate LinkFlags=0x27  I   29 :
#bit EOD			= LinkFlags.0	// End of Data Flag  I   30 :
#bit EOF 			= LinkFlags.1	// End of Frame Flag  I   31 :V292
#bit NxtBit 		= LinkFlags.2	// Value of next bit to transmit  I   32 :V293
#bit Act_phase_flag	= LinkFlags.3 	// VPW active phase flag  I   33 :V294
  I   34 :
int8	ShiftReg;			// Data Byte shift register, need to be in Bank0  I   35 :V295V296
#locate ShiftReg=0x28  I   36 :
int8	MaskReg;			// Mask Register, needs to be in Bank0  I   37 :V297
#locate MaskReg=0x29  I   38 :
int8	PhaseTime;			// VPW active or passive phase time, needs to be in Bank0  I   39 :V298
#locate PhaseTime=0x2a  I   40 :
int8	BusByteCntr;		// Byte counter used in all PWM & VPW routines  I   41 :V299
#locate	BusByteCntr=0x2b  I   42 :
int8	BusBuffPntr_low;		// Buffer Pointer used in all PWM & VPW routines  I   43 :V300
#locate	BusBuffPntr_low=0x2c  I   44 :
int8	BusBuffPntr_high;		  I   45 :V301
#locate	BusBuffPntr_high=0x2d  I   46 :
int8	BusTimeOut;			// Used to determine if bus is stuck for error exit  I   47 :V302
#locate BusTimeOut=0x2e	  I   48 :
int16	BusBuffPntr;		// Buffer Pointer used in all PWM & VPW routines  I   49 :V303
#locate	BusBuffPntr=0x2f  I   50 :
int8	BSR_temp;			// Temporary storage for Bank Select Register  I   51 :V304
#locate	BSR_temp=0x31  I   52 :
  I   53 :
#endif  I   54 :
  I   55 :
  I   56 :E
 I   56 :
#include "util.h" H   13 :
 //------------------------------------------------------------------------------  J    1 :I9
// File: Util  J    2 :
//  J    3 :
// Purpose: Misc utility routines.   J    4 :
//  J    5 :
// Change History:  J    6 :
// Date		Author		Description  J    7 :
//          Lafreniere	Created  J    8 :
//------------------------------------------------------------------------------  J    9 :
#ifndef UTIL_H  J   10 :
#define UTIL_H  J   11 :
  J   12 :
// starting address for the 4-byte EEPOM write protect table  J   13 :
#define EEPROM_WRITE_PROTECT_TABLE_ADDR 	252  J   14 :
  J   15 :
// the logical sector size is arbitrary and has nothing to do with the PIC hardware  J   16 :
#define EEPROM_SECTOR_SIZE 	8  J   17 :
  J   18 :
void ReadEeprom();  J   19 :f1556P1556
void ReadEepromLocal(int8 sector);  J   20 :f1557V307P1557
void WriteEeprom();  J   21 :f1559P1559
int8 IsEepromSectorWriteProtected(int8 sector);  J   22 :f1560V310P1560
int32 ReadEepromSectorWriteProtectTable();  J   23 :f1561P1561
void WriteEerpomSectorWriteProtectTable(int32 writeProtectBits);  J   24 :f1562V313P1562
void init_ports();  J   25 :f1564P1564
void Bus_If_Init(void);  J   26 :f1565P1565
void DecryptBlock(int8 *outbfr, int8 *inbfr);  J   27 :f1566V317V318P1566
int8 IsCmdCAN(int8 cmd);  J   28 :f1569V320P1569
int8 IsCmdLocal(int8 cmd);  J   29 :f1571V322P1571
int8 IsCmdFBGO(int8 cmd);  J   30 :f1572V324P1572
int8 IsCmdListen(int8 cmd);  J   31 :f1573V326P1573
int8 IsCmdNoResponse(int8 cmd);  J   32 :f1574V328P1574
int8 IsCmdFirstResp(int8 cmd);  J   33 :f1575V330P1575
int8 IsCmdStandardId(int8 cmd);  J   34 :f1576V332P1576
int8 IsCmd250kb(int8 cmd);  J   35 :f1577V334P1577
int8 checksum(int8* pMsg, int8 size);  J   36 :f1578V336V337P1578
int8 crc8(int8* buffer, int8 count);  J   37 :f1581V339V340P1581
int32 StrToInt32(int8* str);  J   38 :f1584V342P1584
int8 TraceStr(int8* pMsg, int8 size);  J   39 :f1586V344V345P1586
int8 Trace(int8 msg);  J   40 :f1587V347P1587
  J   41 :
#endif  J   42 :E
 J   42 :
  H   14 :
// *************** INITIALIZE TIMER 2 ****************************  H   15 :
//   H   16 :
//  TIMER 2 IS INITIALIZED TO RUN AT 1/4 THE OSCILLATOR RATE (5MHZ = 200NS / CNT)  H   17 :
//  ITS LEFT TO FREE RUN, WE SET UP THE PR2 COMPARE REGISTER SO THAT THE COUNTER  H   18 :
//  AUTOMATICALLY RESTARTS AFTER REACHING THE COUNT SET IN THE PR2 REGISTER.  H   19 :
//   H   20 :
//  WE WILL LOOP ON THE OVERFLOW BIT TO KNOW WHEN THE COUNT HAS ROLLED OVER  H   21 :
//   H   22 :
//  THIS COUNTER IS BEING USED TO TIME THE TRANSMITTED BIT CELLS:  H   23 :
//  IN PWM, THE TIMER IS SET TO ROLLOVER EVERY 8US (24US BITCELL /3 = 8US)  H   24 :
//   H   25 :
//  Here is the code to test if we have reached or exceeded a given timer value  H   26 :
  H   27 :
//timer2_wait_loop  H   28 :
// 	btfss		PIR1, TMR2IF	//  the bit will be set on rollover  H   29 :
// 	goto		timer2_wait_loop  H   30 :
// 	bcf	PIR1, 	TMR2IF			//  Yes we timed out, now clear the bit & continue  H   31 :
// 	continue with code  H   32 :
  H   33 :
void tmr2_init() {  H   34 :f1589{71
	setup_timer_2 (T2_DIV_BY_1, 39, 1);  H   35 :
				// setup Timer2, as an 8us period timer (3 * 8us = 24us) a bit cell  H   36 :
				// Set Prescaler 1:1  H   37 :
				// 39 = count for a 8 us period ( 8us/200ns = 40 -1 decimal)  H   38 :
				// Set Postscale Count 1:1  H   39 :
}  H   40 :}73
  H   41 :
  H   42 :
// ************  Entry for Receiving a PWM message  ***********  H   43 :
//   H   44 :
int8 PWMRecv(int16* RxBufferPntr, int8* RxCntPntr, int8 timeout) {  H   45 :f1590V350V351V352{75
	BusTimeOut = timeout;   	// Maximum Bus Inactivity Time Out Counter   H   46 :
								// approx 2 msec per count  H   47 :
	Bus_If_Init(); 				// Initialize local variables & timers  H   48 :
	BusBuffPntr = RxBufferPntr;  H   49 :
	BusBuffPntr_low = make8(BusBuffPntr, 0);  // load the pointer address for indirect addressing  H   50 :
	BusBuffPntr_high = make8(BusBuffPntr, 1);  H   51 :
  H   52 :
	#asm  H   53 :
	movff	BusBuffPntr_low, FSR0L  H   54 :
	movff	BusBuffPntr_high, FSR0H  H   55 :
  H   56 :
	bcf		PIR1, TMR2IF		// make sure timer 2 overflow bit is reset  H   57 :
wait_bus_activity1:  H   58 :
	btfss	PIR1, TMR2IF  H   59 :
	goto	wait_bus_activity2  H   60 :
	bcf		PIR1, TMR2IF  H   61 :
	decf	BusTimeOut, f		//check if Bus Access has timed out	  H   62 :
	btfsc	STATUS, Z  H   63 :
	goto	RxBusInactivityExit  H   64 :
  H   65 :
wait_bus_activity2:  H   66 :
	clrf	TMR0L				// restart timer at 400ns per count  H   67 :
bus_active1:  H   68 :
	btfss 	PWM_In				// skips next inst if bus active  H   69 :
	goto	wait_bus_activity1  H   70 :
								// we have an active bus now  H   71 :
	movlw 	( 28000 /400 )		// (desired time in ns)/400ns cylce time  H   72 :
	subwf	TMR0L, W			// subtract from the current timer value  H   73 :
								// look for a minimum SOF pulse of 29us (in nanoseconds)  H   74 :
	btfss	STATUS, C			//  "C" is set if time equal or exceeded  H   75 :
	goto	bus_active1			// loop until we find a pulse longer than 28us  H   76 :
   H   77 :
wait_SOF_drop:					// we have found a SOF, now wait for it to fall  H   78 :
	movlw 	( 38000 /400 )		// (desired time in ns)/400ns cylce time  H   79 :
	subwf	TMR0L, W			// subtract from the current timer value  H   80 :
								// Check if bus stays high longer than 38us (could be a break pulse)  H   81 :
	btfsc	STATUS, C			//  "C" is set if time equal or exceeded  H   82 :
	goto	FrError_Exit		// take the framing error exit if pulse is too long  H   83 :
	btfsc 	PWM_In				// check PWM_IN skip next inst when bus goes passive  H   84 :
	goto	wait_SOF_drop  H   85 :
								// SOF has dropped  H   86 :
	#endasm  H   87 :
	setup_timer_2( T2_DIV_BY_1, 255, 1 );			//  intialize timer2 for 200ns counting  H   88 :
	#asm   H   89 :
  H   90 :
wait_data_bit:					// now wait for rising edge of first data bit  H   91 :
	clrf	TMR2				// restart timer 2 to time bit cell  H   92 :
	btfsc 	PWM_In				// skips next inst as long as bus stays passive  H   93 :
	goto	first_bit  H   94 :
	movlw 	( 63000 /400 )		// (desired time in ns)/400ns cylce time  H   95 :
	subwf	TMR0L, W			// subtract from the current timer value  H   96 :
								// check if SOF has been down too long (frerror or break)  H   97 :
	btfss	STATUS, C			//  "C" is set if time equal or exceeded	  H   98 :
	goto 	wait_data_bit		// loop back & check bus state again  H   99 :
 	goto	FrError_Exit		// exit if 1st bit does not arrive in time  H  100 :
  H  101 :
first_bit:						// start getting the data bits  H  102 :
get_data_bits:				  H  103 :
	movlw	0b00000001			// prime the RX shift register  H  104 :
	movwf	ShiftReg  H  105 :
get_inframe_response:			// entry point for getting the in-frame response bytes			  H  106 :
wait_bit_fall:  H  107 :
	btfss 	PWM_In				// skips next inst as long as bus stays active  H  108 :
	goto	the_bit_fell  H  109 :
	movlw 	( 22000 /200 )		// (desired time in ns)/200ns cylce time  H  110 :
	subwf	TMR2, W				// subtract from the current timer value  H  111 :
								// check if active phase of bit cell is up too long  H  112 :
	btfss	STATUS, C			//  "C" is set if time equal or exceeded	  H  113 :
	goto 	wait_bit_fall		// loop back & check bus state again  H  114 :
	goto	FrError_Exit		// it was up too long, take framing error exit  H  115 :
   H  116 :
the_bit_fell:					// bit fell, now check if this was a one or a zero  H  117 :
	movlw 	( 12500 /200 )		// (desired time in ns)/200ns cylce time  H  118 :
	subwf	TMR2, W				// subtract from the current timer value  H  119 :
								// check if active phase of bit cell was longer than 12.5us  H  120 :
	btfss	STATUS, C			//  "C" is set if 12.5us has been equaled or exceeded  H  121 :
	goto	shift_in_a_1		// it was a 1 if less than 12.5us  H  122 :
	bcf		STATUS, C			// clear C becuse we want to rotate in a zero	  H  123 :
	goto 	shift_it_in			// it was a 0 if more than 12.5us  H  124 :
  H  125 :
  H  126 :
read_another_bit:  H  127 :
	clrf	TMR2				// clear timer to time next bit  H  128 :
	goto	wait_bit_fall  H  129 :
  H  130 :
FrError_Exit:  H  131 :
	bsf		FrError 			// set framing error flag in link control register  H  132 :
	goto	RX_PWM_Exit  H  133 :
  H  134 :
MsgError_Exit:  H  135 :
	bsf		MsgOverflow			// set overflow error flag in link control register  H  136 :
	goto	RX_PWM_Exit  H  137 :
  H  138 :
RxBusInactivityExit:  H  139 :
	bsf		NoBusActivity		// set the error flag bit in LinkControl  H  140 :
	goto	RX_PWM_Exit2		// error exit if bus is stuck busy  H  141 :
  H  142 :
					  H  143 :
shift_in_a_1:  H  144 :
	bsf		STATUS, C			// set C for rotation of a 1 into register  H  145 :
shift_it_in:  H  146 :
	rlcf	ShiftReg, F			// rotate the C bit into the LSB position (data comes in MSB first)  H  147 :
								// after 8 rotations, the first bit in will be in the MSB position  H  148 :
	btfss	STATUS, C			// register is full when the preset one bit comes out  H  149 :
	goto	wait_strt_nxt_bit  	// branch if register not full yet  H  150 :
								// shift register is full, save the byte  H  151 :
  H  152 :
	incf	BusByteCntr, F		// add one to the received bytes count  H  153 :
	movlw	VEHICLE_MSG_SIZE+1	// check if we have exceeded the maximum msg size  H  154 :
	subwf	BusByteCntr, W  H  155 :
	btfsc	STATUS, C			// 'C' will be set when we are oversize  H  156 :
	goto	MsgError_Exit		// its an error if we are over the max byte count  H  157 :
  H  158 :
	movf	ShiftReg, W			// shift register is full, save the accumulated byte to RxBuffer  H  159 :
 	movwf	INDF0  H  160 :
	incf	FSR0L, F			// advance indirect memory pointer to next byte	  H  161 :
	movlw	0b00000001			// prime the shift register again  H  162 :
	movwf	ShiftReg			  H  163 :
			  H  164 :
  H  165 :
//  **** delete support for In Frame Response  H  166 :
//InFrame_Ck:					// now lets check if there is an inframe response  H  167 :
//	btfsc 	PWM_In				// check to see if inframe response active phase shows up			  H  168 :
//	goto 	Ck_InFrame_Status	// executes this inst if bus goes back active  H  169 :
//	movlw 	( 66000 /400 )		// (desired time in ns)/400ns cylce time  H  170 :
//	subwf	TMR0L, W			// subtract from the current timer value  H  171 :
//								// check if bus stays passive longer than 66us  H  172 :
//	btfss	STATUS, C			//  "C" is set if 66us has been equaled or exceeded  H  173 :
//	goto	InFrame_Ck			// loop back & wait until bus is inactive for 66us  H  174 :
//  ******************  H  175 :
  H  176 :
//  **** delete support for In Frame Response  H  177 :
//Ck_InFrame_Status:  H  178 :
//	clrf	TMR0L				// restart timer0 to start timing 1st inframe response bit  H  179 :
//	btfsc	InFrResp			// test if we have already detected an inframe response  H  180 :
//	goto	FrError_Exit		// this is an error if already found an inframe response  H  181 :
//	bsf		InFrResp 			// Set the inframe response detected status flag  H  182 :
//	goto	get_inframe_response	// go receive the inframe message  H  183 :
//  **********************		  H  184 :
  H  185 :
wait_strt_nxt_bit:  H  186 :
	btfsc 	PWM_In				// check to see if we get another data bit comming			  H  187 :
	goto 	read_another_bit	// executes this inst if bus is active  H  188 :
	movlw 	( 29500 /200 )		// (desired time in ns)/200ns cylce time  H  189 :
	subwf	TMR2, W				// subtract from the current timer value  H  190 :
								// check if bus stays passive longer than 29us  H  191 :
	btfss	STATUS, C			//  "C" is set if 29us has been equaled or exceeded  H  192 :
	goto	wait_strt_nxt_bit  H  193 :
	bsf		MsgRecvd			// set the message received flag  H  194 :
   H  195 :
end_of_data_ck:					// now look for end of frame sequence  H  196 :
	btfsc 	PWM_In				// check to see that another active phase doesnt show up			  H  197 :
	goto 	FrError_Exit		// executes this inst if bus goes back active  H  198 :
								// if it does, its an error  H  199 :
	movlw 	( 40000 /200 )		// (desired time in ns)/200ns cylce time  H  200 :
	subwf	TMR2, W				// subtract from the current timer value  H  201 :
								// check if bus stays passive longer than 45us  H  202 :
	btfss	STATUS, C			//  "C" is set if 45us has been equaled or exceeded  H  203 :
	goto	end_of_data_ck		// loop back & wait until until the bus is inactive for 45us  H  204 :
RX_PWM_Exit:  H  205 :
	bsf		EOD					//  set the end of data flag  H  206 :
	bsf		EOF					//  set end of frame flag  H  207 :
RX_PWM_Exit2:  H  208 :
	#endasm  H  209 :
	*RxCntPntr = BusByteCntr;	// return count of received bytes  H  210 :
	return LinkControl;			// return status of the read operation  H  211 :
}  H  212 :}97
  H  213 :
// ###################################################################  H  214 :
// ***************  Entry for PWM Transmit Routine  ******************	  H  215 :
//   H  216 :
int8 PWMSend(int16* TxBufferPntr, int8 PWMTxCnt, int8 timeout) {  H  217 :f1614V374V375V376{99
	BusTimeOut = timeout;   	// Maximum Bus Inactivity Time Out Counter   H  218 :
								// approx 2 msec per count  H  219 :
    #asm  H  220 :
    lost_arbitration2:			// internal, lost arbitration re-entry point  H  221 :
    #endasm  H  222 :
  H  223 :
	Bus_If_Init(); 				// Initialize local variables & timers  H  224 :
  H  225 :
	BusBuffPntr = TxBufferPntr;  H  226 :
	BusBuffPntr_low = make8(BusBuffPntr, 0);  // load the pointer address for indirect addressing  H  227 :
	BusBuffPntr_high = make8(BusBuffPntr, 1);  H  228 :
  H  229 :
	BusByteCntr = PWMTxCnt;		// load the the TxCnt (being pointed at)  H  230 :
  H  231 :
	#asm  H  232 :
	bcf		PIR1, TMR2IF		// make sure timer 2 overflow bit is reset  H  233 :
	movff	BusBuffPntr_low, FSR0L  H  234 :
	movff	BusBuffPntr_high, FSR0H  H  235 :
  H  236 :
EOF_wait1:  H  237 :
	movf	BusTimeOut, f		// check if Bus Access Time has timed out  H  238 :
	btfsc	STATUS, Z  H  239 :
	goto	TxBusBusyExit		// error exit if bus is stuck busy  H  240 :
	btfss	PIR1, TMR2IF		// check if bus timeout period counter has expired  H  241 :
	goto	EOF_wait3			// jump if timer has not timed out yet  H  242 :
	bcf		PIR1, TMR2IF		// reset timer overflow flag  H  243 :
	decf	BusTimeOut, f		// sub one timer tick from timeout count  H  244 :
  H  245 :
EOF_wait3:  H  246 :
	clrf	TMR0L				// restart timer  H  247 :
EOF_wait2:  H  248 :
	btfsc 	PWM_In				// skips next when bus is passive  H  249 :
	goto	EOF_wait1			// loop back & clear timer whenever bus is active  H  250 :
  H  251 :
	movlw 	( 70000 /400 )		// (desired time in ns)/400ns cylce time  H  252 :
	subwf	TMR0L, W			// subtract from the current timer value   H  253 :
								// check if bus stays passive longer than 70us for EOF  H  254 :
	btfss	STATUS, C			//  "C" is set if 70us has been equaled or exceeded  H  255 :
	goto	EOF_wait2			// loop as long as active, checking for 70us duration  H  256 :
  H  257 :
IFS_wait:						// End of Frame found, now check if anyone else starts  H  258 :
								// after 70 us if any other node sends a SOF, we can  H  259 :
								// put one out as well, even if before the 96us is up  H  260 :
	btfsc 	PWM_In				// executes next inst is bus goes active  H  261 :
	goto	strt_transmission	// branch out if bus goes active  H  262 :
	movlw 	( 96000 /400 )		// (desired time in ns)/400ns cylce time  H  263 :
	subwf	TMR0L, W			// subtract from the current timer value  H  264 :
								// check if bus stays passive longer than 96us for IFS  H  265 :
	btfss	STATUS, C			//  "C" is set if 96us has been equaled or exceeded  H  266 :
	goto	IFS_wait			// continue checking til a SOF shows up, or the 96 us times out  H  267 :
   H  268 :
strt_transmission:				// we have seen a SOF or the 96us IFS time has expired  H  269 :
								// in either case, we now drive our own 32us SOF pulse  H  270 :
	clrf	TMR0L				// restart the timer  H  271 :
	bcf		PORTA, PWM_P_Out	// set PWM Bus Active  H  272 :
	bsf		PORTA, PWM_N_Out	// P=0, N=1  H  273 :
	#endasm  H  274 :
	tmr2_init();				// setup Timer2, as an 8us period timer (3 * 8us = 24us) a bit cell  H  275 :
	  H  276 :
	#asm  H  277 :
SOF_delay:  H  278 :
	movlw 	( 30000 /400 )		// (desired time ns startup time)/400ns cylce time  H  279 :
								// nominal per spec is 32 us (use 1us shorter for decay time on bus)  H  280 :
	subwf	TMR0L, W			// subtract from the current timer value  H  281 :
								// check if bus stays passive longer than 32us for IFS  H  282 :
								//  subtracted 1 us for software & circuit delays  H  283 :
	btfss	STATUS, C			//  "C" is set if 32us has been equaled or exceeded  H  284 :
	goto	SOF_delay			// drive the SOF pulse for the full 32us  H  285 :
   H  286 :
	bsf		PORTA, PWM_P_Out	// set PWM Bus Inactive  H  287 :
	bcf		PORTA, PWM_N_Out	// P=1, N=0			  H  288 :
								// drive BUS passive to terminate SOF pulse  H  289 :
   H  290 :
start_sending_bits:  H  291 :
settle_delay:					// allow the bus to settle, per spec should be 1.7us max  H  292 :
	movlw 	( 34000 /400 )		// (desired time in ns)/400ns cylce time  H  293 :
	subwf	TMR0L, W			// subtract from the current timer value  H  294 :
								// allow 2.4us settle time (34.4-32=2.4us) for bus to go passive  H  295 :
	btfss	STATUS, C			//  "C" is set if 35us has been equaled or exceeded  H  296 :
	goto	settle_delay		// wait the 2.4 us settle time  H  297 :
   H  298 :
	btfsc 	PWM_In				// skips next inst if bus is still passive  H  299 :
	goto	lost_arbitration	// Oh-oh, the bus is being driven, we loose arbitration				  H  300 :
								// get the first bit to transmit  H  301 :
 	bcf		NxtBit				// Clear NxtBit in advance of test  H  302 :
	btfsc	INDF0, 7			// test the MSbit of the first byte in the buffer  H  303 :
  H  304 :
	bsf		NxtBit				// if the MSB wasn't a zero, set a one into NxtBit  H  305 :
   H  306 :
SOF_passive_delay:				// keep checking to make sure no one else starts driving the bus  H  307 :
	btfsc 	PWM_In				// skips next inst if bus is still passive  H  308 :
	goto	lost_arbitration	// Oh-oh, the bus is being driven, we loose arbitration  H  309 :
	movlw 	( 45500 /400 )		// (desired time in ns)/400ns cylce time  H  310 :
	subwf	TMR0L, W			// subtract from the current timer value  H  311 :
								// wait for the 16us of passive time after the active SOF pulse  H  312 :
	btfss	STATUS, C			//  "C" is set if 47us has been equaled or exceeded  H  313 :
	goto	SOF_passive_delay	// wait the 16us of passive SOF time  H  314 :
   H  315 :
	clrf	TMR2				// re-start (zero) timer2 to synchronize it with end of SOF time  H  316 :
	bcf		PIR1, TMR2IF		// clear timer 2 interrupt flag, in case it was set  H  317 :
	nop							// actual timer2 interrupts are not enabled, we will be testing the flag bit  H  318 :
	nop							// a few nop's to compenstate for TMR2 startup time after reset  H  319 :
	nop							//  of prescaller / postscaler caused by write to TMR2  H  320 :
	nop  H  321 :
	nop  H  322 :
   H  323 :
strt_bit_cell:  H  324 :
	bcf		PORTA, PWM_P_Out	// set PWM Bus Active  H  325 :
	bsf		PORTA, PWM_N_Out	// P=0, N=1 for start of bit cell  H  326 :
	clrf	TMR0L				// restart timer 0  H  327 :
	btfss	NxtBit				// test if the next bit is a one or a zero  H  328 :
	goto	its_a_zero  H  329 :
its_a_one:  H  330 :
	btfss	PIR1, TMR2IF		// check if 1st 8us time period is complete yet  H  331 :
	goto	its_a_one  H  332 :
	bsf		PORTA, PWM_P_Out	// set PWM Bus Inactive  H  333 :
	bcf		PORTA, PWM_N_Out	// P=1, N=0			  H  334 :
								// for a one, go passive after 8us of active time  H  335 :
	bcf		PIR1, TMR2IF		// reset the timer overflow bit  H  336 :
  H  337 :
wait_half_cell:  H  338 :
	movlw 	( 12500 /400 )		// (desired time ns startup time)/400ns cylce time  H  339 :
	subwf	TMR0L, W			// subtract from the current timer value  H  340 :
								// wait 4.5us of passive time (halfway between a one & a zero)  H  341 :
								// 8us one time + 4.5us = 12.5us   H  342 :
	btfss	STATUS, C			//  "C" is set when 12.5us has been equaled or exceeded  H  343 :
	goto	wait_half_cell		// wait the 4.5us  H  344 :
	btfsc 	PWM_In				// skips next inst if bus is still passive  H  345 :
	goto	lost_arbitration	// Oh-oh, the bus is being driven, we loose arbitration  H  346 :
	goto	wait_2nd_half  H  347 :
  H  348 :
TxBusBusyExit:  H  349 :
	bsf		NoBusActivity		// set the error flag bit in LinkControl  H  350 :
	goto	TxErrorExit  H  351 :
   H  352 :
its_a_zero:						// a zero drives the bus active for 2, 8us timer periods  H  353 :
	btfss	PIR1, TMR2IF		// wait for 1st 8us time period to complete  H  354 :
	goto	its_a_zero  H  355 :
	bcf		PIR1, TMR2IF		// reset the timer overflow bit		  H  356 :
wait_2nd_half:			  H  357 :
	btfss	PIR1, TMR2IF		// wait for 2nd 8us time period to complete  H  358 :
	goto	wait_2nd_half  H  359 :
	bsf		PORTA, PWM_P_Out	// set PWM Bus Inactive  H  360 :
	bcf		PORTA, PWM_N_Out	// P=1, N=0  H  361 :
								// after the 16us go set BUS passive  H  362 :
	bcf		PIR1, TMR2IF		// reset the timer overflow bit  H  363 :
   H  364 :
get_next_bit:					// get next bit to transmit  H  365 :
	bcf		STATUS, C			// make sure 'C' bit is clear before rotating  H  366 :
	rrcf	MaskReg, F			// Move Mask to next bit position  H  367 :
	btfsc	STATUS, C			// if C is set, the entire byte has been sent  H  368 :
	goto	get_next_byte		// setup the next byte  H  369 :
test_the_bit:					// check if the masked bit is a one or a zero  H  370 :
	movf	MaskReg, W			// fetch the Mask Register  H  371 :
	andwf	INDF0, W			// and the mask with current byte being transmitted (indirect)  H  372 :
	bcf		NxtBit  H  373 :
	btfss	STATUS, Z			// skip next instruction if bit was a zero  H  374 :
	bsf		NxtBit				// NxtBit is now set up for the next bit to be sent, now  H  375 :
   H  376 :
wait_cell_passive:				// wait for the 8us of passive time that marks end of bit cell  H  377 :
	btfsc  	PWM_In				// skips next inst if bus is still passive  H  378 :
	goto	lost_arbitration	// Oh-oh, the bus is being driven, we loose arbitration  H  379 :
	btfss	PIR1, TMR2IF		// wait for 3rd & final 8us time period to complete (24us bit cell)  H  380 :
	goto	wait_cell_passive  H  381 :
	bcf		PIR1, TMR2IF		// reset the timer overflow bit  H  382 :
	goto	strt_bit_cell		// go back to transmit the next bit  H  383 :
   H  384 :
get_next_byte:  H  385 :
	incf	FSR0L, F			// increment the TX buffer pointer  H  386 :
	decf	BusByteCntr, F		// sub one from the count of bytes to be sent  H  387 :
	btfsc	STATUS, Z			// have we sent them all yet  H  388 :
	goto	all_sent			// exit loop if we are done sending  H  389 :
	movlw	0x80  H  390 :
	movwf	MaskReg				// put a one back into the MSB position  H  391 :
	goto	test_the_bit		// go transmit the MSB bit of this new byte  H  392 :
  H  393 :
lost_arbitration:  H  394 :
	movf	BusTimeOut, f		// Check the bus access time out count to see  H  395 :
	btfss	STATUS, Z			// if its already zero	  H  396 :
	decf	BusTimeOut, f		// reduce bus time out on each lost arbitration cycle  H  397 :
	goto	lost_arbitration2			  H  398 :
   H  399 :
all_sent:  H  400 :
	bsf		MsgSent				// set the Message Sent Flag  H  401 :
//	movlw	RxBuffer  H  402 :
//	movwf	FSR0L				// setup RxBuffer pointer in case of in-frame response  H  403 :
//	movlw	0b00000001			// prime first RxBuffer byte as a shift register  H  404 :
//	movwf	INDF0  H  405 :
  H  406 :
TX_PWM_Exit:  H  407 :
	bsf		EOD					//  set the end of data flag  H  408 :
	bsf		EOF					//  set end of frame flag  H  409 :
TxErrorExit:  H  410 :
	#endasm  H  411 :
	return LinkControl;			// return the status of the transmit operation  H  412 :
}  H  413 :}125
	  H  414 :
  H  415 :
// ##############   End of pwm-xx.asm    ########################  H  416 :
  H  417 :
  H  418 :E
 H  418 :
#include "VPW-02.c" A   45 :
 //------------------------------------------------------------------------------  K    1 :I10
// File: vpw-01.c  K    2 :
//  K    3 :
// Purpose: VPW Bus Interface  K    4 :
//  K    5 :
// Change History:  K    6 :
// Date		Author		Description  K    7 :
//          Bernie		Created  K    8 :
// August 2003 - updated for operation with the PIC18F248   K    9 :
//------------------------------------------------------------------------------  K   10 :
  K   11 :
#include "glob_bus.h" K   12 :
 //------------------------------------------------------------------------------  I    1 :I8
// File: Glob_bus.h  I    2 :
//  I    3 :
// Purpose: Bus Interface global variables.  I    4 :
//  I    5 :
// Change History:  I    6 :
// Date		Author		Description  I    7 :
//          Bernie		Created  I    8 :
//------------------------------------------------------------------------------  I    9 :
#ifndef GLOB_BUS_H  I   10 :
#define GLOB_BUS_H  I   11 :
  I   12 :
  I   13 :
//  ************ Global Bus Protocol Variable for VPW & PWM Routines ****************  I   14 :
  I   15 :
  I   16 :
int8	LinkControl;		// Data Link Control & Status Register  I   17 :
#locate LinkControl=0x26  I   18 :
	/* defines for the LinkControl variable bit positions */  I   19 :
#bit MsgRecvd = LinkControl.0		// An incomming message was received  I   20 :
#bit FrError = LinkControl.1		// A framing error was detected  I   21 :
#bit InFrResp = LinkControl.2		// An inframe response was received  I   22 :
#bit MsgSent = LinkControl.3		// The TX message has been sent  I   23 :
#bit MsgOverflow = LinkControl.4 	// A received message is longer than VEHICLE_MSG_SIZE  I   24 :
#bit NoBusActivity = LinkControl.5 	// Bus stuck, maximum bus acccess time exceeded  I   25 :
  I   26 :
  I   27 :
int8	LinkFlags;			// Local Data Link operation flags  I   28 :
#locate LinkFlags=0x27  I   29 :
#bit EOD			= LinkFlags.0	// End of Data Flag  I   30 :
#bit EOF 			= LinkFlags.1	// End of Frame Flag  I   31 :
#bit NxtBit 		= LinkFlags.2	// Value of next bit to transmit  I   32 :
#bit Act_phase_flag	= LinkFlags.3 	// VPW active phase flag  I   33 :
  I   34 :
int8	ShiftReg;			// Data Byte shift register, need to be in Bank0  I   35 :
#locate ShiftReg=0x28  I   36 :
int8	MaskReg;			// Mask Register, needs to be in Bank0  I   37 :
#locate MaskReg=0x29  I   38 :
int8	PhaseTime;			// VPW active or passive phase time, needs to be in Bank0  I   39 :
#locate PhaseTime=0x2a  I   40 :
int8	BusByteCntr;		// Byte counter used in all PWM & VPW routines  I   41 :
#locate	BusByteCntr=0x2b  I   42 :
int8	BusBuffPntr_low;		// Buffer Pointer used in all PWM & VPW routines  I   43 :
#locate	BusBuffPntr_low=0x2c  I   44 :
int8	BusBuffPntr_high;		  I   45 :
#locate	BusBuffPntr_high=0x2d  I   46 :
int8	BusTimeOut;			// Used to determine if bus is stuck for error exit  I   47 :
#locate BusTimeOut=0x2e	  I   48 :
int16	BusBuffPntr;		// Buffer Pointer used in all PWM & VPW routines  I   49 :
#locate	BusBuffPntr=0x2f  I   50 :
int8	BSR_temp;			// Temporary storage for Bank Select Register  I   51 :
#locate	BSR_temp=0x31  I   52 :
  I   53 :
#endif  I   54 :
  I   55 :
  I   56 :E
 I   56 :
#include "Util.h" K   13 :
 //------------------------------------------------------------------------------  L    1 :I11
// File: Util  L    2 :
//  L    3 :
// Purpose: Misc utility routines.   L    4 :
//  L    5 :
// Change History:  L    6 :
// Date		Author		Description  L    7 :
//          Lafreniere	Created  L    8 :
//------------------------------------------------------------------------------  L    9 :
#ifndef UTIL_H  L   10 :
#define UTIL_H  L   11 :
  L   12 :
// starting address for the 4-byte EEPOM write protect table  L   13 :
#define EEPROM_WRITE_PROTECT_TABLE_ADDR 	252  L   14 :
  L   15 :
// the logical sector size is arbitrary and has nothing to do with the PIC hardware  L   16 :
#define EEPROM_SECTOR_SIZE 	8  L   17 :
  L   18 :
void ReadEeprom();  L   19 :
void ReadEepromLocal(int8 sector);  L   20 :
void WriteEeprom();  L   21 :
int8 IsEepromSectorWriteProtected(int8 sector);  L   22 :
int32 ReadEepromSectorWriteProtectTable();  L   23 :
void WriteEerpomSectorWriteProtectTable(int32 writeProtectBits);  L   24 :
void init_ports();  L   25 :
void Bus_If_Init(void);  L   26 :
void DecryptBlock(int8 *outbfr, int8 *inbfr);  L   27 :
int8 IsCmdCAN(int8 cmd);  L   28 :
int8 IsCmdLocal(int8 cmd);  L   29 :
int8 IsCmdFBGO(int8 cmd);  L   30 :
int8 IsCmdListen(int8 cmd);  L   31 :
int8 IsCmdNoResponse(int8 cmd);  L   32 :
int8 IsCmdFirstResp(int8 cmd);  L   33 :
int8 IsCmdStandardId(int8 cmd);  L   34 :
int8 IsCmd250kb(int8 cmd);  L   35 :
int8 checksum(int8* pMsg, int8 size);  L   36 :
int8 crc8(int8* buffer, int8 count);  L   37 :
int32 StrToInt32(int8* str);  L   38 :
int8 TraceStr(int8* pMsg, int8 size);  L   39 :
int8 Trace(int8 msg);  L   40 :
  L   41 :
#endif  L   42 :E
 L   42 :
  K   14 :
// ************  Entry for Receiving a VPW message  ***********  K   15 :
  K   16 :
int8 VPWRecv (int16* RxBufferPntr, int8* RxCntPntr, int8 timeout) {  K   17 :f1641V402V403V404{127
	BusTimeOut = timeout;   	// Maximum Bus Inactivity Time Out Counter   K   18 :
								// approx 2 msec per count  K   19 :
	Bus_If_Init(); 				// Initialize local variables & timers  K   20 :
	BusBuffPntr = RxBufferPntr;  K   21 :
	BusBuffPntr_low = make8(BusBuffPntr, 0);  // load the pointer address for indirect addressing  K   22 :
	BusBuffPntr_high = make8(BusBuffPntr, 1);  K   23 :
  K   24 :
	setup_timer_0( RTCC_INTERNAL | RTCC_DIV_8 );	//  intialize & start timer0 at 1.6us per count  K   25 :
  K   26 :
	#asm  K   27 :
//	movff	BSR_temp, BSR		// Save current setting of Bank Select Register  K   28 :
///	movlb	0					//Set BSR to bank zero   K   29 :
	movff	BusBuffPntr_low, FSR0L  K   30 :
	movff	BusBuffPntr_high, FSR0H  K   31 :
  K   32 :
	bcf		PIR1, TMR2IF		// make sure timer 2 overflow bit is reset  K   33 :
wait_bus_activity_v:  K   34 :
	btfss	PIR1, TMR2IF  K   35 :
	goto	wait_bus_activity2_v  K   36 :
	bcf		PIR1, TMR2IF  K   37 :
	decf	BusTimeOut, f		//check if Bus Access has timed out (300 msec max)	  K   38 :
	btfsc	STATUS, Z  K   39 :
	goto	Rx_BusInactivityExit  K   40 :
  K   41 :
wait_bus_activity2_v:  K   42 :
	clrf	TMR0L				//  restart timer0  K   43 :
bus_active1_v:  K   44 :
	btfss PORTA, VPW_In			//  skips next inst if bus active  K   45 :
	goto	wait_bus_activity_v  K   46 :
								//  we have an active bus now  K   47 :
								// calculate the count of time to compare to in nanoseconds  K   48 :
	movlw 	( 163000/1600 )		// (desired time in ns)/1.6us cylce time  K   49 :
	subwf	TMR0L, W			// subtract from the current timer value  K   50 :
								// The "C" bit is a one when the time has been equaled or exceeded	  K   51 :
								//  look for a minimum SOF pulse of 163us (in nanoseconds)  K   52 :
	btfss	STATUS, C			//  "C" is set if time equal or exceeded  K   53 :
	goto	bus_active1_v		//  loop until we find a pulse longer than 163us  K   54 :
   K   55 :
wait_SOF_drop_v:				//  we have found a SOF, now wait for it to fall  K   56 :
								//  Check if bus stays high longer than 239us (could be a break pulse)  K   57 :
	movlw 	( 239000 /1600 )	// (desired time in ns)/1.6us cylce time  K   58 :
	subwf	TMR0L, W			// subtract from the current timer value									  K   59 :
	btfsc	STATUS, C			//  "C" is set if time equal or exceeded  K   60 :
	goto	FrError_Exit_v		//  take the framming error exit if pulse is too long  K   61 :
	btfsc	PORTA, VPW_In		//  skip next inst when bus goes passive  K   62 :
	goto	wait_SOF_drop_v  K   63 :
								//  SOF has dropped  K   64 :
  K   65 :
first_bit_v:					//  start getting the data bits  K   66 :
get_inframe_response_v:			//  entry point for getting the in-frame response bytes  K   67 :
	clrf	TMR0L				//  restart timer 0 to time bit cell		  K   68 :
	bcf		Act_phase_flag  K   69 :
get_data_bits_v:				  K   70 :
	movlw	0b00000001			//  prime the shift register  K   71 :
	movwf	ShiftReg  K   72 :
  K   73 :
  K   74 :
passive_phase:					//  decode if a one or a zero during this passive phase period  K   75 :
								//  in passive phase, 64us nom pulse is a zero (34us min - 96us max)  K   76 :
								//  in passive phase, 128us nom pulse is a one (96us min - 163us max)  K   77 :
	btfss	PORTA, VPW_In		//  wait for the current passive phase to end  K   78 :
	goto	still_passive		//  if still passive go check that if it has exceeded max time of 163us  K   79 :
	movf	TMR0L, W			//  Fetch current value of timer, the duration of this pulse  K   80 :
	movwf	PhaseTime			//  temporarily save it  K   81 :
	clrf	TMR0L				//  reset the timer to start timing the phase that just started  K   82 :
	bsf		Act_phase_flag  	//  mark the polarity of this new phase that we just detected  K   83 :
								//  check to see if pulse was too short, under 34us long  K   84 :
	movlw 	( 35000 /1600 )		// (desired time in ns)/1.6us cylce time  K   85 :
	subwf	PhaseTime, W		// subtract from the measured phase time  K   86 :
	btfss	STATUS, C			//  "C" is set if 34us has been equaled or exceeded  K   87 :
	goto	FrError_Exit_v		//  its an error if pulse was too short  K   88 :
								//  check if the phase time was less than 96us  K   89 :
	movlw 	( 95500 /1600 )		// (desired time in ns)/1.6us cylce time  K   90 :
	subwf	PhaseTime, W		// subtract from the measured phase time	  K   91 :
	btfss	STATUS, C			//  "C" is set if 96us has been equaled or exceeded		  K   92 :
	goto	shift_in_a_0_v		//  short passive is a zero  K   93 :
	goto	shift_in_a_1_v		//  long passive is a one  K   94 :
   K   95 :
still_passive:  K   96 :
								//  check if bus stays passive longer than 164us  K   97 :
	movlw 	( 164000 /1600 )	// (desired time in ns)/1.6us cylce time  K   98 :
	subwf	TMR0L, W			// subtract from the current timer value  K   99 :
	btfss	STATUS, C			//  "C" is set if 163us has been equaled or exceeded  K  100 :
	goto	passive_phase		//  under 163, loop back & check bus polarity again  K  101 :
	goto	end_of_data_ck_v	//  been down for 163us or more, go check if its the end of data	  K  102 :
  K  103 :
  K  104 :
active_phase:					//  decode if a one or a zero during this active phase period  K  105 :
								//  in active phase, 64us nom pulse is a one (34us min - 96us max)  K  106 :
								//  in active phase, 128us nom pulse is a zero (96us min - 163us max)  K  107 :
	btfsc	PORTA, VPW_In		//  wait for the current active phase to end  K  108 :
	goto	still_active		//  if still active go check that if it has exceeded max time of 163us  K  109 :
	movf	TMR0L, W			//  Fetch current value of timer, the duration of this pulse  K  110 :
	movwf	PhaseTime			//  temporarily save it  K  111 :
	clrf	TMR0L				//  reset the timer to start timing the phase that just started  K  112 :
	bcf		Act_phase_flag  	//  mark the polarity of this new passive phase that we just detected  K  113 :
								//  check to see if pulse was too short, under 34us long  K  114 :
	movlw 	( 33500 /1600 )		// (desired time in ns)/1.6us cylce time  K  115 :
	subwf	PhaseTime, W		// subtract from the measured phase time  K  116 :
	btfss	STATUS, C			//  "C" is set if 34us has been equaled or exceeded  K  117 :
	goto	FrError_Exit_v		//  its an error if pulse was too short  K  118 :
								//  check if the phase time was less than 96us  K  119 :
	movlw 	( 95500 /1600 )		// (desired time in ns)/1.6us cylce time  K  120 :
	subwf	PhaseTime, W		// subtract from the measured phase time  K  121 :
	btfss	STATUS, C			//  "C" is set if 96us has been equaled or exceeded		  K  122 :
	goto	shift_in_a_1_v		//  short active is a one  K  123 :
	goto	shift_in_a_0_v		//  long passive is a zero  K  124 :
  K  125 :
still_active:  K  126 :
								//  check if bus stays passive longer than 164us  K  127 :
	movlw 	( 164000 /1600 )	// (desired time in ns) /1.6us cylce time  K  128 :
	subwf	TMR0L, W			// subtract from the current timer value  K  129 :
	btfss	STATUS, C			//  "C" is set if 163us has been equaled or exceeded  K  130 :
	goto	active_phase		//  under 163, loop back & check bus polarity again  K  131 :
	goto	FrError_Exit_v		//  been active for 163us or more, must be an error or Break	  K  132 :
  K  133 :
   K  134 :
shift_in_a_0_v:					//  clear C for rotating a zero into register  K  135 :
	bcf		STATUS, C  K  136 :
	goto	shift_it_in_v  K  137 :
					  K  138 :
shift_in_a_1_v:	  K  139 :
	bsf		STATUS, C			//  set C for rotating a 1 into register  K  140 :
shift_it_in_v:  K  141 :
	rlcf	ShiftReg, F			//  rotate the C bit into the LSB position (data comes in MSB first)  K  142 :
								//  after 8 rotations, the first bit in will be in the MSB position  K  143 :
	btfss	STATUS, C			//  register is full when the preset one bit comes out  K  144 :
	goto	get_nxt_bit_v	  	//  branch if register not full yet  K  145 :
								//  shift register is full, save the byte  K  146 :
  K  147 :
	incf	BusByteCntr, F		//  add one to the received bytes count  K  148 :
	movlw	VEHICLE_MSG_SIZE+1	//  check if we have exceeded the maximum of 12 bytes  K  149 :
	subwf	BusByteCntr, W  K  150 :
	btfsc	STATUS, C			//  'C' will be set when we are over maximum record length  K  151 :
	goto	MsgLen_Exit_v		//  its an error if we are over the msg size limit  K  152 :
  K  153 :
	movf	ShiftReg, W			// shift register is full, save the accumulated byte to RxBuffer  K  154 :
	movwf	INDF0  K  155 :
	incf	FSR0L, F			//  advance indirect memory pointer to next byte	  K  156 :
	movlw	0b00000001			//  prime the RxBuffer byte as a shift register  K  157 :
	movwf	ShiftReg			//  indirect write to the buffer  K  158 :
  K  159 :
get_nxt_bit_v:  K  160 :
	btfss	Act_phase_flag  	//  branch to either active or passive phase bit decode  K  161 :
	goto	passive_phase		//  in VPW acive & passive phases alternate on every bit  K  162 :
	goto	active_phase  K  163 :
   K  164 :
end_of_data_ck_v:				  K  165 :
	bsf		MsgRecvd			//  set the message received flag  K  166 :
	bsf		EOD					//  set the end of data flag  K  167 :
// ***  Following Statements Removed to elliminate In-Frame Response Checking ****  K  168 :
// ***  Per discussion with David 8-13-2002  K  169 :
//InFrame_Ck_v:					//  now lets check if there is an inframe response  K  170 :
//	btfsc	PORTA, VPW_In		//  check to see if inframe response active phase shows up			  K  171 :
//	goto 	Ck_InFrame_Status_v	//  executes this inst if bus goes back active  K  172 :
//								//  check if bus stays passive longer than 239us  K  173 :
//	movlw 	( 239000 /1600 )	// (desired time in ns)/1.6us cylce time  K  174 :
//	subwf	TMR0L, W			// subtract from the current timer value  K  175 :
//	btfss	STATUS, C			//  "C" is set if 239us has been equaled or exceeded  K  176 :
//	goto	InFrame_Ck_v		//  loop back & wait until bus is inactive for 239us  K  177 :
// ***  K  178 :
	bsf		EOF					//  we have identified an end of frame  K  179 :
	goto	VPW_RX_Exit			//  return to the calling "C" application  K  180 :
	  K  181 :
  K  182 :
// ***  Following Statements Removed to elliminate In-Frame Response Checking ****  K  183 :
// ***  Per discussion with David 8-13-2002   K  184 :
//Ck_InFrame_Status_v:  K  185 :
//	clrf	TMR0L				//  restart timer0 to start timing 1st inframe response bit  K  186 :
//	btfsc	InFrResp			//  test if we have already detected an inframe response  K  187 :
//	goto	FrError_Exit_v		//  this is an error if already found an inframe response  K  188 :
//	bsf		InFrResp 			//  Set the inframe response detected status flag  K  189 :
//   K  190 :
//wait_NB_done:					//  wait for the VPW normalization bit to end (throw it away)  K  191 :
//	btfss	PORTA, VPW_In  K  192 :
//	goto	NB_done  K  193 :
//								//  test to make sure the maximum pulse time of 96us is not exceeded  K  194 :
//	movlw 	( 99000 /1600 )		// (desired time in ns)/1.6us cylce time  K  195 :
//	subwf	TMR0L, W			// subtract from the current timer value  K  196 :
//	btfsc	STATUS, C			//  "C" is set if 99us has been equaled or exceeded  K  197 :
//	goto	FrError_Exit_v		//  take error exit if pulse is too long  K  198 :
//	goto	wait_NB_done		//  loop until pulse ends  K  199 :
//  K  200 :
//  K  201 :
//NB_done:						//  the NB terminated, now lets make sure it was correct duration  K  202 :
//								//  its an error if bus was active less than 34us  K  203 :
//	movlw 	( 33000 )/1600 )	// (desired time in ns)/1.6us cylce time  K  204 :
//	subwf	TMR0L, W			// subtract from the current timer value  K  205 :
//	btfss	STATUS, C			//  "C" is set if 34us has been equaled or exceeded  K  206 :
//	goto	FrError_Exit_v		//  take error exit if too short	  K  207 :
//	goto	get_inframe_response_v	//  go receive the inframe message  K  208 :
// ****  K  209 :
  K  210 :
MsgLen_Exit_v:  K  211 :
	bsf		MsgOverflow			// set overflow error flag in link control register	  K  212 :
	goto	VPW_RX_Exit  K  213 :
	  K  214 :
Rx_BusInactivityExit:  K  215 :
	bsf		NoBusActivity		// set the error flag bit in LinkControl  K  216 :
	goto	VPW_RX_Exit			// error exit if bus is stuck busy  K  217 :
  K  218 :
FrError_Exit_v:					//  time exceeded or other problem if we get here  K  219 :
	bsf		FrError 			//  set framing error flag in control register  K  220 :
VPW_RX_Exit:  K  221 :
//	movff	BSR_temp, BSR		// Restore setting of Bank Select Register  K  222 :
	#endasm  K  223 :
  K  224 :
	*RxCntPntr = BusByteCntr;	// return count of received bytes  K  225 :
	return LinkControl;			// return status for the calling application  K  226 :
}		  K  227 :}149
   K  228 :
// ###################################################################  K  229 :
// ***************  Entry for VPW Transmit Routine  ******************	  K  230 :
//  K  231 :
int8 VPWSend (int16* TxBufferPntr, int8 VPWTxCnt, int8 timeout) {  K  232 :f1662V426V427V428{151
	BusTimeOut = timeout;   	// Maximum Bus Inactivity Time Out Counter   K  233 :
								// approx 2 msec per count  K  234 :
    #asm  K  235 :
    lost_arbitration_v2:		// internal, lost arbitration re-entry point  K  236 :
    #endasm  K  237 :
      K  238 :
	Bus_If_Init(); 				// Initialize local variables & timers  K  239 :
	BusBuffPntr = TxBufferPntr;  K  240 :
	BusBuffPntr_low = make8(BusBuffPntr, 0);  // load the pointer address for indirect addressing  K  241 :
	BusBuffPntr_high = make8(BusBuffPntr, 1);  K  242 :
  K  243 :
	#asm  K  244 :
//	movff	BSR_temp, BSR		// Save current setting of Bank Select Register  K  245 :
//	movlb	0					//Set BSR to bank zero  K  246 :
	movff	BusBuffPntr_low, FSR0L  K  247 :
	movff	BusBuffPntr_high, FSR0H  K  248 :
	#endasm  K  249 :
  K  250 :
	BusByteCntr = VPWTxCnt;		// load the the TxCnt (being pointed at)  K  251 :
  K  252 :
	setup_timer_0( RTCC_INTERNAL | RTCC_DIV_8 ); // initialize timer0 to run at 200ns / count  K  253 :
  K  254 :
	#asm  K  255 :
	bcf		PIR1, TMR2IF		// make sure timer 2 overflow bit is reset  K  256 :
EOF_wait1_v:  K  257 :
	btfss	PIR1, TMR2IF  K  258 :
	goto	EOF_wait3_v			// jump if timer has not timed out yet  K  259 :
	bcf		PIR1, TMR2IF  K  260 :
	movf	BusTimeOut, f		// check if Bus Access has timed out	  K  261 :
	btfsc	STATUS, Z  K  262 :
	goto	TxBusBusyExit_v		// error exit if bus is stuck busy  K  263 :
	decf	BusTimeOut, f		// sub one timer tick from timeout count  K  264 :
  K  265 :
EOF_wait3_v:  K  266 :
	clrf	TMR0L				// restart timer  K  267 :
EOF_wait2_v:  K  268 :
	btfsc	PORTA, VPW_In		// skips next when bus is inactive  K  269 :
	goto	EOF_wait1_v			// loop back until we see an inactive bus  K  270 :
  K  271 :
								// check if bus stays passive longer than 239us for EOF  K  272 :
	movlw 	( 239000 /1600 )	// (desired time in ns)/1.6us cylce time  K  273 :
	subwf	TMR0L, W			// subtract from the current timer value  K  274 :
	btfss	STATUS, C			// "C" is set if 239us has been equaled or exceeded  K  275 :
	goto	EOF_wait2_v			// loop as long as passive  K  276 :
  K  277 :
IFS_wait_v:						// End of Frame found, now check if anyone else starts  K  278 :
								// after 239 us, if any other node sends a SOF, we can  K  279 :
								// put one out as well, even before the 300us IFS is up  K  280 :
	btfsc	PORTA, VPW_In		// executes next inst is bus goes active again  K  281 :
	goto	strt_transmission_v	// branch out if bus goes active  K  282 :
								// check if bus stays passive longer than 300us for IFS  K  283 :
	movlw 	( 300000 /1600 )	// (desired time in ns)/1.6us cylce time  K  284 :
	subwf	TMR0L, W			// subtract from the current timer value  K  285 :
	btfss	STATUS, C			// "C" is set if 300us has been equaled or exceeded  K  286 :
	goto	IFS_wait_v			// continue checking til a SOF shows up, or the 300 us times out  K  287 :
  K  288 :
strt_transmission_v:			// we have seen a SOF or the 300us IFS time has expired  K  289 :
								// in either case, we now drive our own 200us SOF pulse  K  290 :
	clrf	TMR0L				// restart the timer  K  291 :
	bsf		PORTB, VPW_Out		// drive VPW BUS active  K  292 :
	  K  293 :
SOF_delay_v:  K  294 :
								// Leave bus active for 200us  K  295 :
	movlw 	( 200000 /1600 )	// (desired time in ns)/1.6us cylce time  K  296 :
	subwf	TMR0L, W			// subtract from the current timer value  K  297 :
	btfss	STATUS, C			// "C" is set if 32us has been equaled or exceeded  K  298 :
	goto	SOF_delay_v			// drive the SOF pulse for the full 200us  K  299 :
  K  300 :
	bcf		PORTB, VPW_Out		// drive BUS passive to terminate SOF pulse  K  301 :
	clrf	TMR0L				// restart the timer  K  302 :
  K  303 :
start_sending_bits_v:  K  304 :
settle_delay_v:					// allow the bus to settle, per Moto 33390 spec should be 17.7us max  K  305 :
								// allow 21us settle time for bus to go passive  K  306 :
	movlw 	( 21000 /1600 )		// (desired time in ns)/1.6us cylce time  K  307 :
	subwf	TMR0L, W			// subtract from the current timer value  K  308 :
	btfss	STATUS, C			// "C" is set if 35us has been equaled or exceeded  K  309 :
	goto	settle_delay_v		// wait the 21 us settle time  K  310 :
  K  311 :
	btfsc	PORTA, VPW_In		// skips next inst if bus is still passive  K  312 :
	goto	lost_arbitration_v	// Oh-oh, the bus is being driven, we loose arbitration				  K  313 :
								// get the first bit to transmit  K  314 :
 	bcf		NxtBit				// NxtBit is already zero because of being reset at start  K  315 :
	btfsc	INDF0, 7			// test the MSbit of the first byte in the buffer  K  316 :
	bsf		NxtBit				// if the MSB wasn't a zero, set a one into NxtBit  K  317 :
  K  318 :
TX_passive_phase:  K  319 :
	btfsc	NxtBit				// Check if next bit is a zero or a one  K  320 :
	goto	passive_1			// branch if its a one  K  321 :
passive_0:  K  322 :
	call	get_next_bit_v		// setup the next bit to be transmitted  K  323 :
passive_0_ck:  K  324 :
	btfsc	PORTA, VPW_In		// check if someone else may be driving the bus  K  325 :
	goto	lost_arbitration_v	// exit routine if someone else is driving the bus  K  326 :
								// leave bus active for 64us for a passive 0 pulse  K  327 :
	movlw 	( 64000 /1600 )		// (desired time in ns)/1.6us cylce time  K  328 :
	subwf	TMR0L, W			// subtract from the current timer value  K  329 :
	btfss	STATUS, C			// "C" is set when 64us has been equaled or exceeded  K  330 :
	goto	passive_0_ck		// loop until pulse is finished  K  331 :
   K  332 :
end_passive:  K  333 :
	btfsc	MsgSent				//  test if we are done transmitting before driving bus active  K  334 :
	goto	VPW_TX_end_of_data  //  go execute end of data routine if done  K  335 :
	clrf	TMR0L				//  reset the timer  K  336 :
	bsf		PORTB, VPW_Out		//  set the bus active for next phase  K  337 :
	goto	TX_active_phase		//  now lets continue with the active phase  K  338 :
   K  339 :
passive_1:  K  340 :
	call	get_next_bit_v		//  setup the next bit to be transmitted  K  341 :
passive_1_ck:  K  342 :
	btfsc	PORTA, VPW_In		//  check if someone else may be driving the bus  K  343 :
	goto	lost_arbitration_v	//  exit routine if someone else is driving the bus  K  344 :
								//  leave bus passive for 128us for a passive 1 pulse  K  345 :
	movlw 	( 128000 /1600 )	// (desired time in ns)/1.6us cylce time  K  346 :
	subwf	TMR0L, W			// subtract from the current timer value  K  347 :
	btfss	STATUS, C			//  "C" is set when 128us has been equaled or exceeded  K  348 :
	goto	passive_1_ck		//  loop until pulse is finished  K  349 :
	goto	end_passive			//  go get ready for next phase	  K  350 :
   K  351 :
lost_arbitration_v:  K  352 :
	movf	BusTimeOut, f		// Check the bus access time out count to see  K  353 :
	btfss	STATUS, Z			// if its already zero	  K  354 :
	decf	BusTimeOut, f		// reduce bus time out on each lost arbitration cycle  K  355 :
	goto	lost_arbitration_v2	  K  356 :
   K  357 :
TX_active_phase:  K  358 :
	btfsc	NxtBit				//  Check if next bit is a zero or a one  K  359 :
	goto	active_1			//  branch if its a one  K  360 :
active_0:  K  361 :
								//  drive bus active for 128us for an active 0 pulse  K  362 :
	movlw 	( 128000 /1600 )	// (desired time in ns)/1.6us cylce time  K  363 :
	subwf	TMR0L, W			// subtract from the current timer value  K  364 :
	btfss	STATUS, C			//  "C" is set when 128us has been equaled or exceeded  K  365 :
	goto	active_0			//  loop until pulse is finished  K  366 :
   K  367 :
end_active:  K  368 :
	clrf	TMR0L				//  reset the timer  K  369 :
	bcf		PORTB, VPW_Out		//  set the bus passive for next phase  K  370 :
	call	get_next_bit_v		//  setup the next bit to be transmitted  K  371 :
	btfsc	MsgSent				//  test if we are done transmitting yet  K  372 :
	goto	VPW_TX_end_of_data	//  go execute end of data routine if done  K  373 :
passive_delay_v:				//  allow the bus to settle, per Moto 33390 spec should be 17.7us max  K  374 :
								//  allow 21us settle time for bus to go passive  K  375 :
	movlw 	( 21000 /1600 )		// (desired time in ns)/1.6us cylce time  K  376 :
	subwf	TMR0L, W			// subtract from the current timer value  K  377 :
	btfss	STATUS, C			//  "C" is set if 21us has been equaled or exceeded  K  378 :
	goto	passive_delay_v		//  wait the 21 us settle time before testing for lost arbitration  K  379 :
	goto	TX_passive_phase	//  now lets continue with the passive phase  K  380 :
   K  381 :
active_1:  K  382 :
								//  drive bus active for 64us for an active 1 pulse  K  383 :
	movlw 	( 64000 /1600 )		// (desired time in ns)/1.6us cylce time  K  384 :
	subwf	TMR0L, W			// subtract from the current timer value  K  385 :
	btfss	STATUS, C			//  "C" is set when 64us has been equaled or exceeded  K  386 :
	goto	active_1			//  loop until pulse is finished  K  387 :
	goto	end_active			//  go get ready for next phase	  K  388 :
   K  389 :
get_next_bit_v:					//  get next bit to transmit  K  390 :
	bcf		STATUS, C			//  make sure 'C' bit is clear before rotating  K  391 :
	rrcf	MaskReg, F			//  Move Mask to next bit position  K  392 :
	btfsc	STATUS, C			//  if C is set, the entire byte has been sent  K  393 :
	goto	get_next_byte_v		//  setup the next byte  K  394 :
test_the_bit_v:					//  check if the masked bit is a one or a zero  K  395 :
	movf	MaskReg, W			//  fetch the Mask Register  K  396 :
	andwf	INDF0, W			//  and the mask with current byte being transmitted (indirect)  K  397 :
	bcf		NxtBit  K  398 :
	btfss	STATUS, Z			//  skip next instruction if bit was a zero  K  399 :
	bsf		NxtBit				//  NxtBit is now set up for the next bit to be sent  K  400 :
	return  K  401 :
   K  402 :
get_next_byte_v:  K  403 :
	incf	FSR0L, F			//  increment the TX buffer pointer  K  404 :
	decf	BusByteCntr, F		//  sub one from the count of bytes to be sent  K  405 :
	btfsc	STATUS, Z			//  have we sent them all yet  K  406 :
	goto	all_sent_v			//  exit loop if we are done sending  K  407 :
	movlw	0x80  K  408 :
	movwf	MaskReg				//  put a one back into the MSB position  K  409 :
	goto	test_the_bit_v		//  setup NxtBit for the MSB bit of this new byte  K  410 :
  K  411 :
TxBusBusyExit_v:  K  412 :
	bsf		NoBusActivity		// set the error flag bit in LinkControl  K  413 :
	goto	TxErrorExit_v			  K  414 :
   K  415 :
all_sent_v:  K  416 :
	bsf		MsgSent				//  set the Message Sent Flag  K  417 :
								//  Support for in-frame response was removed per David  K  418 :
//	movlw	RxBuffer  K  419 :
//	movwf	FSR0L				//  setup RxBuffer pointer in case of in-frame response  K  420 :
//	movlw	0b00000001			//  prime first RxBuffer byte as a shift register  K  421 :
//	movwf	INDF0  K  422 :
	return  K  423 :
  K  424 :
VPW_TX_end_of_data:  K  425 :
	bsf		EOD					//  set the end of data flag  K  426 :
	bsf		EOF					//  set end of frame flag  K  427 :
TxErrorExit_v:  K  428 :
//	movff	BSR_temp, BSR		// Restore setting of Bank Select Register  K  429 :
	#endasm  K  430 :
  K  431 :
	return LinkControl;			// return status for the calling application  K  432 :
}	   K  433 :}181
								  K  434 :
   K  435 :
// ##############   End of vpw-xx.c    ########################  K  436 :
  K  437 :
  K  438 :E
 K  438 :
#include "CAN18XX8.c" A   46 :
 /*********************************************************************  M    1 :I12
 *  M    2 :
 *              PIC18CXX8 CAN C Library Source Code  M    3 :
 *  M    4 :
 *********************************************************************  M    5 :
 * FileName:        CAN18CXX8.C  M    6 :
 * Dependencies:    CAN18CXX8.h  M    7 :
 * Date:            09/06/00  M    8 :
 * Processor:       PIC18CXX8  M    9 :
 * Complier:        MPLAB 5.11.00    M   10 :
 *                 (**bcl Sept 16, 2003 - changed to CCS C compiler)  M   11 :
 * Company:         Microchip Technology, Inc.  M   12 :
 *  M   13 :
 * Software License Agreement  M   14 :
 *  M   15 :
 * The software supplied herewith by Microchip Technology Incorporated  M   16 :
 * (the Company) for its PICmicro Microcontroller is intended and  M   17 :
 * supplied to you, the Companys customer, for use solely and  M   18 :
 * exclusively on Microchip PICmicro Microcontroller products. The  M   19 :
 * software is owned by the Company and/or its supplier, and is  M   20 :
 * protected under applicable copyright laws. All rights are reserved.  M   21 :
 * Any use in violation of the foregoing restrictions may subject the  M   22 :
 * user to criminal sanctions under applicable laws, as well as to  M   23 :
 * civil liability for the breach of the terms and conditions of this  M   24 :
 * license.  M   25 :
 *  M   26 :
 * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,  M   27 :
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED  M   28 :
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  M   29 :
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,  M   30 :
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR  M   31 :
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.  M   32 :
 *  M   33 :
 * Author               Date    Comment  M   34 :
 *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  M   35 :
 * Nilesh Rajbharti     9/6/00  Original        (Rev 1.0)  M   36 :
 * Nilesh Rajbharti     12/1/00 Fixed bugs.  M   37 :
 *                              (CANRegsToID, CANReceiveMessage,  M   38 :
 *                               CANSetMask + Added  M   39 :
 *                               CAN_CONFIG_DBL_BUFFER_ON/OFF option)  M   40 :
 * Nilesh Rajbharti     6/8/01  Renamed CAN_CONFIG_DBL_BUFFERED to  M   41 :
 *                              CAN_RX_DBL_BUFFERED  M   42 :
 *  M   43 :
 * Nilesh Rajbharti     6/5/02  Modified RXB0DLC_RTR def to fix compiler  M   44 :
 *                              missing def problem.  M   45 :
 *                              Fixed CANIDToRegs() where "static"  M   46 :
 *                              mode would not compile.  (Rev 1.2)  M   47 :
 *  M   48 :
 * Bernie Lafreniere	8/16/03 Start porting driver to run on CCS C with  M   49 :
 *								the PIC18F248 processor.  M   50 :
 *  M   51 :
 ********************************************************************/  M   52 :
  M   53 :
/*  M   54 :
 * Private helper functions to convert 32-bit CAN ID value into  M   55 :
 * corresponding PIC18CXX8 registers and vice-versa.  M   56 :
 */  M   57 :
  M   58 :
/*static void CANIDToRegs(BYTE* ptr,  M   59 :
                        int32 val,  M   60 :
                        BYTE config_flags);  M   61 :
static void RegsToCANID(BYTE* ptr,  M   62 :
                        int32 *val,  M   63 :
                        BYTE config_flags);  M   64 :
  M   65 :
*/  M   66 :
  M   67 :
#include "CAN18XX8.h"	// CAN interface driver M   68 :
 /*********************************************************************  N    1 :I13
 *              PIC18CXX8 CAN C Library Header File  N    2 :
 *********************************************************************  N    3 :
 * FileName:        CAN18CXX8.h  N    4 :
 * Dependencies:    None  N    5 :
 * Date:            09/06/00  N    6 :
 * Processor:       PIC18CXX8  N    7 :
 * Complier:        MPLAB 5.11.00  N    8 :
 * Company:         Microchip Technology, Inc.  N    9 :
 *  N   10 :
 *  N   11 :
 * Software License Agreement  N   12 :
 *  N   13 :
 * The software supplied herewith by Microchip Technology Incorporated  N   14 :
 * (the Company) for its PICmicro Microcontroller is intended and  N   15 :
 * supplied to you, the Companys customer, for use solely and  N   16 :
 * exclusively on Microchip PICmicro Microcontroller products. The  N   17 :
 * software is owned by the Company and/or its supplier, and is  N   18 :
 * protected under applicable copyright laws. All rights are reserved.  N   19 :
 *  Any use in violation of the foregoing restrictions may subject the  N   20 :
 * user to criminal sanctions under applicable laws, as well as to  N   21 :
 * civil liability for the breach of the terms and conditions of this  N   22 :
 * license.  N   23 :
 *  N   24 :
 * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,  N   25 :
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED  N   26 :
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  N   27 :
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,  N   28 :
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR  N   29 :
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.  N   30 :
 *  N   31 :
 * Author               Date    Comment  N   32 :
 *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  N   33 :
 * Nilesh Rajbharti     9/6/00  Original        (Rev 1.0)  N   34 :
 * Nilesh Rajbharti     12/1/00 Fixed bugs.  N   35 :
 *                              (CANRegsToID, CANReceiveMessage,  N   36 :
 *                               CANSetMask + Added  N   37 :
 *                               CAN_CONFIG_DBL_BUFFER_ON/OFF option)  N   38 :
 * Nilesh Rajbharti     6/8/01  Renamed CAN_CONFIG_DBL_BUFFERED to  N   39 :
 *                              CAN_RX_DBL_BUFFERED  N   40 :
 *  N   41 :
 * Bernie Lafreniere	8/16/03 Start porting driver to run on CCS C with  N   42 :
 *								the PIC18F248 processor.  N   43 :
 *  N   44 :
 *********************************************************************/  N   45 :
#ifndef CAN18XX8_H          // To avoid duplicate inclusion  N   46 :
#define CAN18XX8_H  N   47 :
  N   48 :
#bit RXB0CON_RX0DBEN    = RXB0CON.2	// PIC18XX8 CAN register.bit mapping  N   49 :
#bit RXB0CON_RXFUL      = RXB0CON.7  N   50 :V457
#bit RXB1CON_RXFUL      = RXB1CON.7  N   51 :V458
#bit TXB0CON_TXREQ      = TXB0CON.3  N   52 :V459
  N   53 :
#bit TXB1CON_TXPRI0     = TXB1CON.0  N   54 :V460
#bit TXB1CON_TXPRI1     = TXB1CON.1  N   55 :V461
#bit TXB1CON_TXREQ      = TXB1CON.3  N   56 :V462
#bit TXB1CON_TXERR      = TXB1CON.4  N   57 :V463
#bit TXB1CON_TXLARB     = TXB1CON.5  N   58 :V464
#bit TXB1CON_TXABT      = TXB1CON.6  N   59 :V465
  N   60 :
#bit TXB2CON_TXPRI0     = TXB2CON.0  N   61 :V466
#bit TXB2CON_TXPRI1     = TXB2CON.1  N   62 :V467
#bit TXB2CON_TXREQ      = TXB2CON.3  N   63 :V468
#bit TXB2CON_TXERR      = TXB2CON.4  N   64 :V469
#bit TXB2CON_TXLARB     = TXB2CON.5  N   65 :V470
#bit TXB2CON_TXABT      = TXB2CON.6  N   66 :V471
  N   67 :
#bit BRGCON2_SAM        = BRGCON2.6  N   68 :V472
#bit BRGCON2_SEG2PHTS   = BRGCON2.7  N   69 :V473
#bit BRGCON3_WAKFIL     = BRGCON3.6  N   70 :V474
#bit PIR3_RXB0IF        = PIR3.0  N   71 :V475
#bit PIR3_RXB1IF        = PIR3.1  N   72 :V476
#bit PIR3_IRXIF         = PIR3.7  N   73 :V477
#bit COMSTAT_TXB0       = COMSTAT.5  N   74 :V478
#bit COMSTAT_TXBP       = COMSTAT.4  N   75 :V479
#bit COMSTAT_RXBP       = COMSTAT.3  N   76 :V480
#bit COMSTAT_RX1OVFL    = COMSTAT.6  N   77 :V481
#bit COMSTAT_RX0OVFL    = COMSTAT.7  N   78 :V482
#bit RXB0DLC_RTR        = RXB0DLC.6  N   79 :V483
#bit RXB0SIDL_EXID      = RXB0SIDL.3  N   80 :V484
#bit CANCON_ABAT        = CANCON.4  N   81 :V485
  N   82 :
//////////////////////////////////////////////////////////////////////  N   83 :
  N   84 :
/*********************************************************************  N   85 :
 *  N   86 :
 * union CAN_MESSAGE_ID  N   87 :
 *  N   88 :
 * This union provides abstract data type for CAN message id.  N   89 :
 * It is used for both 11-bit and 29-bit message identifiers.  N   90 :
 * There are multiple union members to be able to access individual  N   91 :
 * parts of it.  N   92 :
 *  N   93 :
 ********************************************************************/  N   94 :
 // Parse-out 29-bit or 11-bit (saved in 32-bit number)  N   95 :
typedef union _CAN_MESSAGE_ID  N   96 :V486
{  N   97 :T487
    int32 ID;  N   98 :
  N   99 :
    struct  N  100 :
    {  N  101 :
        struct  N  102 :
        {  N  103 :
            int8 SIDL:3;        // SIDL<5:7>  N  104 :
            int8 SIDH:5;        // SIDH<0:4>  N  105 :
        } BYTE1;  N  106 :
        struct  N  107 :
        {  N  108 :
            int8 SIDHU:3;       // SIDH<5:7>  N  109 :
            int8 EIDL_LN:5;     // EIDL<0:4>  N  110 :
        } BYTE2;  N  111 :
        struct  N  112 :
        {  N  113 :
            int8 EIDL_UN:3;     // EIDL<5:7>  N  114 :
            int8 EIDH_LN:5;     // EIDH<0:4>  N  115 :
        } BYTE3;  N  116 :
        struct  N  117 :
        {  N  118 :
            int8 EIDH_UN:3;     // EIDH<5:7>  N  119 :
            int8 EIDHU:2;       // SIDL<0:1>  N  120 :
            int8 PAD:3;			// bcl added name "PAD" to make CCS happy  N  121 :
        } BYTE4;  N  122 :
    } ID_VALS;  N  123 :
  N  124 :
    // This is to allow individual byte access within message id.  N  125 :
    struct  N  126 :
    {  N  127 :
        BYTE BYTE_1;  N  128 :
        BYTE BYTE_2;  N  129 :
        BYTE BYTE_3;  N  130 :
        BYTE BYTE_4;  N  131 :
    } BYTES;  N  132 :
} CAN_MESSAGE_ID;  N  133 :
  N  134 :
//////////////////////////////////////////////////////////////////////  N  135 :
  N  136 :
/*********************************************************************  N  137 :
 *  N  138 :
 * enum CAN_TX_MSG_FLAGS  N  139 :
 *  N  140 :
 * This enumeration values define flags related to transmission of a  N  141 :
 * CAN message.  There could be more than one this flag  N  142 :
 * ANDed together to form multiple flags.  N  143 :
 *  N  144 :
 *********************************************************************/  N  145 :
 typedef enum CAN_TX_MSG_FLAGS  N  146 :
 {  N  147 :T515
    CAN_TX_PRIORITY_BITS= 0b00000011,  N  148 :
    CAN_TX_PRIORITY_0   = 0b11111100,   // XXXXXX00  N  149 :
    CAN_TX_PRIORITY_1   = 0b11111101,   // XXXXXX01  N  150 :
    CAN_TX_PRIORITY_2   = 0b11111110,   // XXXXXX10  N  151 :
    CAN_TX_PRIORITY_3   = 0b11111111,   // XXXXXX11  N  152 :
  N  153 :
    CAN_TX_FRAME_BIT    = 0b00001000,  N  154 :
    CAN_TX_STD_FRAME    = 0b11111111,   // XXXXX1XX  N  155 :
    CAN_TX_XTD_FRAME    = 0b11110111,   // XXXXX0XX  N  156 :
  N  157 :
    CAN_TX_RTR_BIT      = 0b01000000,  N  158 :
    CAN_TX_NO_RTR_FRAME = 0b11111111,   // X1XXXXXX  N  159 :
    CAN_TX_RTR_FRAME    = 0b10111111    // X0XXXXXX  N  160 :
};  N  161 :
  N  162 :
//////////////////////////////////////////////////////////////////////  N  163 :
  N  164 :
/*********************************************************************  N  165 :
 *  N  166 :
 * enum CAN_RX_MSG_FLAGS  N  167 :
 *  N  168 :
 * These enumeration values define flags related to reception of a CAN  N  169 :
 * message.  There could be more than one these flags  N  170 :
 * ANDed together to form multiple flags.  N  171 :
 * If a particular bit is set, corresponding meaning is TRUE or else  N  172 :
 * it will be FALSE.  N  173 :
 *  N  174 :
 * e.g.  N  175 :
 *      if (MsgFlag & CAN_RX_OVERFLOW)  N  176 :
 *      {  N  177 :
 *          // Receiver overflow has occured.  We have lost previous  N  178 :
 *          // message.  N  179 :
 *          ...  N  180 :
 *      }  N  181 :
 *  N  182 :
 ********************************************************************/  N  183 :
typedef enum CAN_RX_MSG_FLAGS  N  184 :
{  N  185 :T527
    CAN_RX_FILTER_BITS  = 0b00000111,   // Use this to access filter  N  186 :
                                        // bits  N  187 :
    CAN_RX_FILTER_1     = 0b00000000,  N  188 :
    CAN_RX_FILTER_2     = 0b00000001,  N  189 :
    CAN_RX_FILTER_3     = 0b00000010,  N  190 :
    CAN_RX_FILTER_4     = 0b00000011,  N  191 :
    CAN_RX_FILTER_5     = 0b00000100,  N  192 :
    CAN_RX_FILTER_6     = 0b00000101,  N  193 :
  N  194 :
    CAN_RX_OVERFLOW     = 0b00001000,   // Set if Overflowed else  N  195 :
                                        // cleared  N  196 :
  N  197 :
    CAN_RX_INVALID_MSG  = 0b00010000,   // Set if invalid else  N  198 :
                                        // cleared  N  199 :
  N  200 :
    CAN_RX_XTD_FRAME    = 0b00100000,   // Set if XTD message else  N  201 :
                                        // cleared  N  202 :
  N  203 :
    CAN_RX_RTR_FRAME    = 0b01000000,   // Set if RTR message else  N  204 :
                                        // cleared  N  205 :
  N  206 :
    CAN_RX_DBL_BUFFERED = 0b10000000    // Set if this message was  N  207 :
                                        // hardware double-buffered  N  208 :
};  N  209 :
  N  210 :
//////////////////////////////////////////////////////////////////////  N  211 :
  N  212 :
  N  213 :
/*********************************************************************  N  214 :
 *  N  215 :
 * enum CAN_MASK  N  216 :
 *  N  217 :
 * These enumeration values define mask codes.  Routine CANSetMask()  N  218 :
 * requires this code as one of its arguments.  These enumerations  N  219 :
 * must be used by itself i.e. it cannot be ANDed to form multiple  N  220 :
 * values.  N  221 :
 *  N  222 :
 ********************************************************************/  N  223 :
typedef enum CAN_MASK  N  224 :
{  N  225 :T540
     CAN_MASK_B1,  N  226 :
     CAN_MASK_B2  N  227 :
};  N  228 :
  N  229 :
//////////////////////////////////////////////////////////////////////  N  230 :
  N  231 :
/*********************************************************************  N  232 :
 *  N  233 :
 * enum CAN_FILTER  N  234 :
 *  N  235 :
 * These enumeration values define filter codes.  Routine CANSetFilter  N  236 :
 * requires this code as one of its arguments.  These enumerations  N  237 :
 * must be used by itself  N  238 :
 * i.e. it cannot be ANDed to form multiple values.  N  239 :
 *  N  240 :
 ********************************************************************/  N  241 :
typedef enum CAN_FILTER  N  242 :
{  N  243 :T543
    CAN_FILTER_B1_F1,  N  244 :
    CAN_FILTER_B1_F2,  N  245 :
    CAN_FILTER_B2_F1,  N  246 :
    CAN_FILTER_B2_F2,  N  247 :
    CAN_FILTER_B2_F3,  N  248 :
    CAN_FILTER_B2_F4  N  249 :
};  N  250 :
  N  251 :
//////////////////////////////////////////////////////////////////////  N  252 :
  N  253 :
/*********************************************************************  N  254 :
 *  N  255 :
 * enum CAN_OP_MODE  N  256 :
 *  N  257 :
 * This enumeration values define codes related to CAN module  N  258 :
 * operation mode. CANSetOperationMode() routine requires this code.  N  259 :
 * These values must be used by itself  N  260 :
 * i.e. it cannot be ANDed to form * multiple values.  N  261 :
 *  N  262 :
 ********************************************************************/  N  263 :
typedef enum CAN_OP_MODE  N  264 :
{  N  265 :T550
    CAN_OP_MODE_BITS    = 0b11100000,   // Use this to access opmode  N  266 :
                                        // bits  N  267 :
    CAN_OP_MODE_NORMAL  = 0b00000000,  N  268 :
    CAN_OP_MODE_SLEEP   = 0b00100000,  N  269 :
    CAN_OP_MODE_LOOP    = 0b01000000,  N  270 :
    CAN_OP_MODE_LISTEN  = 0b01100000,  N  271 :
    CAN_OP_MODE_CONFIG  = 0b10000000  N  272 :
};  N  273 :
  N  274 :
//////////////////////////////////////////////////////////////////////  N  275 :
  N  276 :
/*********************************************************************  N  277 :
 *  N  278 :
 * enum CAN_CONFIG_FLAGS  N  279 :
 *  N  280 :
 * These enumeration values define flags related to configuring the CAN  N  281 :
 * module. Routines CANInitialize() and CANSetBaudRate() use these  N  282 :
 * codes. One or more of these values may be ANDed to form multiple  N  283 :
 * flags.  N  284 :
 *  N  285 :
 ********************************************************************/  N  286 :
//typedef enum CAN_CONFIG_FLAGS  N  287 :
//{  N  288 :
#define    CAN_CONFIG_DEFAULT           0b11111111,   // 11111111  N  289 :
  N  290 :
#define    CAN_CONFIG_PHSEG2_PRG_BIT    0b00000001  N  291 :
#define    CAN_CONFIG_PHSEG2_PRG_ON     0b11111111   // XXXXXXX1  N  292 :
#define    CAN_CONFIG_PHSEG2_PRG_OFF    0b11111110   // XXXXXXX0  N  293 :
  N  294 :
#define    CAN_CONFIG_LINE_FILTER_BIT   0b00000010  N  295 :
#define    CAN_CONFIG_LINE_FILTER_ON    0b11111111   // XXXXXX1X  N  296 :
#define    CAN_CONFIG_LINE_FILTER_OFF   0b11111101   // XXXXXX0X  N  297 :
  N  298 :
#define    CAN_CONFIG_SAMPLE_BIT        0b00000100  N  299 :
#define    CAN_CONFIG_SAMPLE_ONCE       0b11111111   // XXXXX1XX  N  300 :
#define    CAN_CONFIG_SAMPLE_THRICE     0b11111011   // XXXXX0XX  N  301 :
  N  302 :
#define    CAN_CONFIG_MSG_TYPE_BIT      0b00001000  N  303 :
#define    CAN_CONFIG_STD_MSG           0b11111111   // XXXX1XXX  N  304 :
#define    CAN_CONFIG_XTD_MSG           0b11110111   // XXXX0XXX  N  305 :
  N  306 :
#define    CAN_CONFIG_DBL_BUFFER_BIT    0b00010000  N  307 :
#define    CAN_CONFIG_DBL_BUFFER_ON     0b11111111   // XXX1XXXX  N  308 :
#define    CAN_CONFIG_DBL_BUFFER_OFF    0b11101111   // XXX0XXXX  N  309 :
  N  310 :
#define    CAN_CONFIG_MSG_BITS          0b01100000  N  311 :
#define    CAN_CONFIG_ALL_MSG           0b11111111   // X11XXXXX  N  312 :
#define    CAN_CONFIG_VALID_XTD_MSG     0b11011111   // X10XXXXX  N  313 :
#define    CAN_CONFIG_VALID_STD_MSG     0b10111111   // X01XXXXX  N  314 :
#define    CAN_CONFIG_ALL_VALID_MSG     0b10011111    // X00XXXXX  N  315 :
//};  N  316 :
  N  317 :
//////////////////////////////////////////////////////////////////////  N  318 :
  N  319 :
/*********************************************************************  N  320 :
 * Function:        void CANInitialize( BYTE SJW,  N  321 :
 *                                      BYTE BRP,  N  322 :
 *                                      BYTE PHSEG1,  N  323 :
 *                                      BYTE PHSEG2,  N  324 :
 *                                      BYTE PROPSEG,  N  325 :
 *                                      BYTE config)  N  326 :
 *  N  327 :
 * PreCondition:    MCU must be in Configuration mode or else these  N  328 :
 *                  values will be ignored.  N  329 :
 *  N  330 :
 * Input:           SJW     - SJW value as defined in 18CXX8 datasheet  N  331 :
 *                              (Must be between 1 thru 4)  N  332 :
 *                  BRP     - BRP value as defined in 18CXX8 datasheet  N  333 :
 *                              (Must be between 1 thru 64)  N  334 :
 *                  PHSEG1  - PHSEG1 value as defined in 18CXX8  N  335 :
 *                            datasheet  N  336 :
 *                              (Must be between 1 thru 8)  N  337 :
 *                  PHSEG2  - PHSEG2 value as defined in 18CXX8  N  338 :
 *                            datasheet  N  339 :
 *                              (Must be between 1 thru 8)  N  340 :
 *                  PROPSEG - PROPSEG value as defined in 18CXX8  N  341 :
 *                            datasheet  N  342 :
 *                              (Must be between 1 thru 8)  N  343 :
 *                  flags   - Value of type enum CAN_CONFIG_FLAGS  N  344 :
 *  N  345 :
 * Output:          CAN bit rate is set.  N  346 :
 *                  All masks registers are set '0'  N  347 :
 *                  to allow all messages.  N  348 :
 *                  Filter registers are set according to flag value.  N  349 :
 *                  If (config & CAN_CONFIG_VALID_XTD_MSG)  N  350 :
 *                      Set all filters to XTD_MSG  N  351 :
 *                  Else if (config & CONFIG_VALID_STD_MSG)  N  352 :
 *                      Set all filters to STD_MSG  N  353 :
 *                  Else  N  354 :
 *                      Set half of the filters to STD while rests to  N  355 :
 *                      XTD_MSG.  N  356 :
 *  N  357 :
 * Side Effects:    All pending transmissions are aborted.  N  358 :
 ********************************************************************/  N  359 :
void CANInitialize(BYTE SJW,  N  360 :f1808V558
                    BYTE BRP,  N  361 :V559
                    BYTE PHSEG1,  N  362 :V560
                    BYTE PHSEG2,  N  363 :V561
                    BYTE PROPSEG,  N  364 :V562
                    BYTE config);  N  365 :V563P1808
  N  366 :
//////////////////////////////////////////////////////////////////////  N  367 :
  N  368 :
  N  369 :
/*********************************************************************  N  370 :
 * Function:        void CANSetOperationMode(CAN_OP_MODE mode)  N  371 :
 *  N  372 :
 * PreCondition:    None  N  373 :
 *  N  374 :
 * Input:           mode    - Operation mode code  N  375 :
 *                            must be of type enum CAN_OP_MODES  N  376 :
 *  N  377 :
 * Output:          MCU is set to requested mode  N  378 :
 *  N  379 :
 * Side Effects:    None  N  380 :
 *  N  381 :
 * Note:            This is a blocking call.  It will not return until  N  382 :
 *                  requested mode is set.  N  383 :
 ********************************************************************/  N  384 :
void CANSetOperationMode(CAN_OP_MODE mode);  N  385 :f1815V565P1815
  N  386 :
//////////////////////////////////////////////////////////////////////  N  387 :
  N  388 :
  N  389 :
/*********************************************************************  N  390 :
 * Macro:           void CANSetOperationModeNoWait(CAN_OP_MODE mode)  N  391 :
 *  N  392 :
 * PreCondition:    None  N  393 :
 *  N  394 :
 * Input:           mode    - Operation mode code  N  395 :
 *                            must be of type enum CAN_OP_MODES  N  396 :
 *  N  397 :
 * Output:          MCU is set to requested mode  N  398 :
 *  N  399 :
 * Side Effects:    None  N  400 :
 *  N  401 :
 * Note:            This is a non-blocking call.  N  402 :
 *                  It does not verify that  N  403 :
 *                  CAN module is switched to requested mode or not.  N  404 :
 *                  Caller must use CANGetOperationMode() to verify  N  405 :
 *                  correct operation mode before performing mode  N  406 :
 *                  specific operation.  N  407 :
 *  N  408 :
 ********************************************************************/  N  409 :
#define CANSetOperationModeNoWait(mode) (CANCON = mode)  N  410 :
  N  411 :
//////////////////////////////////////////////////////////////////////  N  412 :
  N  413 :
/*********************************************************************  N  414 :
 * Macro:           CAN_OP_MODE CANSetOperationMode()  N  415 :
 *  N  416 :
 * PreCondition:    None  N  417 :
 *  N  418 :
 * Input:           None  N  419 :
 *  N  420 :
 * Output:          Current operational mode of CAN module is returned  N  421 :
 *  N  422 :
 * Side Effects:    None  N  423 :
 *  N  424 :
 ********************************************************************/  N  425 :
#define CANGetOperationMode() (CANCON & CAN_OP_MODE_BITS)  N  426 :
  N  427 :
//////////////////////////////////////////////////////////////////////  N  428 :
  N  429 :
/*********************************************************************  N  430 :
 * Function:        void CANSetBaudRate(BYTE SJW,  N  431 :
 *                                      BYTE BRP,  N  432 :
 *                                      BYTE PHSEG1,  N  433 :
 *                                      BYTE PHSEG2,  N  434 :
 *                                      BYTE PROPSEG,  N  435 :
 *                                      BYTE flags)  N  436 :
 *  N  437 :
 * PreCondition:    MCU must be in Configuration mode or else these  N  438 :
 *                  values will be ignored.  N  439 :
 *  N  440 :
 * Input:           SJW     - SJW value as defined in 18CXX8 datasheet  N  441 :
 *                              (Must be between 1 thru 4)  N  442 :
 *                  BRP     - BRP value as defined in 18CXX8 datasheet  N  443 :
 *                              (Must be between 1 thru 64)  N  444 :
 *                  PHSEG1  - PHSEG1 value as defined in 18CXX8  N  445 :
 *                            datasheet  N  446 :
 *                              (Must be between 1 thru 8)  N  447 :
 *                  PHSEG2  - PHSEG2 value as defined in 18CXX8  N  448 :
 *                            datasheet  N  449 :
 *                              (Must be between 1 thru 8)  N  450 :
 *                  PROPSEG - PROPSEG value as defined in 18CXX8  N  451 :
 *                            datasheet  N  452 :
 *                              (Must be between 1 thru 8)  N  453 :
 *                  flags   - Value of type enum CAN_CONFIG_FLAGS  N  454 :
 *  N  455 :
 * Output:          CAN bit rate is set as per given values.  N  456 :
 *  N  457 :
 * Side Effects:    None  N  458 :
 *  N  459 :
 ********************************************************************/  N  460 :
void CANSetBaudRate (BYTE SJW,  N  461 :f1819V567
                     BYTE BRP,  N  462 :V568
                     BYTE PHSEG1,  N  463 :V569
                     BYTE PHSEG2,  N  464 :V570
                     BYTE PROPSEG,  N  465 :V571
                     BYTE flags);  N  466 :V572P1819
  N  467 :
//////////////////////////////////////////////////////////////////////  N  468 :
  N  469 :
/*********************************************************************  N  470 :
 * Function:        void CANSetMask(enum CAN_MASK code,  N  471 :
 *                                  int32 val,  N  472 :
 *                                  BYTE type)  N  473 :
 *  N  474 :
 * PreCondition:    MCU must be in Configuration mode.  If not, all  N  475 :
 *                  values  N  476 :
 *                  will be ignored.  N  477 :
 *  N  478 :
 * Input:           code    - One of CAN_MASK value  N  479 :
 *                  val     - Actual mask register value.  N  480 :
 *                  type    - Type of message to filter either  N  481 :
 *                            CAN_CONFIG_XTD_MSG or CAN_CONFIG_STD_MSG  N  482 :
 *  N  483 :
 * Output:          Given value is bit adjusted to appropriate buffer  N  484 :
 *                  mask registers.  N  485 :
 *  N  486 :
 * Side Effects:    None  N  487 :
 ********************************************************************/  N  488 :
void CANSetMask (CAN_MASK code,  N  489 :f1821V574
                int32 val,  N  490 :V575
                BYTE type);  N  491 :V576P1821
  N  492 :
//////////////////////////////////////////////////////////////////////  N  493 :
  N  494 :
/*********************************************************************  N  495 :
 * Function:        void CANSetFilter(enum CAN_FILTER code,  N  496 :
 *                                    int32 val,  N  497 :
 *                                    BYTE type)  N  498 :
 *  N  499 :
 * PreCondition:    MCU must be in Configuration mode.  If not, all  N  500 :
 *                  values will be ignored.  N  501 :
 *  N  502 :
 * Input:           code    - One of CAN_FILTER value  N  503 :
 *                  val     - Actual filter register value.  N  504 :
 *                  type    - Type of message to filter either  N  505 :
 *                            CAN_CONFIG_XTD_MSG or CAN_CONFIG_STD_MSG  N  506 :
 *  N  507 :
 * Output:          Given value is bit adjusted to appropriate buffer  N  508 :
 *                  filter registers.  N  509 :
 *  N  510 :
 * Side Effects:    None  N  511 :
 ********************************************************************/  N  512 :
void CANSetFilter ( CAN_FILTER code,  N  513 :f1825V578
                    int32 val,  N  514 :V579
                    BYTE type);  N  515 :V580P1825
  N  516 :
//////////////////////////////////////////////////////////////////////  N  517 :
  N  518 :
/*********************************************************************  N  519 :
 * Function:        BOOL CANSendMessage(int32 id,  N  520 :
 *                                  BYTE *Data,  N  521 :
 *                                  BYTE DataLen,  N  522 :
 *                                  enum CAN_TX_MSG_FLAGS MsgFlags)  N  523 :
 *  N  524 :
 * PreCondition:    None  N  525 :
 *  N  526 :
 * Input:           id          - CAN message identifier.  N  527 :
 *                                Only 11 or 29 bits may be used  N  528 :
 *                                depending on standard or extended  N  529 :
 *                                message type.  N  530 :
 *                  Data        - Data bytes of upto 8 bytes in length  N  531 :
 *                  DataLen     - Data length from 1 thru 8.  N  532 :
 *                  MsgFlags    - One or CAN_TX_MSG_FLAGS values ANDed  N  533 :
 *                                together  N  534 :
 *  N  535 :
 * Output:          If at least one empty transmit buffer is found,  N  536 :
 *                  given message is queued to be transmitted. If none  N  537 :
 *                  found FALSE value is returned.  N  538 :
 *  N  539 :
 * Side Effects:    None  N  540 :
 *  N  541 :
 ********************************************************************/  N  542 :
BOOLEAN CANSendMessage (int32 id,  N  543 :f1826V582
                     BYTE *Data,  N  544 :V583
                     BYTE DataLen,  N  545 :V584
                     CAN_TX_MSG_FLAGS MsgFlags);  N  546 :V585P1826
  N  547 :
//////////////////////////////////////////////////////////////////////  N  548 :
  N  549 :
/*********************************************************************  N  550 :
 * Function:        BOOL CANReceiveMessage(int32 *id,  N  551 :
 *                                  BYTE *Data,  N  552 :
 *                                  BYTE *DataLen,  N  553 :
 *                                  enum CAN_RX_MSG_FLAGS *MsgFlags)  N  554 :
 *  N  555 :
 * PreCondition:    None  N  556 :
 *  N  557 :
 * Input:           None  N  558 :
 *  N  559 :
 * Output:          id          - CAN message identifier.  N  560 :
 *                  Data        - Data bytes of upto 8 bytes in length  N  561 :
 *                  DataLen     - Data length from 1 thru 8.  N  562 :
 *                  MsgFlags    - One or CAN_RX_MSG_FLAGS values ANDed  N  563 :
 *                                together  N  564 :
 *  N  565 :
 * Output:          If at least one full receive buffer is found,  N  566 :
 *                  it is extrated and returned. If none found FALSE  N  567 :
 *                  value is returned.  N  568 :
 *  N  569 :
 * Side Effects:    None  N  570 :
 *  N  571 :
 ********************************************************************/  N  572 :
BOOLEAN CANReceiveMessage(int32* id,  N  573 :f1831V587
                        BYTE *Data,  N  574 :V588
                        BYTE *DataLen,  N  575 :V589
                        CAN_RX_MSG_FLAGS *MsgFlags);  N  576 :V590P1831
  N  577 :
//////////////////////////////////////////////////////////////////////  N  578 :
  N  579 :
/*********************************************************************  N  580 :
 * Macro:           BYTE CANGetTxErrorCount()  N  581 :
 *  N  582 :
 * PreCondition:    None  N  583 :
 *  N  584 :
 * Input:           None  N  585 :
 *  N  586 :
 * Output:          Current transmit error count as defined by  N  587 :
 *                  CAN specifications.  N  588 :
 *  N  589 :
 * Side Effects:    None  N  590 :
 *  N  591 :
 ********************************************************************/  N  592 :
#define CANGetTxErrorCount()    (TXERRCNT)  N  593 :
  N  594 :
//////////////////////////////////////////////////////////////////////  N  595 :
  N  596 :
/*********************************************************************  N  597 :
 * Macro:           BYTE CANGetRxErrorCount()  N  598 :
 *  N  599 :
 * PreCondition:    None  N  600 :
 *  N  601 :
 * Input:           None  N  602 :
 *  N  603 :
 * Output:          Current receive error count as defined by  N  604 :
 *                  CAN specifications.  N  605 :
 *  N  606 :
 * Side Effects:    None  N  607 :
 *  N  608 :
 ********************************************************************/  N  609 :
#define CANGetRxErrorCount()    (RXERRCNT)  N  610 :
  N  611 :
//////////////////////////////////////////////////////////////////////  N  612 :
  N  613 :
/*********************************************************************  N  614 :
 * Macro:           BOOL CANIsBusOff()  N  615 :
 *  N  616 :
 * PreCondition:    None  N  617 :
 *  N  618 :
 * Input:           None  N  619 :
 *  N  620 :
 * Output:          TRUE if CAN Module is off due to excessive error  N  621 :
 *                  FALSE is it is not off.  N  622 :
 *  N  623 :
 * Side Effects:    None  N  624 :
 *  N  625 :
 ********************************************************************/  N  626 :
#define CANIsBusOff()           (COMSTAT_TXB0)  N  627 :
  N  628 :
//////////////////////////////////////////////////////////////////////  N  629 :
  N  630 :
/*********************************************************************  N  631 :
 * Macro:           BOOL CANIsTxPassive()  N  632 :
 *  N  633 :
 * PreCondition:    None  N  634 :
 *  N  635 :
 * Input:           None  N  636 :
 *  N  637 :
 * Output:          TRUE if CAN transmit module is error passive as  N  638 :
 *                  defined by CAN specifications.  N  639 :
 *  N  640 :
 * Side Effects:    None  N  641 :
 *  N  642 :
 ********************************************************************/  N  643 :
#define CANIsTxPassive()        (COMSTAT_TXBP)  N  644 :
  N  645 :
//////////////////////////////////////////////////////////////////////  N  646 :
  N  647 :
/*********************************************************************  N  648 :
 * Macro:           BYTE CANIsRxPassive()  N  649 :
 *  N  650 :
 * PreCondition:    None  N  651 :
 *  N  652 :
 * Input:           None  N  653 :
 *  N  654 :
 * Output:          TRUE if CAN receive module is error active as  N  655 :
 *                  defined by CAN specifications.  N  656 :
 *  N  657 :
 * Side Effects:    None  N  658 :
 *  N  659 :
 ********************************************************************/  N  660 :
#define CANIsRxPassive()        (COMSTAT_RXBP)  N  661 :
  N  662 :
//////////////////////////////////////////////////////////////////////  N  663 :
  N  664 :
/*********************************************************************  N  665 :
 * Macro:           void CANAbortAll()  N  666 :
 *  N  667 :
 * PreCondition:    None  N  668 :
 *  N  669 :
 * Input:           None  N  670 :
 *  N  671 :
 * Output:          None  N  672 :
 *  N  673 :
 * Side Effects:    None  N  674 :
 *  N  675 :
 ********************************************************************/  N  676 :
#define CANAbortAll()           (CANCON_ABAT = 1)  N  677 :
  N  678 :
//////////////////////////////////////////////////////////////////////  N  679 :
  N  680 :
/*********************************************************************  N  681 :
 * Macro:           BOOL  CANIsRxReady()  N  682 :
 *  N  683 :
 * PreCondition:    None  N  684 :
 *  N  685 :
 * Input:           None  N  686 :
 *  N  687 :
 * Output:          TRUE if at least one of the CAN receive buffer is  N  688 :
 *                  empty FALSE if none receive buffers are empty.  N  689 :
 *  N  690 :
 * Side Effects:    None  N  691 :
 *  N  692 :
 ********************************************************************/  N  693 :
#define CANIsRxReady()          (RXB0CON_RXFUL || RXB1CON_RXFUL)  N  694 :
  N  695 :
//////////////////////////////////////////////////////////////////////  N  696 :
  N  697 :
/*********************************************************************  N  698 :
 * Macro:           BOOL CANIsTxReady()  N  699 :
 *  N  700 :
 * PreCondition:    None  N  701 :
 *  N  702 :
 * Input:           None  N  703 :
 *  N  704 :
 * Output:          TRUE if at least one CAN transmit buffer is empty  N  705 :
 *                  FALSE if all CAN transmit buffers are full  N  706 :
 *  N  707 :
 * Side Effects:    None  N  708 :
 *  N  709 :
 ********************************************************************/  N  710 :
#define CANIsTxReady()          (!TXB0CON_TXREQ || \  N  711 :
                                 !TXB1CON_TXREQ || \  N  712 :
                                 !TXB2CON_TXREQ )  N  713 :
  N  714 :
#endif      // CAN18XX8_H  N  715 :
  N  716 :E
 N  716 :
  M   69 :
/*********************************************************************  M   70 :
 * Function:        void CANInitialize(BYTE SJW,  M   71 :
 *                                      BYTE BRP,  M   72 :
 *                                      BYTE PHSEG1,  M   73 :
 *                                      BYTE PHSEG2,  M   74 :
 *                                      BYTE PROPSEG,  M   75 :
 *                                      BYTE config)  M   76 :
 *  M   77 :
 * PreCondition:    MCU must be in Configuration mode or else these  M   78 :
 *                  values will be ignored.  M   79 :
 *  M   80 :
 * Input:           SJW     - SJW value as defined in 18CXX8 datasheet  M   81 :
 *                              (Must be between 1 thru 4)  M   82 :
 *                  BRP     - BRP value as defined in 18CXX8 datasheet  M   83 :
 *                              (Must be between 1 thru 64)  M   84 :
 *                  PHSEG1  - PHSEG1 value as defined in 18CXX8  M   85 :
 *                            datasheet  M   86 :
 *                              (Must be between 1 thru 8)  M   87 :
 *                  PHSEG2  - PHSEG2 value as defined in 18CXX8  M   88 :
 *                            datasheet  M   89 :
 *                              (Must be between 1 thru 8)  M   90 :
 *                  PROPSEG - PROPSEG value as defined in 18CXX8  M   91 :
 *                            datasheet  M   92 :
 *                              (Must be between 1 thru 8)  M   93 :
 *                  flags   - Value of type BYTE  M   94 :
 *  M   95 :
 * Output:          CAN bit rate is set. All masks registers are set  M   96 :
 *                  '0' to allow all messages.  M   97 :
 *                  Filter registers are set according to flag value.  M   98 :
 *                  If (config & CAN_CONFIG_VALID_XTD_MSG)  M   99 :
 *                      Set all filters to XTD_MSG  M  100 :
 *                  Else if (config & CONFIG_VALID_STD_MSG)  M  101 :
 *                      Set all filters to STD_MSG  M  102 :
 *                  Else  M  103 :
 *                      Set half of the filters to STD while rest to  M  104 :
 *                      XTD_MSG.  M  105 :
 *  M  106 :
 * Side Effects:    All pending transmissions are aborted.  M  107 :
 *  M  108 :
 ********************************************************************/  M  109 :
 void CANInitialize(BYTE SJW,  M  110 :f1808V558
                    BYTE BRP,  M  111 :V559
                    BYTE PHSEG1,  M  112 :V560
                    BYTE PHSEG2,  M  113 :V561
                    BYTE PROPSEG,  M  114 :V562
                    BYTE config)  M  115 :V563
 {  M  116 :{196
     BYTE FilterConfig1;  M  117 :V591
     BYTE FilterConfig2;  M  118 :V592
  M  119 :
    // In order to setup necessary config parameters of CAN module,  M  120 :
    // it must be in CONFIG mode.  M  121 :
    CANSetOperationMode(CAN_OP_MODE_CONFIG);  	//Set configuration mode  M  122 :
  M  123 :
    // Now set the baud rate, tQ and segment counts  M  124 :
    CANSetBaudRate(SJW,  M  125 :
                    BRP,  M  126 :
                    PHSEG1,  M  127 :
                    PHSEG2,  M  128 :
                    PROPSEG,  M  129 :
                    config);  M  130 :
  M  131 :
    RXB0CON = config & CAN_CONFIG_MSG_BITS;		//Receive: All, Valid XTND, Valid STD or All Valid CAN messages  M  132 :
    if ( (config & CAN_CONFIG_DBL_BUFFER_BIT) == CAN_CONFIG_DBL_BUFFER_ON )  M  133 :
        RXB0CON_RX0DBEN = 1;					//Enable Buffer0 overflow to write Buffer1  M  134 :
  M  135 :
    RXB1CON = RXB0CON;							//Set common bits of both Rx cntrl registers equal  M  136 :
  M  137 :
    // Set default filter and mask registers for all receive buffers.  M  138 :
    CANSetMask(CAN_MASK_B1, 0, CAN_CONFIG_XTD_MSG);  M  139 :
    CANSetMask(CAN_MASK_B2, 0, CAN_CONFIG_XTD_MSG);  M  140 :
  M  141 :
    switch( (config & CAN_CONFIG_MSG_BITS) | ~CAN_CONFIG_MSG_BITS )  M  142 :
    {  M  143 :
    case CAN_CONFIG_VALID_XTD_MSG:  M  144 :
        FilterConfig1 = CAN_CONFIG_XTD_MSG;  M  145 :
        FilterConfig2 = CAN_CONFIG_XTD_MSG;  M  146 :
        break;  M  147 :
  M  148 :
    case CAN_CONFIG_VALID_STD_MSG:  M  149 :
        FilterConfig1 = CAN_CONFIG_STD_MSG;  M  150 :
        FilterConfig2 = CAN_CONFIG_STD_MSG;  M  151 :
        break;  M  152 :
    default:  M  153 :
        FilterConfig1 = CAN_CONFIG_STD_MSG;  M  154 :
        FilterConfig2 = CAN_CONFIG_XTD_MSG;  M  155 :
        break;  M  156 :
    }  M  157 :
  M  158 :
    // By default, there will be no mask on any receive filters,  M  159 :
    // hence filter value of '0' will be ignored.  M  160 :
    CANSetFilter(CAN_FILTER_B1_F1, 0, FilterConfig1);  M  161 :
    CANSetFilter(CAN_FILTER_B1_F2, 0, FilterConfig1);  M  162 :
    CANSetFilter(CAN_FILTER_B2_F1, 0, FilterConfig2);  M  163 :
    CANSetFilter(CAN_FILTER_B2_F2, 0, FilterConfig2);  M  164 :
    CANSetFilter(CAN_FILTER_B2_F3, 0, FilterConfig2);  M  165 :
    CANSetFilter(CAN_FILTER_B2_F4, 0, FilterConfig2);  M  166 :
  M  167 :
    // Restore to Normal mode.  M  168 :
    CANSetOperationMode(CAN_OP_MODE_NORMAL);  M  169 :
}  M  170 :}205
  M  171 :
//////////////////////////////////////////////////////////////////////  M  172 :
  M  173 :
/*********************************************************************  M  174 :
 * Function:        void CANSetOperationMode(CAN_OP_MODE mode)  M  175 :
 *  M  176 :
 * PreCondition:    None  M  177 :
 *  M  178 :
 * Input:           mode    - Operation mode code  M  179 :
 *                            must be of type CAN_OP_MODES  M  180 :
 *  M  181 :
 * Output:          MCU is set to requested mode  M  182 :
 *  M  183 :
 * Side Effects:    None  M  184 :
 *  M  185 :
 * Overview:        Given mode byte is copied to CANSTAT and made  M  186 :
 *                  sure that requested mode is set.  M  187 :
 *  M  188 :
 * Note:            This is a blocking call.  It will not return until  M  189 :
 *                  requested mode is set.  M  190 :
 ********************************************************************/  M  191 :
void CANSetOperationMode(CAN_OP_MODE mode)  M  192 :f1815V565
{  M  193 :{206
     // Request desired mode of the CAN engine.  M  194 :
     CANCON = mode;  M  195 :
  M  196 :
    // Wait for the CAN engine to set the desired mode.  M  197 :
    while( (CANSTAT & CAN_OP_MODE_BITS) != mode );  M  198 :
}  M  199 :}211
  M  200 :
//////////////////////////////////////////////////////////////////////  M  201 :
  M  202 :
/*********************************************************************  M  203 :
 * Function:        void CANSetBaudRate(BYTE SJW,  M  204 :
 *                                      BYTE BRP,  M  205 :
 *                                      BYTE PHSEG1,  M  206 :
 *                                      BYTE PHSEG2,  M  207 :
 *                                      BYTE PROPSEG,  M  208 :
 *                                      BYTE flags)  M  209 :
 *  M  210 :
 * PreCondition:    MCU must be in Configuration mode or else these  M  211 :
 *                  values will be ignored.  M  212 :
 *  M  213 :
 * Input:           SJW     - SJW value as defined in 18CXX8 datasheet  M  214 :
 *                              (Must be between 1 thru 4)  M  215 :
 *                  BRP     - BRP value as defined in 18CXX8 datasheet  M  216 :
 *                              (Must be between 1 thru 64)  M  217 :
 *                  PHSEG1  - PHSEG1 value as defined in 18CXX8  M  218 :
 *                            datasheet  M  219 :
 *                              (Must be between 1 thru 8)  M  220 :
 *                  PHSEG2  - PHSEG2 value as defined in 18CXX8  M  221 :
 *                            datasheet  M  222 :
 *                              (Must be between 1 thru 8)  M  223 :
 *                  PROPSEG - PROPSEG value as defined in 18CXX8  M  224 :
 *                            datasheet  M  225 :
 *                              (Must be between 1 thru 8)  M  226 :
 *                  flags   - Value of type BYTE  M  227 :
 *  M  228 :
 * Output:          CAN bit rate is set as per given values.  M  229 :
 *  M  230 :
 * Side Effects:    None  M  231 :
 *  M  232 :
 * Overview:        Given values are bit adjusted to fit in 18CXX8  M  233 :
 *                  BRGCONx registers and copied.  M  234 :
 *  M  235 :
 ********************************************************************/  M  236 :
 void CANSetBaudRate(BYTE SJW,  M  237 :f1819V567
                     BYTE BRP,  M  238 :V568
                     BYTE PHSEG1,  M  239 :V569
                     BYTE PHSEG2,  M  240 :V570
                     BYTE PROPSEG,  M  241 :V571
                     BYTE flags)  M  242 :V572
 {  M  243 :{212
     // Actual values are offset '0'. (Can engine has 1 as a minimum)  M  244 :
     // Hence map given values from offset '1' to offset '0'  M  245 :
     SJW--;  M  246 :
     BRP--;  M  247 :
     PHSEG1--;  M  248 :
     PHSEG2--;  M  249 :
     PROPSEG--;  M  250 :
  M  251 :
    // Bit adjust given values into their appropriate registers.  M  252 :
    BRGCON1 = SJW << 6;  M  253 :
    BRGCON1 |= BRP;  M  254 :
  M  255 :
    BRGCON2 = PHSEG1 << 3;  M  256 :
    BRGCON2 |= PROPSEG;  M  257 :
  M  258 :
    if ( !(flags & CAN_CONFIG_SAMPLE_BIT) )  M  259 :
        BRGCON2_SAM = 1;					//Set sample thrice mode  M  260 :
  M  261 :
    if ( flags & CAN_CONFIG_PHSEG2_PRG_BIT )  M  262 :
        BRGCON2_SEG2PHTS = 1;				//Set segments fully programmable mode  M  263 :
  M  264 :
  M  265 :
    BRGCON3 = PHSEG2;  M  266 :
    if ( flags & CAN_CONFIG_LINE_FILTER_BIT )  M  267 :
        BRGCON3_WAKFIL = 1;					//Enable Line Filter for wake-up  M  268 :
  M  269 :
}  M  270 :}220
  M  271 :
//////////////////////////////////////////////////////////////////////  M  272 :
/*********************************************************************  M  273 :
 * Function:        void CANIDToRegs(BYTE* ptr,  M  274 :
 *                                      int32 val,  M  275 :
 *                                      BYTE config_flags)  M  276 :
 *  M  277 :
 * PreCondition:    None  M  278 :
 *  M  279 :
 * Input:           ptr     - Starting address of a buffer to be updated  M  280 :
 *                  val     - 32-bit value to be converted  M  281 :
 *                  type    - Type of message - either  M  282 :
 *                            CAN_CONFIG_XTD_MSG or CAN_CONFIG_STD_MSG  M  283 :
 *  M  284 :
 * Output:          Given CAN id value 'val' is bit adjusted and copied  M  285 :
 *                  into corresponding PIC18CXX8 CAN registers  M  286 :
 *  M  287 :
 * Side Effects:    None  M  288 :
 *  M  289 :
 * Overview:        If given id is of type standard identifier,  M  290 :
 *                  only SIDH and SIDL are updated  M  291 :
 *                  If given id is of type extended identifier,  M  292 :
 *                  bits val<17:0> is copied to EIDH, EIDL and SIDH<1:0>  M  293 :
 *                  bits val<28:18> is copied to SIDH and SIDL  M  294 :
 *  M  295 :
 ********************************************************************/  M  296 :
static void CANIDToRegs(BYTE* ptr,  M  297 :f1842V594
                        int32 val,  M  298 :V595
                        BYTE type)  M  299 :V596
{  M  300 :{222
    CAN_MESSAGE_ID *Value;  M  301 :V597
  M  302 :
    Value =  (CAN_MESSAGE_ID*)&val;  M  303 :
  M  304 :
    if ( type & CAN_CONFIG_MSG_TYPE_BIT )  M  305 :
    {  M  306 :
        // Standard Identifier  M  307 :
        *ptr = Value->BYTES.BYTE_1 >> 3;        // Copy SID<7:3> to SIDH<4:0>  M  308 :{226
        *ptr |= (Value->BYTES.BYTE_2 << 5);     // Copy SID<10:8> to SIDH<7:5>  M  309 :
        ptr++;                                  // Point to SIDL  M  310 :
        *ptr = Value->BYTES.BYTE_1 << 5;        // Copy SID<2:0> to SIDL<7:5>  M  311 :
    }  M  312 :}227
    else  M  313 :
    {  M  314 :
        // Extended Identifier  M  315 :
        *ptr = Value->BYTES.BYTE_3 >> 5;        // Copy EID<23:21> to SIDH<2:0>  M  316 :{229
        *ptr |= Value->BYTES.BYTE_4 << 3;       // Copy EID<28:24> to SIDH<7:3>  M  317 :
        ptr++;                                  // Point to SIDL  M  318 :
        *ptr = (Value->BYTES.BYTE_3 << 3) & 0xE0; // Copy EID<20:18> to SIDL<7:5>  M  319 :
                                                // mask out EID<17:16> bits  M  320 :
        *ptr |= 0b00001000;                     // Set EXIDEN bit  to SIDL<3>  M  321 :
        *ptr |= Value->BYTES.BYTE_3 & 0x03;     // Copy EID<17:16> to SIDL<1:0>  M  322 :
        ptr++;                                  // Point to EIDH  M  323 :
        *ptr = Value->BYTES.BYTE_2;             // Copy EID<15:8> to EIDH<7:0>  M  324 :
        ptr++;                                  // Point to EIDL  M  325 :
        *ptr = Value->BYTES.BYTE_1;             // Copy EID<7:0> to EIDL<7:0>  M  326 :
    }  M  327 :}230
}  M  328 :}231
  M  329 :
//////////////////////////////////////////////////////////////////////  M  330 :
/*********************************************************************  M  331 :
 * Function:        void RegsToCANID(BYTE *ptr,  M  332 :
 *                                      int32 *val,  M  333 :
 *                                      BYTE type)  M  334 :
 *  M  335 :
 * PreCondition:    None  M  336 :
 *  M  337 :
 * Input:           ptr     - Starting address of a buffer to be updated  M  338 :
 *                  val     - 32-bit buffer to hold value  M  339 :
 *                  type    - Type of message - either  M  340 :
 *                            CAN_CONFIG_XTD_MSG or CAN_CONFIG_STD_MSG  M  341 :
 *  M  342 :
 * Output:          CAN registers starting at given address are bit  M  343 :
 *                  adjusted and copied into 'val'  M  344 :
 *  M  345 :
 * Side Effects:    None  M  346 :
 *  M  347 :
 * Overview:        If given id is of type standard identifier,  M  348 :
 *                  only SIDH and SIDL are used  M  349 :
 *                  If given id is of type extended identifier,  M  350 :
 *                  bits EIDH, EIDL and SIDL<1:0> is copied to val<17:0>  M  351 :
 *                  bits SIDH and SIDL is copied to val<28:18>  M  352 :
 *  M  353 :
 ********************************************************************/  M  354 :
static void RegsToCANID(BYTE* ptr,  M  355 :f1845V599
                        int32 *val,  M  356 :V600
                        BYTE type)  M  357 :V601
{  M  358 :{233
    CAN_MESSAGE_ID *Value;  M  359 :V602
  M  360 :
    Value = (CAN_MESSAGE_ID*)val;  M  361 :
  M  362 :
    if ( type & CAN_CONFIG_MSG_TYPE_BIT )  M  363 :
    {  M  364 :
        // Standard Identifier  M  365 :
        Value->BYTES.BYTE_1 = (*ptr << 3);      // Copy SIDH<4:0> to SID<7:3>  M  366 :{237
        Value->BYTES.BYTE_2 = *ptr >> 5;        // Copy SIDH<7:5> to SID<10:8>  M  367 :
        ptr++;                                  // Point to SIDL  M  368 :
        Value->BYTES.BYTE_1 |= (*ptr >> 5);     // Copy SIDL<7:6> to SID<2:0>  M  369 :
        Value->BYTES.BYTE_3 = 0x00;  M  370 :
        Value->BYTES.BYTE_4 = 0x00;  M  371 :
    }  M  372 :}238
    else  M  373 :
    {  M  374 :
        // Extended Identifier  M  375 :
        Value->BYTES.BYTE_3 = (*ptr << 5);      // Copy SIDH<2:0> to EID<23:21>  M  376 :{240
        Value->BYTES.BYTE_4 = (*ptr >> 3);      // Copy SIDH<7:3> to EID<29:25>  M  377 :
        ptr++;                          		// Point to SIDL  M  378 :
        Value->BYTES.BYTE_3 |= (*ptr & 0x03);   // Copy SIDH<1:0> to EID<17:16>  M  379 :
        // Bug-Fix NKR 11/20/00  M  380 :
        Value->BYTES.BYTE_3 |= ((*ptr & 0xe0) >> 3);  // Copy SIDL<7:6> to EID<20:18>  M  381 :
        ptr++;                          		// Point to EIDH  M  382 :
        Value->BYTES.BYTE_2 = *ptr;             // Copy EIDH<15:8> to EID<15:8>  M  383 :
        ptr++;                                  // Point to EIDL  M  384 :
        Value->BYTES.BYTE_1 = *ptr;             // Copy EIDH<7:0> to EID<7:0>  M  385 :
    }  M  386 :}241
}  M  387 :}242
  M  388 :
  M  389 :
  M  390 :
/*********************************************************************  M  391 :
 * Function:        void CANSetMask(CAN_MASK code,  M  392 :
 *                                  int32 val,  M  393 :
 *                                  BYTE type)  M  394 :
 *  M  395 :
 * PreCondition:    MCU must be in Configuration mode.  If not, all  M  396 :
 *                  values will be ignored.  M  397 :
 *  M  398 :
 * Input:           code    - One of CAN_MASK value  M  399 :
 *                  val     - Actual mask register value.  M  400 :
 *                  type    - Type of message to filter either  M  401 :
 *                            CAN_CONFIG_XTD_MSG or CAN_CONFIG_STD_MSG  M  402 :
 *  M  403 :
 * Output:          Given value is bit adjusted to appropriate buffer  M  404 :
 *                  mask registers.  M  405 :
 *  M  406 :
 * Side Effects:    None  M  407 :
 *  M  408 :
 ********************************************************************/  M  409 :
 void CANSetMask(CAN_MASK code,  M  410 :f1821V574
                 int32 val,  M  411 :V575
                 BYTE type)  M  412 :V576
 {  M  413 :{243
     BYTE *ptr;  M  414 :V603
  M  415 :
    // Select appropriate starting address based on given CAN_MASK  M  416 :
    // value.  M  417 :
    if ( code == CAN_MASK_B1 )  M  418 :
        ptr = (BYTE*)&RXM0SIDH;  M  419 :
    else  M  420 :
        ptr = (BYTE*)&RXM1SIDH;  M  421 :
  M  422 :
    // Convert given 32-bit id value into corresponding register values.  M  423 :
    CANIDToRegs(ptr, val, type);  M  424 :
}  M  425 :}248
  M  426 :
//////////////////////////////////////////////////////////////////////  M  427 :
  M  428 :
/*********************************************************************  M  429 :
 * Function:        void CANSetFilter(CAN_FILTER code,  M  430 :
 *                                   int32 val,  M  431 :
 *                                   CAN_CONFIG type)  M  432 :
 *  M  433 :
 * PreCondition:    MCU must be in Configuration mode.  If not, all  M  434 :
 *                  values will be ignored.  M  435 :
 *  M  436 :
 *  M  437 :
 Input:             code    - One of CAN_FILTER value  M  438 :
 *                  val     - Actual filter register value.  M  439 :
 *                  type    - Type of message to filter either  M  440 :
 *                            CAN_CONFIG_XTD_MSG or CAN_CONFIG_STD_MSG  M  441 :
 *  M  442 :
 * Output:          Given value is bit adjusted to appropriate buffer  M  443 :
 *                  filter registers.  M  444 :
 *  M  445 :
 * Side Effects:    None  M  446 :
 ********************************************************************/  M  447 :
 void CANSetFilter(CAN_FILTER code,  M  448 :f1825V578
                    int32 val,  M  449 :V579
                    BYTE type)  M  450 :V580
 {  M  451 :{249
    BYTE *ptr;  M  452 :V604
  M  453 :
    // Select appropriate starting address based on given CAN_FILTER  M  454 :
    // code.  M  455 :
    switch(code)  M  456 :
    {  M  457 :
    case CAN_FILTER_B1_F1:  M  458 :
        ptr = (BYTE*)&RXF0SIDH;  M  459 :
        break;  M  460 :
  M  461 :
    case CAN_FILTER_B1_F2:  M  462 :
        ptr = (BYTE*)&RXF1SIDH;  M  463 :
        break;  M  464 :
  M  465 :
    case CAN_FILTER_B2_F1:  M  466 :
        ptr = (BYTE*)&RXF2SIDH;  M  467 :
        break;  M  468 :
  M  469 :
    case CAN_FILTER_B2_F2:  M  470 :
        ptr = (BYTE*)&RXF3SIDH;  M  471 :
        break;  M  472 :
  M  473 :
    case CAN_FILTER_B2_F3:  M  474 :
        ptr = (BYTE*)&RXF4SIDH;  M  475 :
        break;  M  476 :
  M  477 :
    default:  M  478 :
        ptr = (BYTE*)&RXF5SIDH;  M  479 :
        break;  M  480 :
    }  M  481 :
  M  482 :
    // Convert 32-bit value into register values.  M  483 :
    CANIDToRegs(ptr, val, type);  M  484 :
  M  485 :
}  M  486 :}259
  M  487 :
//////////////////////////////////////////////////////////////////////  M  488 :
  M  489 :
/*********************************************************************  M  490 :
 * Function:        BOOLEAN CANSendMessage(int32 id,  M  491 :
 *                                  BYTE *Data,  M  492 :
 *                                  BYTE DataLen,  M  493 :
 *                                  CAN_TX_MSG_FLAGS MsgFlags)  M  494 :
 *  M  495 :
 * PreCondition:    None  M  496 :
 *  M  497 :
 * Input:           id          - CAN message identifier.  M  498 :
 *                                Only 11 or 29 bits may be used  M  499 :
 *                                depending on standard or extended  M  500 :
 *                                message type.  M  501 :
 *                  Data        - Data bytes of upto 8 bytes in length  M  502 :
 *                  DataLen     - Data length from 1 thru 8.  M  503 :
 *                  MsgFlags    - One or more CAN_TX_MSG_FLAGS values ANDed  M  504 :
 *                                together  M  505 :
 *  M  506 :
 * Output:          If at least one empty transmit buffer is found,  M  507 :
 *                  given message is queued to be transmitted. If none  M  508 :
 *                  found within 50 miliseconds a FALSE value is returned.  M  509 :
 *  M  510 :
 * Side Effects:    None  M  511 :
 *  M  512 :
 ********************************************************************/  M  513 :
BOOLEAN CANSendMessage(int32 id,  M  514 :f1826V582
                     BYTE* Data,  M  515 :V583
                     BYTE DataLen,  M  516 :V584
                     CAN_TX_MSG_FLAGS MsgFlags)  M  517 :V585
{  M  518 :{260
    BYTE i;  M  519 :V605
    BYTE *ptr;  M  520 :V606
  M  521 :
	// Return FALSE if a TX buffer is not available within 50ms.  M  522 :
	i=0;  M  523 :
	while ((TXB0CON_TXREQ & TXB1CON_TXREQ & TXB2CON_TXREQ) == 1)  M  524 :
	{  M  525 :
		delay_ms(1);			// Delay 1 millisecond  M  526 :{271
		if (++i >= 50)  M  527 :
			return FALSE;  M  528 :
	}  M  529 :}274
  M  530 :
	// Find the first empty transmitter.  M  531 :
    if ( TXB0CON_TXREQ == 0 )  M  532 :
    {  M  533 :
        // TxBuffer0 is empty.  Set WIN bits to point to TXB0  M  534 :
        CANCON &= 0b11110001;  M  535 :{279
        CANCON |= 0b00001000;  M  536 :
    }  M  537 :}280
    else if ( TXB1CON_TXREQ == 0 )  M  538 :
    {  M  539 :
        // TxBuffer1 is empty. Set WIN bits to point to TXB1  M  540 :
        CANCON &= 0b11110001;  M  541 :{286
        CANCON |= 0b00000110;  M  542 :
    }  M  543 :}287
    else if ( TXB2CON_TXREQ == 0 )  M  544 :
    {  M  545 :
        // TxBuffer2 is empty. Set WIN bits to point to TXB2  M  546 :
        CANCON &= 0b11110001;  M  547 :{293
        CANCON |= 0b00000100;  M  548 :
    }  M  549 :}294
    else  M  550 :
        // None of the transmit buffers were empty.  M  551 :
        return FALSE;  M  552 :
  M  553 :
    /*  M  554 :
     * Now that WIN has remapped RXB0 to empty buffer, simply  M  555 :
     * populate RXB0 buffer, which is really accessing one of the TX buffers  M  556 :
     */  M  557 :
  M  558 :
    // Set transmit priority.  M  559 :
    RXB0CON = MsgFlags & CAN_TX_PRIORITY_BITS;  M  560 :
  M  561 :
    // Populate Extended identifier information only if it is  M  562 :
    // desired.  M  563 :
    if ( !(MsgFlags & CAN_TX_FRAME_BIT) )  M  564 :
        CANIDToRegs((BYTE*)&RXB0SIDH, id, CAN_CONFIG_XTD_MSG);  M  565 :
    else  M  566 :
        CANIDToRegs((BYTE*)&RXB0SIDH, id, CAN_CONFIG_STD_MSG);  M  567 :
  M  568 :
    RXB0DLC = DataLen;  M  569 :
  M  570 :
    if ( !(MsgFlags & CAN_TX_RTR_BIT) )  M  571 :
        RXB0DLC |= 0b01000000;  M  572 :
  M  573 :
    // Populate data values.  M  574 :
    ptr = (BYTE*)&RXB0D0;  M  575 :
    for ( i = 0; i < DataLen; i++ )  M  576 :
        ptr[i] = Data[i];  M  577 :
  M  578 :
    /*  M  579 :
     * Mark this buffer as ready to start transmit.  M  580 :
     * We are not using C bit field structure because RXB0 registers  M  581 :
     * are remapped to one of the empty transmit buffers and their  M  582 :
     * bit3 is not same as RXB0CON bit3.  To avoid confusion, in-line  M  583 :
     * assembly is used to directly set bit 3 of corresponding TXBnCON  M  584 :
     * register.  M  585 :
     */  M  586 :
  M  587 :
     #asm  M  588 :
     bsf RXB0CON, 3  M  589 :
     #endasm  M  590 :
      M  591 :
/*  M  592 :
     * Restore CAN buffer mapping so that subsequent access to RXB0  M  593 :
     * buffers are to the real RXB0 buffer.  M  594 :
     */  M  595 :
    CANCON &= 0b11110001;  M  596 :
  M  597 :
    return TRUE;  M  598 :
}  M  599 :}307
  M  600 :
//////////////////////////////////////////////////////////////////////  M  601 :
  M  602 :
/*********************************************************************  M  603 :
 * Function:        BOOLEAN CANReceiveMessage(int32 *id,  M  604 :
 *                                  BYTE *Data,  M  605 :
 *                                  BYTE DataLen,  M  606 :
 *                                  CAN_RX_MSG_FLAGS MsgFlags)  M  607 :
 *  M  608 :
 * PreCondition:    None  M  609 :
 *  M  610 :
 * Input:           None  M  611 :
 *  M  612 :
 * Output:          id          - CAN message identifier.  M  613 :
 *                  Data        - Data bytes of upto 8 bytes in length  M  614 :
 *                  DataLen     - Data length from 1 thru 8.  M  615 :
 *                  MsgFlags    - One or CAN_RX_MSG_FLAGS values ANDed  M  616 :
 *                                together  M  617 :
 *  M  618 :
 * Output:          If at least one full receive buffer is found,  M  619 :
 *                  it is extrated and returned.  M  620 :
 *                  If none found FALSE value is returned.  M  621 :
 *  M  622 :
 * Side Effects:    None  M  623 :
 *  M  624 :
 ********************************************************************/  M  625 :
BOOLEAN CANReceiveMessage(int32 *id,  M  626 :f1831V587
                        BYTE *Data,  M  627 :V588
                        BYTE *DataLen,  M  628 :V589
                        CAN_RX_MSG_FLAGS *MsgFlags)  M  629 :V590
{  M  630 :{308
    BYTE i;  M  631 :V607
    BYTE *ptr;  M  632 :V608
    BOOLEAN lbIsItBuffer0;  M  633 :V609
  M  634 :
    // Start with no error or flags set.  M  635 :
    *MsgFlags = 0x0;  M  636 :
  M  637 :
    // Find which buffer is ready.  M  638 :
    if ( RXB0CON_RXFUL )  M  639 :
    {  M  640 :
        // RXBuffer0 is full.  M  641 :
        CANCON &= 0b11110001;  M  642 :{312
  M  643 :
        lbIsItBuffer0 = TRUE;  M  644 :
  M  645 :
        // Clear the received flag.  M  646 :
        PIR3_RXB0IF = 0;  M  647 :
  M  648 :
        // Record and forget any previous overflow  M  649 :
        if ( COMSTAT_RX0OVFL )  M  650 :
        {  M  651 :
            *MsgFlags |= CAN_RX_OVERFLOW;  M  652 :{315
            COMSTAT_RX0OVFL = 0;  M  653 :
        }  M  654 :}316
  M  655 :
        if ( RXB0CON_RX0DBEN )  M  656 :
        {  M  657 :
            *MsgFlags |= RXB0CON & CAN_RX_FILTER_BITS;  M  658 :{319
            *MsgFlags &= 0x01;  M  659 :
        }  M  660 :}320
    }  M  661 :}321
    else if ( RXB1CON_RXFUL )  M  662 :
    {  M  663 :
        // RXBuffer1 is full  M  664 :
        CANCON &= 0b11110001;  M  665 :{325
        CANCON |= 0b00001010;  M  666 :
  M  667 :
        lbIsItBuffer0 = FALSE;  M  668 :
  M  669 :
        // Clear the received flag.  M  670 :
        PIR3_RXB1IF = 0;  M  671 :
  M  672 :
        // Record and forget any previous overflow  M  673 :
        if ( COMSTAT_RX1OVFL )  M  674 :
        {  M  675 :
            *MsgFlags |= CAN_RX_OVERFLOW;  M  676 :{328
            COMSTAT_RX1OVFL = 0;  M  677 :
        }  M  678 :}329
  M  679 :
        *MsgFlags |= RXB1CON & CAN_RX_FILTER_BITS;  M  680 :
        if ( *MsgFlags < 0x02 )  M  681 :
            *MsgFlags |= CAN_RX_DBL_BUFFERED;  M  682 :
    }  M  683 :}332
    else  M  684 :
        return FALSE;  M  685 :
  M  686 :
    // Retrieve message length.  M  687 :
    *DataLen = RXB0DLC & 0b00001111;  M  688 :
  M  689 :
    // Determine whether this was RTR or not.  M  690 :
    if ( RXB0DLC_RTR )  M  691 :
        *MsgFlags |= CAN_RX_RTR_FRAME;  M  692 :
  M  693 :
    // Retrieve EIDX bytes only if this is extended message  M  694 :
    if ( RXB0SIDL_EXID )  M  695 :
    {  M  696 :
        *MsgFlags |= CAN_RX_XTD_FRAME;  M  697 :{338
  M  698 :
        RegsToCANID((BYTE*)&RXB0SIDH, id, CAN_CONFIG_XTD_MSG);  M  699 :
    }  M  700 :}339
    else  M  701 :
        RegsToCANID((BYTE*)&RXB0SIDH, id, CAN_CONFIG_STD_MSG);  M  702 :
  M  703 :
    // Get message data itself  M  704 :
	if (Data)   // check if caller's pointer is null before copying out the message  M  705 :
	{  M  706 :
        ptr = (BYTE*)&RXB0D0;  M  707 :{343
        for ( i = 0; i < *DataLen; i++ )  M  708 :
            Data[i] = ptr[i];  M  709 :
	}  M  710 :}350
  M  711 :
    // Restore default RXB0 mapping.  M  712 :
    CANCON &= 0b11110001;  M  713 :
  M  714 :
    // Record and Clear any previous invalid message bit flag.  M  715 :
    if ( PIR3_IRXIF )  M  716 :
    {  M  717 :
        *MsgFlags |= CAN_RX_INVALID_MSG;  M  718 :{353
        PIR3_IRXIF = 0;  M  719 :
    }  M  720 :}354
  M  721 :
    if ( lbIsItBuffer0 )  M  722 :
        RXB0CON_RXFUL = 0;  M  723 :
    else  M  724 :
        RXB1CON_RXFUL = 0;  M  725 :
  M  726 :
    return TRUE;  M  727 :
}  M  728 :}358
  M  729 :
  M  730 :
  M  731 :E
 M  731 :
#include "Vehicle.c" A   47 :
 //------------------------------------------------------------------------------  O    1 :I14
// File: Vehicle  O    2 :
//  O    3 :
// Purpose: Vehicle communication and parsing routines.  O    4 :
//  O    5 :
// TBD - bit_test() takes too much ROM, might be able to bit mask and save space.  O    6 :
//  O    7 :
// Change History:  O    8 :
// Date		Author		Description  O    9 :
//          Lafreniere	Created  O   10 :
//------------------------------------------------------------------------------  O   11 :
#include "Vehicle.h" O   12 :
 //------------------------------------------------------------------------------  P    1 :I15
// File: Vehicle  P    2 :
//  P    3 :
// Purpose: Vehicle communication and parsing routines.   P    4 :
//  P    5 :
// Change History:  P    6 :
// Date		Author		Description  P    7 :
//          Lafreniere	Created  P    8 :
//------------------------------------------------------------------------------  P    9 :
#ifndef VEHICLE_H  P   10 :
#define VEHICLE_H  P   11 :
  P   12 :
void VehSendRecv();  P   13 :f1849P1849
  P   14 :
#endif  P   15 :E
 P   15 :
#include "Globals.h" O   13 :
 //------------------------------------------------------------------------------  F    1 :I5
// File: Globals  F    2 :
//  F    3 :
// Purpose: Project global variables.  F    4 :
//  F    5 :
// Change History:  F    6 :
// Date		Author		Description  F    7 :
//          Lafreniere	Created  F    8 :
//------------------------------------------------------------------------------  F    9 :
#ifndef GLOBALS_H  F   10 :
#define GLOBALS_H  F   11 :
  F   12 :
#include "Const.h"  F   13 :
#include "Timer.h"  F   14 :
                   F   15 :
typedef struct   F   16 :
{  F   17 :
    int8 comType : 3;  F   18 :
    int8 firstResp : 1;  F   19 :
	int8 forceInitCAN : 1;  F   20 :
    int8 canModeChanged : 1;  // true when mode changes (e.g. 250kb to 500kb, or SI to EI)  F   21 :
    int8 adapterLocked : 1;  F   22 :
	int8 enableLLineXmit : 1; 		// transmit at 10.4 on both K and L lines (default is K line only)  F   23 :
	int8 enableIso9600Baud : 1;		// transmit ISO at 9600 if true, false means 10.4k (default is 10.4k)  F   24 :
	int8 enableIso5msByteDelay : 1; // true means 5mS between each byte sent to vehicle, false no delay (default is true)  F   25 :
	int8 enableIsoChecksum : 1;		// add checksum byte to ISO messages if true, no byte added if false (default is true)  F   26 :
} Flags;  F   27 :
  F   28 :
int8 gDevid1;  F   29 :
int8 gDevid2;  F   30 :
  F   31 :
Flags gFlags = { MODE_ISO, FALSE };  F   32 :
int8 gError = ERR_NONE;  F   33 :
int8 gErrorExtraData1 = 0;  F   34 :
int8 gErrorExtraData2 = 0;  F   35 :
int8 gErrorExtraData3 = 0;  F   36 :
  F   37 :
int8 gHostBuf[HOST_RECV_MSG_SIZE];  F   38 :
//*** #locate gHostBuf=0x2d  // pic18f248 should not require ram to be managed  F   39 :
int8 gHostBufCnt = 0;  F   40 :
int16 gHostRecvTimeout = 0;  F   41 :
  F   42 :
int8 gVehicleBuf[VEHICLE_MAX_MSGS][VEHICLE_MSG_SIZE];  F   43 :
//*** #locate gVehicleBuf=0xa0  F   44 :
  F   45 :
int8 gVehicleBufCnt = 0;  F   46 :
  F   47 :
int8 gCurrentCmd = 0;   // current command sent from host  F   48 :
int8 gLastCmd = 0;      // last command sent from host  F   49 :
  F   50 :
int32 gP2can = HST_FIFTY_MS;  F   51 :
  F   52 :
// decyption variables  F   53 :
int16  gLfsr;  F   54 :
//int8 gLast;  F   55 :
  F   56 :
#endif  F   57 :E
 F   57 :
#include "Const.h" O   14 :
 //------------------------------------------------------------------------------  E    1 :I4
// File: Const  E    2 :
//  E    3 :
// Purpose: Project constants.  E    4 :
//  E    5 :
// Change History:  E    6 :
// Date		Author		Description  E    7 :
//          Lafreniere	Created  E    8 :
//------------------------------------------------------------------------------  E    9 :
#ifndef CONST_H  E   10 :
#define CONST_H  E   11 :
  E   12 :
#ifdef DEBUG  E   13 :
    #define TRACE(char) Trace(char);  E   14 :
#else  E   15 :
    #define TRACE(char)   E   16 :
#endif  E   17 :
  E   18 :
// software revision  E   19 :
#define SOFTWARE_REV            0x08  E   20 :
  E   21 :
#define MAX_ECU				8 	// per ISO 15675-4 7.3.3. max ECUs is 8  E   22 :
  E   23 :
#define DEVID1_ADDR 0x3FFFFEL  E   24 :
#define DEVID2_ADDR 0x3FFFFFL   E   25 :
  E   26 :
// The old 18F248 and the new 18F2480 have some differences, mostly in the analog  E   27 :
// to digital converter. Using _DEVID2 check the processor version.   E   28 :
#define VER_18F248				0x08  E   29 :
//#define VER_18F2480 					  E   30 :
  E   31 :
// destination address  E   32 :
#define DESTINATION_ADDR        0x2d  E   33 :
  E   34 :
// from host msg byte positions  E   35 :
#define IDX_HOST_DESTINATION        0  E   36 :
#define IDX_HOST_COMMAND            1  E   37 :
#define IDX_HOST_BYTE_COUNT         2  E   38 :
#define IDX_HOST_START_DATA         3  E   39 :
#define IDX_HOST_CHECKSUM           14  E   40 :
  E   41 :
// to host msg byte positions  E   42 :
#define IDX_VEHICLE_DESTINATION     0  E   43 :
#define IDX_VEHICLE_COMMAND         1  E   44 :
#define IDX_VEHICLE_CHECKSUM        13  E   45 :
  E   46 :
// max size of all messages  E   47 :
#define HOST_RECV_MSG_SIZE          15      // from host size including all non-OBD II bytes  E   48 :
#define HOST_SEND_MSG_SIZE          14      // to host size  E   49 :
#define VEHICLE_MSG_SIZE            12      // to/from max vehicle size, not as sent to host (RSP byte not included)   E   50 :
#define VEHICLE_MAX_MSGS            32      // number of VEHICLE_MSG_SIZE we can store in RAM  E   51 :
  E   52 :
// error codes returned to host  E   53 :
#define ERR_NONE                        0x00   // ERR_NONE must be 0!  E   54 :
#define ERR_NOT_IMPLEMENTED             0x01  E   55 :
#define ERR_BAD_CHECKSUM                0x02  E   56 :
#define ERR_ISO_NO_SYNC                 0x03  E   57 :
#define ERR_ISO_INCORRECT_INV_ADDR      0x04  E   58 :
#define ERR_ISO_NO_RESPONSE             0x05  E   59 :
#define ERR_J1850_NO_RESPONSE           0x07  E   60 :
#define ERR_ISO_BAD_CHECKSUM            0x08  E   61 :
#define ERR_J1850_BAD_CRC               0x09      E   62 :
#define ERR_KWP_BAUD_TOO_SLOW           0x0b    // not used  E   63 :
#define ERR_KWP_NO_RESPONSE             0x0c    // not used  E   64 :
#define ERR_KWP_INCORRECT_SYNC          0x0d    // not used  E   65 :
#define ERR_ISO_NOT_ENABLED             0x10    // not used  E   66 :
#define ERR_J1850_VPW_NOT_ENABLED       0x11    // not used  E   67 :
#define ERR_J1850_PWM_NOT_ENABLED       0x12    // not used  E   68 :
#define ERR_KWP_NOT_ENABLED             0x13    // not used  E   69 :
#define ERR_VW_PASS_THRU_NOT_ENABLED    0x14    // not used  E   70 :
#define ERR_CAN_NO_RESPONSE             0x15	// COMSTAT CAN register returned as extra data  E   71 :
#define ERR_CAN_RX_OVERFLOW             0x16  E   72 :
#define ERR_CAN_TX_BUFFER_UNAVAIL       0x18  E   73 :
#define ERR_CAN_RX_MESSAGE_LEN_WRONG    0x19  E   74 :
#define ERR_CAN_ERROR_INTERRUPT			0x1A	// COMSTAT CAN register returned as extra data  E   75 :
#define ERR_CAN_INVALID_MSG_INTERRUPT   0x1B    // TXBnCON CAN register returned as extra data 1, 2 and 3  E   76 :
#define ERR_ISO_INV_ADDR_NOT_RECEIVED	0x1F  E   77 :
#define ERR_ISO_SYNC_BYTE_NOT_RECEIVED	0x20  E   78 :
  E   79 :
#define ERR_WRONG_DESTINATION           0x80      E   80 :
#define ERR_BYTE_COUNT_TOO_LARGE        0x81  E   81 :
#define ERR_J1850_FRAMING_ERROR         0x82  E   82 :
#define ERR_J1850_MSG_OVERFLOW          0x83   E   83 :
#define ERR_ISO_NO_KEYBYTE              0x84  E   84 :
#define ERR_ADAPTER_LOCKED              0x85  E   85 :
#define ERR_INVALID_NON_VOLATILE_SECTOR 0x86  E   86 :
#define ERR_NON_VOLATILE_SECTOR_LOCKED  0x87  E   87 :
  E   88 :
// host-to-adapter commands  E   89 :
#define CMD_ISO_WITH_5_BAUD             0x01  E   90 :
#define CMD_VPW                         0x02  E   91 :
#define CMD_PWM                         0x04  E   92 :
#define CMD_CAN_SI_250KB                0x08      E   93 :
#define CMD_ISO                         0x10  E   94 :
#define CMD_VW_PASS_THRU_WITH_5_BAUD    0x20    // not used  E   95 :
#define CMD_VW_PASS_THRU_WITHOUT_5_BAUD 0x40    // not used  E   96 :
#define CMD_PWM_WITH_IFR                0x80  E   97 :
#define CMD_ISO_1ST_RESPONSE            0x81  E   98 :
#define CMD_VPW_1ST_RESPONSE            0x82  E   99 :
#define CMD_ATOD_CONVERSION             0x83    // not used  E  100 :
#define CMD_PWM_1ST_RESPONSE            0x84  E  101 :
#define CMD_KWP_WITH_5_BAUD             0x85  E  102 :
#define CMD_KWP_REPORT_KW1_KW2          0x86    // not used  E  103 :
#define CMD_KWP_FAST_INIT               0x87  E  104 :
#define CMD_KWP                         0x88  E  105 :
#define CMD_KWP_1ST_RESPONSE            0x89  E  106 :
#define CMD_CAN_SI_500KB                0x90  E  107 :
#define CMD_CAN_EI_250KB                0x91  E  108 :
#define CMD_CAN_EI_500KB                0x92  E  109 :
#define CMD_CAN_SI_250KB_1ST            0x93  E  110 :
#define CMD_CAN_SI_500KB_1ST            0x94  E  111 :
#define CMD_CAN_EI_250KB_1ST            0x95  E  112 :
#define CMD_CAN_EI_500KB_1ST            0x96  E  113 :
#define CMD_CAN_SET_STD_MASK_FILTER		0x97  E  114 :
#define CMD_CAN_SET_XTD_MASK_FILTER		0x98  E  115 :
#define CMD_CAN_SET_P2_CAN_TIMEOUT		0x99  E  116 :
#define CMD_CAN_SI_250KB_FBGO			0x9A	// FBGO = fast bus get off  E  117 :
#define CMD_CAN_SI_500KB_FBGO			0x9B	// FBGO = fast bus get off  E  118 :
#define CMD_CAN_EI_250KB_FBGO			0x9C	// FBGO = fast bus get off  E  119 :
#define CMD_CAN_EI_500KB_FBGO			0x9D	// FBGO = fast bus get off  E  120 :
#define CMD_CAN_SI_250KB_LISTEN			0x9E	  E  121 :
#define CMD_CAN_SI_500KB_LISTEN			0x9F	  E  122 :
#define CMD_CAN_EI_250KB_LISTEN			0xA0	  E  123 :
#define CMD_CAN_EI_500KB_LISTEN			0xA1  E  124 :
#define CMD_CAN_SI_250KB_NO_RESPONSE	0xA2	  E  125 :
#define CMD_CAN_SI_500KB_NO_RESPONSE	0xA3	  E  126 :
#define CMD_CAN_EI_250KB_NO_RESPONSE	0xA4	  E  127 :
#define CMD_CAN_EI_500KB_NO_RESPONSE	0xA5  E  128 :
#define CMD_ISO_NO_RESPONSE				0xA6  E  129 :
#define CMD_ISO_ENABLE_L_LINE_XMIT		0xA9  E  130 :
#define CMD_ISO_SET_9600_BAUD			0xAB  E  131 :
#define CMD_ISO_CHECKSUM_ENABLE			0xAC  E  132 :
#define CMD_ISO_5MS_BYTE_DELAY_ENABLE	0xAD  E  133 :
#define CMD_UNLOCK_ADAPTER              0xB0	  E  134 :
#define CMD_READ_EEPROM					0xB9  E  135 :
#define CMD_WRITE_EEPROM				0xBA  E  136 :
#define CMD_KWP_FAST_INIT_9600			0xC4  E  137 :
#define CMD_READ_BATTERY_VOLTAGE		0xF0  E  138 :
  E  139 :
// adapter-to-host commands  E  140 :
#define CMD_ERROR                       0x80  E  141 :
#define CMD_ISO_MSG                     0x81  E  142 :
#define CMD_VPW_MSG                     0x82  E  143 :
#define CMD_PWM_MSG                     0x84  E  144 :
#define CMD_CAN_MSG                     0x88  E  145 :
#define CMD_KWP_MSG                     0x01  E  146 :
#define CMD_LOCAL_DATA					0x40  E  147 :
  E  148 :
// transmit modes (must fit in 3-bits!)  E  149 :
#define MODE_ISO                 0x00  E  150 :
#define MODE_VPW                 0x01  E  151 :
#define MODE_PWM                 0x02  E  152 :
#define MODE_KWP                 0x03  E  153 :
#define MODE_CAN                 0x04  E  154 :
  E  155 :
// interface capabilites (i.e. what com modes does the adapter support)  E  156 :
#define CAP_ISO         0x01  E  157 :
#define CAP_VPW         0x02  E  158 :
#define CAP_PWM         0x04  E  159 :
#define CAP_KWP         0x08  E  160 :
#define CAP_CAN         0x10  E  161 :
#define CAP_DUAL_CAN	0x20  E  162 :
#define DASH_DYNO_VER	0x40  E  163 :
#ifdef DASH_DYNO  E  164 :
#define CAP_INTERFACE   (CAP_ISO | CAP_VPW | CAP_PWM | CAP_KWP | CAP_CAN | DASH_DYNO_VER)  E  165 :
#else  E  166 :
#define CAP_INTERFACE   (CAP_ISO | CAP_VPW | CAP_PWM | CAP_KWP | CAP_CAN)  E  167 :
#endif  E  168 :
  E  169 :
#endif   E  170 :E
 E  170 :
#include "Timer.h" O   15 :
 //------------------------------------------------------------------------------  G    1 :I6
// File: Timer  G    2 :
//  G    3 :
// Purpose: High speed timer (HST) routines.   G    4 :
//  G    5 :
// Change History:  G    6 :
// Date		Author		Description  G    7 :
//          Lafreniere	Created  G    8 :
//------------------------------------------------------------------------------  G    9 :
#ifndef TIMER_H  G   10 :
#define TIMER_H  G   11 :
  G   12 :
#define TIMER1_TIMEOUT          0     // 1.6uS per tick with div set to 8  G   13 :
#define MS_TO_TICKS(mS) 		((mS * 10000) / 16)	  // 1.6uS per tick  G   14 :
  G   15 :
// max 16-bit number  G   16 :
#define HST_TWO_MS              1250  G   17 :
#define HST_TEN_MS              6250  G   18 :
#define HST_TWENTY_FIVE_MS      15625  G   19 :
#define HST_FIFTY_MS            31250  G   20 :
#define HST_FIVE_HUNDRED_MS		312500	// NOTE: this number exceeds 16-bit timer and must be used with Int32  G   21 :
#define HST_ONE_S				625000	// NOTE: this number exceeds 16-bit timer and must be used with Int32  G   22 :
  G   23 :
typedef int16 HstTimer; //TBD DEBUG  G   24 :
//typedef int32 HstTimer;  G   25 :
              G   26 :
HstTimer HstGetTicks(void) { return get_timer1(); }  G   27 :
BOOLEAN HstTestTimer(HstTimer timer, HstTimer ticks);  G   28 :
BOOLEAN HstTestTimerRetrig(HstTimer *timer, HstTimer ticks);  G   29 :
HstTimer HstElapsedTime(HstTimer timer);  G   30 :
  G   31 :
#endif  G   32 :E
 G   32 :
#include "Util.h" O   16 :
 //------------------------------------------------------------------------------  L    1 :I11
// File: Util  L    2 :
//  L    3 :
// Purpose: Misc utility routines.   L    4 :
//  L    5 :
// Change History:  L    6 :
// Date		Author		Description  L    7 :
//          Lafreniere	Created  L    8 :
//------------------------------------------------------------------------------  L    9 :
#ifndef UTIL_H  L   10 :
#define UTIL_H  L   11 :
  L   12 :
// starting address for the 4-byte EEPOM write protect table  L   13 :
#define EEPROM_WRITE_PROTECT_TABLE_ADDR 	252  L   14 :
  L   15 :
// the logical sector size is arbitrary and has nothing to do with the PIC hardware  L   16 :
#define EEPROM_SECTOR_SIZE 	8  L   17 :
  L   18 :
void ReadEeprom();  L   19 :
void ReadEepromLocal(int8 sector);  L   20 :
void WriteEeprom();  L   21 :
int8 IsEepromSectorWriteProtected(int8 sector);  L   22 :
int32 ReadEepromSectorWriteProtectTable();  L   23 :
void WriteEerpomSectorWriteProtectTable(int32 writeProtectBits);  L   24 :
void init_ports();  L   25 :
void Bus_If_Init(void);  L   26 :
void DecryptBlock(int8 *outbfr, int8 *inbfr);  L   27 :
int8 IsCmdCAN(int8 cmd);  L   28 :
int8 IsCmdLocal(int8 cmd);  L   29 :
int8 IsCmdFBGO(int8 cmd);  L   30 :
int8 IsCmdListen(int8 cmd);  L   31 :
int8 IsCmdNoResponse(int8 cmd);  L   32 :
int8 IsCmdFirstResp(int8 cmd);  L   33 :
int8 IsCmdStandardId(int8 cmd);  L   34 :
int8 IsCmd250kb(int8 cmd);  L   35 :
int8 checksum(int8* pMsg, int8 size);  L   36 :
int8 crc8(int8* buffer, int8 count);  L   37 :
int32 StrToInt32(int8* str);  L   38 :
int8 TraceStr(int8* pMsg, int8 size);  L   39 :
int8 Trace(int8 msg);  L   40 :
  L   41 :
#endif  L   42 :E
 L   42 :
#include "PWM-02.h" O   17 :
 #ifndef PWM_H  Q    1 :I16
#define PWM_H  Q    2 :
  Q    3 :
int8 PWMSend(int16* TxBufferPntr, int8 PWMTxCnt, int8 timeout);  Q    4 :f1614V374V375V376P1614
int8 PWMRecv(int16* RxBufferPntr, int8* RxCntPntr, int8 timeout);  Q    5 :f1590V350V351V352P1590
  Q    6 :
#endif  Q    7 :E
 Q    7 :
#include "VPW-02.h" O   18 :
 #ifndef VPW_H  R    1 :I17
#define VPW_H  R    2 :
  R    3 :
int8 VPWSend(int16* TxBufferPntr, int8 VPWTxCnt, int8 timeout);  R    4 :f1662V426V427V428P1662
int8 VPWRecv(int16* RxBufferPntr, int8* RxCntPntr, int8 timeout);  R    5 :f1641V402V403V404P1641
  R    6 :
#endif  R    7 :E
 R    7 :
#include "CAN18XX8.h" O   19 :
 /*********************************************************************  N    1 :I13
 *              PIC18CXX8 CAN C Library Header File  N    2 :
 *********************************************************************  N    3 :
 * FileName:        CAN18CXX8.h  N    4 :
 * Dependencies:    None  N    5 :
 * Date:            09/06/00  N    6 :
 * Processor:       PIC18CXX8  N    7 :
 * Complier:        MPLAB 5.11.00  N    8 :
 * Company:         Microchip Technology, Inc.  N    9 :
 *  N   10 :
 *  N   11 :
 * Software License Agreement  N   12 :
 *  N   13 :
 * The software supplied herewith by Microchip Technology Incorporated  N   14 :
 * (the Company) for its PICmicro Microcontroller is intended and  N   15 :
 * supplied to you, the Companys customer, for use solely and  N   16 :
 * exclusively on Microchip PICmicro Microcontroller products. The  N   17 :
 * software is owned by the Company and/or its supplier, and is  N   18 :
 * protected under applicable copyright laws. All rights are reserved.  N   19 :
 *  Any use in violation of the foregoing restrictions may subject the  N   20 :
 * user to criminal sanctions under applicable laws, as well as to  N   21 :
 * civil liability for the breach of the terms and conditions of this  N   22 :
 * license.  N   23 :
 *  N   24 :
 * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,  N   25 :
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED  N   26 :
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  N   27 :
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,  N   28 :
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR  N   29 :
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.  N   30 :
 *  N   31 :
 * Author               Date    Comment  N   32 :
 *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  N   33 :
 * Nilesh Rajbharti     9/6/00  Original        (Rev 1.0)  N   34 :
 * Nilesh Rajbharti     12/1/00 Fixed bugs.  N   35 :
 *                              (CANRegsToID, CANReceiveMessage,  N   36 :
 *                               CANSetMask + Added  N   37 :
 *                               CAN_CONFIG_DBL_BUFFER_ON/OFF option)  N   38 :
 * Nilesh Rajbharti     6/8/01  Renamed CAN_CONFIG_DBL_BUFFERED to  N   39 :
 *                              CAN_RX_DBL_BUFFERED  N   40 :
 *  N   41 :
 * Bernie Lafreniere	8/16/03 Start porting driver to run on CCS C with  N   42 :
 *								the PIC18F248 processor.  N   43 :
 *  N   44 :
 *********************************************************************/  N   45 :
#ifndef CAN18XX8_H          // To avoid duplicate inclusion  N   46 :
#define CAN18XX8_H  N   47 :
  N   48 :
#bit RXB0CON_RX0DBEN    = RXB0CON.2	// PIC18XX8 CAN register.bit mapping  N   49 :
#bit RXB0CON_RXFUL      = RXB0CON.7  N   50 :
#bit RXB1CON_RXFUL      = RXB1CON.7  N   51 :
#bit TXB0CON_TXREQ      = TXB0CON.3  N   52 :
  N   53 :
#bit TXB1CON_TXPRI0     = TXB1CON.0  N   54 :
#bit TXB1CON_TXPRI1     = TXB1CON.1  N   55 :
#bit TXB1CON_TXREQ      = TXB1CON.3  N   56 :
#bit TXB1CON_TXERR      = TXB1CON.4  N   57 :
#bit TXB1CON_TXLARB     = TXB1CON.5  N   58 :
#bit TXB1CON_TXABT      = TXB1CON.6  N   59 :
  N   60 :
#bit TXB2CON_TXPRI0     = TXB2CON.0  N   61 :
#bit TXB2CON_TXPRI1     = TXB2CON.1  N   62 :
#bit TXB2CON_TXREQ      = TXB2CON.3  N   63 :
#bit TXB2CON_TXERR      = TXB2CON.4  N   64 :
#bit TXB2CON_TXLARB     = TXB2CON.5  N   65 :
#bit TXB2CON_TXABT      = TXB2CON.6  N   66 :
  N   67 :
#bit BRGCON2_SAM        = BRGCON2.6  N   68 :
#bit BRGCON2_SEG2PHTS   = BRGCON2.7  N   69 :
#bit BRGCON3_WAKFIL     = BRGCON3.6  N   70 :
#bit PIR3_RXB0IF        = PIR3.0  N   71 :
#bit PIR3_RXB1IF        = PIR3.1  N   72 :
#bit PIR3_IRXIF         = PIR3.7  N   73 :
#bit COMSTAT_TXB0       = COMSTAT.5  N   74 :
#bit COMSTAT_TXBP       = COMSTAT.4  N   75 :
#bit COMSTAT_RXBP       = COMSTAT.3  N   76 :
#bit COMSTAT_RX1OVFL    = COMSTAT.6  N   77 :
#bit COMSTAT_RX0OVFL    = COMSTAT.7  N   78 :
#bit RXB0DLC_RTR        = RXB0DLC.6  N   79 :
#bit RXB0SIDL_EXID      = RXB0SIDL.3  N   80 :
#bit CANCON_ABAT        = CANCON.4  N   81 :
  N   82 :
//////////////////////////////////////////////////////////////////////  N   83 :
  N   84 :
/*********************************************************************  N   85 :
 *  N   86 :
 * union CAN_MESSAGE_ID  N   87 :
 *  N   88 :
 * This union provides abstract data type for CAN message id.  N   89 :
 * It is used for both 11-bit and 29-bit message identifiers.  N   90 :
 * There are multiple union members to be able to access individual  N   91 :
 * parts of it.  N   92 :
 *  N   93 :
 ********************************************************************/  N   94 :
 // Parse-out 29-bit or 11-bit (saved in 32-bit number)  N   95 :
typedef union _CAN_MESSAGE_ID  N   96 :
{  N   97 :
    int32 ID;  N   98 :
  N   99 :
    struct  N  100 :
    {  N  101 :
        struct  N  102 :
        {  N  103 :
            int8 SIDL:3;        // SIDL<5:7>  N  104 :
            int8 SIDH:5;        // SIDH<0:4>  N  105 :
        } BYTE1;  N  106 :
        struct  N  107 :
        {  N  108 :
            int8 SIDHU:3;       // SIDH<5:7>  N  109 :
            int8 EIDL_LN:5;     // EIDL<0:4>  N  110 :
        } BYTE2;  N  111 :
        struct  N  112 :
        {  N  113 :
            int8 EIDL_UN:3;     // EIDL<5:7>  N  114 :
            int8 EIDH_LN:5;     // EIDH<0:4>  N  115 :
        } BYTE3;  N  116 :
        struct  N  117 :
        {  N  118 :
            int8 EIDH_UN:3;     // EIDH<5:7>  N  119 :
            int8 EIDHU:2;       // SIDL<0:1>  N  120 :
            int8 PAD:3;			// bcl added name "PAD" to make CCS happy  N  121 :
        } BYTE4;  N  122 :
    } ID_VALS;  N  123 :
  N  124 :
    // This is to allow individual byte access within message id.  N  125 :
    struct  N  126 :
    {  N  127 :
        BYTE BYTE_1;  N  128 :
        BYTE BYTE_2;  N  129 :
        BYTE BYTE_3;  N  130 :
        BYTE BYTE_4;  N  131 :
    } BYTES;  N  132 :
} CAN_MESSAGE_ID;  N  133 :
  N  134 :
//////////////////////////////////////////////////////////////////////  N  135 :
  N  136 :
/*********************************************************************  N  137 :
 *  N  138 :
 * enum CAN_TX_MSG_FLAGS  N  139 :
 *  N  140 :
 * This enumeration values define flags related to transmission of a  N  141 :
 * CAN message.  There could be more than one this flag  N  142 :
 * ANDed together to form multiple flags.  N  143 :
 *  N  144 :
 *********************************************************************/  N  145 :
 typedef enum CAN_TX_MSG_FLAGS  N  146 :
 {  N  147 :
    CAN_TX_PRIORITY_BITS= 0b00000011,  N  148 :
    CAN_TX_PRIORITY_0   = 0b11111100,   // XXXXXX00  N  149 :
    CAN_TX_PRIORITY_1   = 0b11111101,   // XXXXXX01  N  150 :
    CAN_TX_PRIORITY_2   = 0b11111110,   // XXXXXX10  N  151 :
    CAN_TX_PRIORITY_3   = 0b11111111,   // XXXXXX11  N  152 :
  N  153 :
    CAN_TX_FRAME_BIT    = 0b00001000,  N  154 :
    CAN_TX_STD_FRAME    = 0b11111111,   // XXXXX1XX  N  155 :
    CAN_TX_XTD_FRAME    = 0b11110111,   // XXXXX0XX  N  156 :
  N  157 :
    CAN_TX_RTR_BIT      = 0b01000000,  N  158 :
    CAN_TX_NO_RTR_FRAME = 0b11111111,   // X1XXXXXX  N  159 :
    CAN_TX_RTR_FRAME    = 0b10111111    // X0XXXXXX  N  160 :
};  N  161 :
  N  162 :
//////////////////////////////////////////////////////////////////////  N  163 :
  N  164 :
/*********************************************************************  N  165 :
 *  N  166 :
 * enum CAN_RX_MSG_FLAGS  N  167 :
 *  N  168 :
 * These enumeration values define flags related to reception of a CAN  N  169 :
 * message.  There could be more than one these flags  N  170 :
 * ANDed together to form multiple flags.  N  171 :
 * If a particular bit is set, corresponding meaning is TRUE or else  N  172 :
 * it will be FALSE.  N  173 :
 *  N  174 :
 * e.g.  N  175 :
 *      if (MsgFlag & CAN_RX_OVERFLOW)  N  176 :
 *      {  N  177 :
 *          // Receiver overflow has occured.  We have lost previous  N  178 :
 *          // message.  N  179 :
 *          ...  N  180 :
 *      }  N  181 :
 *  N  182 :
 ********************************************************************/  N  183 :
typedef enum CAN_RX_MSG_FLAGS  N  184 :
{  N  185 :
    CAN_RX_FILTER_BITS  = 0b00000111,   // Use this to access filter  N  186 :
                                        // bits  N  187 :
    CAN_RX_FILTER_1     = 0b00000000,  N  188 :
    CAN_RX_FILTER_2     = 0b00000001,  N  189 :
    CAN_RX_FILTER_3     = 0b00000010,  N  190 :
    CAN_RX_FILTER_4     = 0b00000011,  N  191 :
    CAN_RX_FILTER_5     = 0b00000100,  N  192 :
    CAN_RX_FILTER_6     = 0b00000101,  N  193 :
  N  194 :
    CAN_RX_OVERFLOW     = 0b00001000,   // Set if Overflowed else  N  195 :
                                        // cleared  N  196 :
  N  197 :
    CAN_RX_INVALID_MSG  = 0b00010000,   // Set if invalid else  N  198 :
                                        // cleared  N  199 :
  N  200 :
    CAN_RX_XTD_FRAME    = 0b00100000,   // Set if XTD message else  N  201 :
                                        // cleared  N  202 :
  N  203 :
    CAN_RX_RTR_FRAME    = 0b01000000,   // Set if RTR message else  N  204 :
                                        // cleared  N  205 :
  N  206 :
    CAN_RX_DBL_BUFFERED = 0b10000000    // Set if this message was  N  207 :
                                        // hardware double-buffered  N  208 :
};  N  209 :
  N  210 :
//////////////////////////////////////////////////////////////////////  N  211 :
  N  212 :
  N  213 :
/*********************************************************************  N  214 :
 *  N  215 :
 * enum CAN_MASK  N  216 :
 *  N  217 :
 * These enumeration values define mask codes.  Routine CANSetMask()  N  218 :
 * requires this code as one of its arguments.  These enumerations  N  219 :
 * must be used by itself i.e. it cannot be ANDed to form multiple  N  220 :
 * values.  N  221 :
 *  N  222 :
 ********************************************************************/  N  223 :
typedef enum CAN_MASK  N  224 :
{  N  225 :
     CAN_MASK_B1,  N  226 :
     CAN_MASK_B2  N  227 :
};  N  228 :
  N  229 :
//////////////////////////////////////////////////////////////////////  N  230 :
  N  231 :
/*********************************************************************  N  232 :
 *  N  233 :
 * enum CAN_FILTER  N  234 :
 *  N  235 :
 * These enumeration values define filter codes.  Routine CANSetFilter  N  236 :
 * requires this code as one of its arguments.  These enumerations  N  237 :
 * must be used by itself  N  238 :
 * i.e. it cannot be ANDed to form multiple values.  N  239 :
 *  N  240 :
 ********************************************************************/  N  241 :
typedef enum CAN_FILTER  N  242 :
{  N  243 :
    CAN_FILTER_B1_F1,  N  244 :
    CAN_FILTER_B1_F2,  N  245 :
    CAN_FILTER_B2_F1,  N  246 :
    CAN_FILTER_B2_F2,  N  247 :
    CAN_FILTER_B2_F3,  N  248 :
    CAN_FILTER_B2_F4  N  249 :
};  N  250 :
  N  251 :
//////////////////////////////////////////////////////////////////////  N  252 :
  N  253 :
/*********************************************************************  N  254 :
 *  N  255 :
 * enum CAN_OP_MODE  N  256 :
 *  N  257 :
 * This enumeration values define codes related to CAN module  N  258 :
 * operation mode. CANSetOperationMode() routine requires this code.  N  259 :
 * These values must be used by itself  N  260 :
 * i.e. it cannot be ANDed to form * multiple values.  N  261 :
 *  N  262 :
 ********************************************************************/  N  263 :
typedef enum CAN_OP_MODE  N  264 :
{  N  265 :
    CAN_OP_MODE_BITS    = 0b11100000,   // Use this to access opmode  N  266 :
                                        // bits  N  267 :
    CAN_OP_MODE_NORMAL  = 0b00000000,  N  268 :
    CAN_OP_MODE_SLEEP   = 0b00100000,  N  269 :
    CAN_OP_MODE_LOOP    = 0b01000000,  N  270 :
    CAN_OP_MODE_LISTEN  = 0b01100000,  N  271 :
    CAN_OP_MODE_CONFIG  = 0b10000000  N  272 :
};  N  273 :
  N  274 :
//////////////////////////////////////////////////////////////////////  N  275 :
  N  276 :
/*********************************************************************  N  277 :
 *  N  278 :
 * enum CAN_CONFIG_FLAGS  N  279 :
 *  N  280 :
 * These enumeration values define flags related to configuring the CAN  N  281 :
 * module. Routines CANInitialize() and CANSetBaudRate() use these  N  282 :
 * codes. One or more of these values may be ANDed to form multiple  N  283 :
 * flags.  N  284 :
 *  N  285 :
 ********************************************************************/  N  286 :
//typedef enum CAN_CONFIG_FLAGS  N  287 :
//{  N  288 :
#define    CAN_CONFIG_DEFAULT           0b11111111,   // 11111111  N  289 :
  N  290 :
#define    CAN_CONFIG_PHSEG2_PRG_BIT    0b00000001  N  291 :
#define    CAN_CONFIG_PHSEG2_PRG_ON     0b11111111   // XXXXXXX1  N  292 :
#define    CAN_CONFIG_PHSEG2_PRG_OFF    0b11111110   // XXXXXXX0  N  293 :
  N  294 :
#define    CAN_CONFIG_LINE_FILTER_BIT   0b00000010  N  295 :
#define    CAN_CONFIG_LINE_FILTER_ON    0b11111111   // XXXXXX1X  N  296 :
#define    CAN_CONFIG_LINE_FILTER_OFF   0b11111101   // XXXXXX0X  N  297 :
  N  298 :
#define    CAN_CONFIG_SAMPLE_BIT        0b00000100  N  299 :
#define    CAN_CONFIG_SAMPLE_ONCE       0b11111111   // XXXXX1XX  N  300 :
#define    CAN_CONFIG_SAMPLE_THRICE     0b11111011   // XXXXX0XX  N  301 :
  N  302 :
#define    CAN_CONFIG_MSG_TYPE_BIT      0b00001000  N  303 :
#define    CAN_CONFIG_STD_MSG           0b11111111   // XXXX1XXX  N  304 :
#define    CAN_CONFIG_XTD_MSG           0b11110111   // XXXX0XXX  N  305 :
  N  306 :
#define    CAN_CONFIG_DBL_BUFFER_BIT    0b00010000  N  307 :
#define    CAN_CONFIG_DBL_BUFFER_ON     0b11111111   // XXX1XXXX  N  308 :
#define    CAN_CONFIG_DBL_BUFFER_OFF    0b11101111   // XXX0XXXX  N  309 :
  N  310 :
#define    CAN_CONFIG_MSG_BITS          0b01100000  N  311 :
#define    CAN_CONFIG_ALL_MSG           0b11111111   // X11XXXXX  N  312 :
#define    CAN_CONFIG_VALID_XTD_MSG     0b11011111   // X10XXXXX  N  313 :
#define    CAN_CONFIG_VALID_STD_MSG     0b10111111   // X01XXXXX  N  314 :
#define    CAN_CONFIG_ALL_VALID_MSG     0b10011111    // X00XXXXX  N  315 :
//};  N  316 :
  N  317 :
//////////////////////////////////////////////////////////////////////  N  318 :
  N  319 :
/*********************************************************************  N  320 :
 * Function:        void CANInitialize( BYTE SJW,  N  321 :
 *                                      BYTE BRP,  N  322 :
 *                                      BYTE PHSEG1,  N  323 :
 *                                      BYTE PHSEG2,  N  324 :
 *                                      BYTE PROPSEG,  N  325 :
 *                                      BYTE config)  N  326 :
 *  N  327 :
 * PreCondition:    MCU must be in Configuration mode or else these  N  328 :
 *                  values will be ignored.  N  329 :
 *  N  330 :
 * Input:           SJW     - SJW value as defined in 18CXX8 datasheet  N  331 :
 *                              (Must be between 1 thru 4)  N  332 :
 *                  BRP     - BRP value as defined in 18CXX8 datasheet  N  333 :
 *                              (Must be between 1 thru 64)  N  334 :
 *                  PHSEG1  - PHSEG1 value as defined in 18CXX8  N  335 :
 *                            datasheet  N  336 :
 *                              (Must be between 1 thru 8)  N  337 :
 *                  PHSEG2  - PHSEG2 value as defined in 18CXX8  N  338 :
 *                            datasheet  N  339 :
 *                              (Must be between 1 thru 8)  N  340 :
 *                  PROPSEG - PROPSEG value as defined in 18CXX8  N  341 :
 *                            datasheet  N  342 :
 *                              (Must be between 1 thru 8)  N  343 :
 *                  flags   - Value of type enum CAN_CONFIG_FLAGS  N  344 :
 *  N  345 :
 * Output:          CAN bit rate is set.  N  346 :
 *                  All masks registers are set '0'  N  347 :
 *                  to allow all messages.  N  348 :
 *                  Filter registers are set according to flag value.  N  349 :
 *                  If (config & CAN_CONFIG_VALID_XTD_MSG)  N  350 :
 *                      Set all filters to XTD_MSG  N  351 :
 *                  Else if (config & CONFIG_VALID_STD_MSG)  N  352 :
 *                      Set all filters to STD_MSG  N  353 :
 *                  Else  N  354 :
 *                      Set half of the filters to STD while rests to  N  355 :
 *                      XTD_MSG.  N  356 :
 *  N  357 :
 * Side Effects:    All pending transmissions are aborted.  N  358 :
 ********************************************************************/  N  359 :
void CANInitialize(BYTE SJW,  N  360 :
                    BYTE BRP,  N  361 :
                    BYTE PHSEG1,  N  362 :
                    BYTE PHSEG2,  N  363 :
                    BYTE PROPSEG,  N  364 :
                    BYTE config);  N  365 :
  N  366 :
//////////////////////////////////////////////////////////////////////  N  367 :
  N  368 :
  N  369 :
/*********************************************************************  N  370 :
 * Function:        void CANSetOperationMode(CAN_OP_MODE mode)  N  371 :
 *  N  372 :
 * PreCondition:    None  N  373 :
 *  N  374 :
 * Input:           mode    - Operation mode code  N  375 :
 *                            must be of type enum CAN_OP_MODES  N  376 :
 *  N  377 :
 * Output:          MCU is set to requested mode  N  378 :
 *  N  379 :
 * Side Effects:    None  N  380 :
 *  N  381 :
 * Note:            This is a blocking call.  It will not return until  N  382 :
 *                  requested mode is set.  N  383 :
 ********************************************************************/  N  384 :
void CANSetOperationMode(CAN_OP_MODE mode);  N  385 :
  N  386 :
//////////////////////////////////////////////////////////////////////  N  387 :
  N  388 :
  N  389 :
/*********************************************************************  N  390 :
 * Macro:           void CANSetOperationModeNoWait(CAN_OP_MODE mode)  N  391 :
 *  N  392 :
 * PreCondition:    None  N  393 :
 *  N  394 :
 * Input:           mode    - Operation mode code  N  395 :
 *                            must be of type enum CAN_OP_MODES  N  396 :
 *  N  397 :
 * Output:          MCU is set to requested mode  N  398 :
 *  N  399 :
 * Side Effects:    None  N  400 :
 *  N  401 :
 * Note:            This is a non-blocking call.  N  402 :
 *                  It does not verify that  N  403 :
 *                  CAN module is switched to requested mode or not.  N  404 :
 *                  Caller must use CANGetOperationMode() to verify  N  405 :
 *                  correct operation mode before performing mode  N  406 :
 *                  specific operation.  N  407 :
 *  N  408 :
 ********************************************************************/  N  409 :
#define CANSetOperationModeNoWait(mode) (CANCON = mode)  N  410 :
  N  411 :
//////////////////////////////////////////////////////////////////////  N  412 :
  N  413 :
/*********************************************************************  N  414 :
 * Macro:           CAN_OP_MODE CANSetOperationMode()  N  415 :
 *  N  416 :
 * PreCondition:    None  N  417 :
 *  N  418 :
 * Input:           None  N  419 :
 *  N  420 :
 * Output:          Current operational mode of CAN module is returned  N  421 :
 *  N  422 :
 * Side Effects:    None  N  423 :
 *  N  424 :
 ********************************************************************/  N  425 :
#define CANGetOperationMode() (CANCON & CAN_OP_MODE_BITS)  N  426 :
  N  427 :
//////////////////////////////////////////////////////////////////////  N  428 :
  N  429 :
/*********************************************************************  N  430 :
 * Function:        void CANSetBaudRate(BYTE SJW,  N  431 :
 *                                      BYTE BRP,  N  432 :
 *                                      BYTE PHSEG1,  N  433 :
 *                                      BYTE PHSEG2,  N  434 :
 *                                      BYTE PROPSEG,  N  435 :
 *                                      BYTE flags)  N  436 :
 *  N  437 :
 * PreCondition:    MCU must be in Configuration mode or else these  N  438 :
 *                  values will be ignored.  N  439 :
 *  N  440 :
 * Input:           SJW     - SJW value as defined in 18CXX8 datasheet  N  441 :
 *                              (Must be between 1 thru 4)  N  442 :
 *                  BRP     - BRP value as defined in 18CXX8 datasheet  N  443 :
 *                              (Must be between 1 thru 64)  N  444 :
 *                  PHSEG1  - PHSEG1 value as defined in 18CXX8  N  445 :
 *                            datasheet  N  446 :
 *                              (Must be between 1 thru 8)  N  447 :
 *                  PHSEG2  - PHSEG2 value as defined in 18CXX8  N  448 :
 *                            datasheet  N  449 :
 *                              (Must be between 1 thru 8)  N  450 :
 *                  PROPSEG - PROPSEG value as defined in 18CXX8  N  451 :
 *                            datasheet  N  452 :
 *                              (Must be between 1 thru 8)  N  453 :
 *                  flags   - Value of type enum CAN_CONFIG_FLAGS  N  454 :
 *  N  455 :
 * Output:          CAN bit rate is set as per given values.  N  456 :
 *  N  457 :
 * Side Effects:    None  N  458 :
 *  N  459 :
 ********************************************************************/  N  460 :
void CANSetBaudRate (BYTE SJW,  N  461 :
                     BYTE BRP,  N  462 :
                     BYTE PHSEG1,  N  463 :
                     BYTE PHSEG2,  N  464 :
                     BYTE PROPSEG,  N  465 :
                     BYTE flags);  N  466 :
  N  467 :
//////////////////////////////////////////////////////////////////////  N  468 :
  N  469 :
/*********************************************************************  N  470 :
 * Function:        void CANSetMask(enum CAN_MASK code,  N  471 :
 *                                  int32 val,  N  472 :
 *                                  BYTE type)  N  473 :
 *  N  474 :
 * PreCondition:    MCU must be in Configuration mode.  If not, all  N  475 :
 *                  values  N  476 :
 *                  will be ignored.  N  477 :
 *  N  478 :
 * Input:           code    - One of CAN_MASK value  N  479 :
 *                  val     - Actual mask register value.  N  480 :
 *                  type    - Type of message to filter either  N  481 :
 *                            CAN_CONFIG_XTD_MSG or CAN_CONFIG_STD_MSG  N  482 :
 *  N  483 :
 * Output:          Given value is bit adjusted to appropriate buffer  N  484 :
 *                  mask registers.  N  485 :
 *  N  486 :
 * Side Effects:    None  N  487 :
 ********************************************************************/  N  488 :
void CANSetMask (CAN_MASK code,  N  489 :
                int32 val,  N  490 :
                BYTE type);  N  491 :
  N  492 :
//////////////////////////////////////////////////////////////////////  N  493 :
  N  494 :
/*********************************************************************  N  495 :
 * Function:        void CANSetFilter(enum CAN_FILTER code,  N  496 :
 *                                    int32 val,  N  497 :
 *                                    BYTE type)  N  498 :
 *  N  499 :
 * PreCondition:    MCU must be in Configuration mode.  If not, all  N  500 :
 *                  values will be ignored.  N  501 :
 *  N  502 :
 * Input:           code    - One of CAN_FILTER value  N  503 :
 *                  val     - Actual filter register value.  N  504 :
 *                  type    - Type of message to filter either  N  505 :
 *                            CAN_CONFIG_XTD_MSG or CAN_CONFIG_STD_MSG  N  506 :
 *  N  507 :
 * Output:          Given value is bit adjusted to appropriate buffer  N  508 :
 *                  filter registers.  N  509 :
 *  N  510 :
 * Side Effects:    None  N  511 :
 ********************************************************************/  N  512 :
void CANSetFilter ( CAN_FILTER code,  N  513 :
                    int32 val,  N  514 :
                    BYTE type);  N  515 :
  N  516 :
//////////////////////////////////////////////////////////////////////  N  517 :
  N  518 :
/*********************************************************************  N  519 :
 * Function:        BOOL CANSendMessage(int32 id,  N  520 :
 *                                  BYTE *Data,  N  521 :
 *                                  BYTE DataLen,  N  522 :
 *                                  enum CAN_TX_MSG_FLAGS MsgFlags)  N  523 :
 *  N  524 :
 * PreCondition:    None  N  525 :
 *  N  526 :
 * Input:           id          - CAN message identifier.  N  527 :
 *                                Only 11 or 29 bits may be used  N  528 :
 *                                depending on standard or extended  N  529 :
 *                                message type.  N  530 :
 *                  Data        - Data bytes of upto 8 bytes in length  N  531 :
 *                  DataLen     - Data length from 1 thru 8.  N  532 :
 *                  MsgFlags    - One or CAN_TX_MSG_FLAGS values ANDed  N  533 :
 *                                together  N  534 :
 *  N  535 :
 * Output:          If at least one empty transmit buffer is found,  N  536 :
 *                  given message is queued to be transmitted. If none  N  537 :
 *                  found FALSE value is returned.  N  538 :
 *  N  539 :
 * Side Effects:    None  N  540 :
 *  N  541 :
 ********************************************************************/  N  542 :
BOOLEAN CANSendMessage (int32 id,  N  543 :
                     BYTE *Data,  N  544 :
                     BYTE DataLen,  N  545 :
                     CAN_TX_MSG_FLAGS MsgFlags);  N  546 :
  N  547 :
//////////////////////////////////////////////////////////////////////  N  548 :
  N  549 :
/*********************************************************************  N  550 :
 * Function:        BOOL CANReceiveMessage(int32 *id,  N  551 :
 *                                  BYTE *Data,  N  552 :
 *                                  BYTE *DataLen,  N  553 :
 *                                  enum CAN_RX_MSG_FLAGS *MsgFlags)  N  554 :
 *  N  555 :
 * PreCondition:    None  N  556 :
 *  N  557 :
 * Input:           None  N  558 :
 *  N  559 :
 * Output:          id          - CAN message identifier.  N  560 :
 *                  Data        - Data bytes of upto 8 bytes in length  N  561 :
 *                  DataLen     - Data length from 1 thru 8.  N  562 :
 *                  MsgFlags    - One or CAN_RX_MSG_FLAGS values ANDed  N  563 :
 *                                together  N  564 :
 *  N  565 :
 * Output:          If at least one full receive buffer is found,  N  566 :
 *                  it is extrated and returned. If none found FALSE  N  567 :
 *                  value is returned.  N  568 :
 *  N  569 :
 * Side Effects:    None  N  570 :
 *  N  571 :
 ********************************************************************/  N  572 :
BOOLEAN CANReceiveMessage(int32* id,  N  573 :
                        BYTE *Data,  N  574 :
                        BYTE *DataLen,  N  575 :
                        CAN_RX_MSG_FLAGS *MsgFlags);  N  576 :
  N  577 :
//////////////////////////////////////////////////////////////////////  N  578 :
  N  579 :
/*********************************************************************  N  580 :
 * Macro:           BYTE CANGetTxErrorCount()  N  581 :
 *  N  582 :
 * PreCondition:    None  N  583 :
 *  N  584 :
 * Input:           None  N  585 :
 *  N  586 :
 * Output:          Current transmit error count as defined by  N  587 :
 *                  CAN specifications.  N  588 :
 *  N  589 :
 * Side Effects:    None  N  590 :
 *  N  591 :
 ********************************************************************/  N  592 :
#define CANGetTxErrorCount()    (TXERRCNT)  N  593 :
  N  594 :
//////////////////////////////////////////////////////////////////////  N  595 :
  N  596 :
/*********************************************************************  N  597 :
 * Macro:           BYTE CANGetRxErrorCount()  N  598 :
 *  N  599 :
 * PreCondition:    None  N  600 :
 *  N  601 :
 * Input:           None  N  602 :
 *  N  603 :
 * Output:          Current receive error count as defined by  N  604 :
 *                  CAN specifications.  N  605 :
 *  N  606 :
 * Side Effects:    None  N  607 :
 *  N  608 :
 ********************************************************************/  N  609 :
#define CANGetRxErrorCount()    (RXERRCNT)  N  610 :
  N  611 :
//////////////////////////////////////////////////////////////////////  N  612 :
  N  613 :
/*********************************************************************  N  614 :
 * Macro:           BOOL CANIsBusOff()  N  615 :
 *  N  616 :
 * PreCondition:    None  N  617 :
 *  N  618 :
 * Input:           None  N  619 :
 *  N  620 :
 * Output:          TRUE if CAN Module is off due to excessive error  N  621 :
 *                  FALSE is it is not off.  N  622 :
 *  N  623 :
 * Side Effects:    None  N  624 :
 *  N  625 :
 ********************************************************************/  N  626 :
#define CANIsBusOff()           (COMSTAT_TXB0)  N  627 :
  N  628 :
//////////////////////////////////////////////////////////////////////  N  629 :
  N  630 :
/*********************************************************************  N  631 :
 * Macro:           BOOL CANIsTxPassive()  N  632 :
 *  N  633 :
 * PreCondition:    None  N  634 :
 *  N  635 :
 * Input:           None  N  636 :
 *  N  637 :
 * Output:          TRUE if CAN transmit module is error passive as  N  638 :
 *                  defined by CAN specifications.  N  639 :
 *  N  640 :
 * Side Effects:    None  N  641 :
 *  N  642 :
 ********************************************************************/  N  643 :
#define CANIsTxPassive()        (COMSTAT_TXBP)  N  644 :
  N  645 :
//////////////////////////////////////////////////////////////////////  N  646 :
  N  647 :
/*********************************************************************  N  648 :
 * Macro:           BYTE CANIsRxPassive()  N  649 :
 *  N  650 :
 * PreCondition:    None  N  651 :
 *  N  652 :
 * Input:           None  N  653 :
 *  N  654 :
 * Output:          TRUE if CAN receive module is error active as  N  655 :
 *                  defined by CAN specifications.  N  656 :
 *  N  657 :
 * Side Effects:    None  N  658 :
 *  N  659 :
 ********************************************************************/  N  660 :
#define CANIsRxPassive()        (COMSTAT_RXBP)  N  661 :
  N  662 :
//////////////////////////////////////////////////////////////////////  N  663 :
  N  664 :
/*********************************************************************  N  665 :
 * Macro:           void CANAbortAll()  N  666 :
 *  N  667 :
 * PreCondition:    None  N  668 :
 *  N  669 :
 * Input:           None  N  670 :
 *  N  671 :
 * Output:          None  N  672 :
 *  N  673 :
 * Side Effects:    None  N  674 :
 *  N  675 :
 ********************************************************************/  N  676 :
#define CANAbortAll()           (CANCON_ABAT = 1)  N  677 :
  N  678 :
//////////////////////////////////////////////////////////////////////  N  679 :
  N  680 :
/*********************************************************************  N  681 :
 * Macro:           BOOL  CANIsRxReady()  N  682 :
 *  N  683 :
 * PreCondition:    None  N  684 :
 *  N  685 :
 * Input:           None  N  686 :
 *  N  687 :
 * Output:          TRUE if at least one of the CAN receive buffer is  N  688 :
 *                  empty FALSE if none receive buffers are empty.  N  689 :
 *  N  690 :
 * Side Effects:    None  N  691 :
 *  N  692 :
 ********************************************************************/  N  693 :
#define CANIsRxReady()          (RXB0CON_RXFUL || RXB1CON_RXFUL)  N  694 :
  N  695 :
//////////////////////////////////////////////////////////////////////  N  696 :
  N  697 :
/*********************************************************************  N  698 :
 * Macro:           BOOL CANIsTxReady()  N  699 :
 *  N  700 :
 * PreCondition:    None  N  701 :
 *  N  702 :
 * Input:           None  N  703 :
 *  N  704 :
 * Output:          TRUE if at least one CAN transmit buffer is empty  N  705 :
 *                  FALSE if all CAN transmit buffers are full  N  706 :
 *  N  707 :
 * Side Effects:    None  N  708 :
 *  N  709 :
 ********************************************************************/  N  710 :
#define CANIsTxReady()          (!TXB0CON_TXREQ || \  N  711 :
                                 !TXB1CON_TXREQ || \  N  712 :
                                 !TXB2CON_TXREQ )  N  713 :
  N  714 :
#endif      // CAN18XX8_H  N  715 :
  N  716 :E
 N  716 :
#include "CAN.h" O   20 :
 //------------------------------------------------------------------------------  S    1 :I18
// File: CAN  S    2 :
//  S    3 :
// Purpose: CAN communication and parsing routines.   S    4 :
//  S    5 :
// Change History:  S    6 :
// Date		Author		Description  S    7 :
//          Lafreniere	Created  S    8 :
//------------------------------------------------------------------------------  S    9 :
#ifndef CAN_H  S   10 :
#define CAN_H  S   11 :
  S   12 :
void VehSendCAN();  S   13 :f1853P1853
void VehRecvCAN();  S   14 :f1854P1854
void CanEmptyRxBuffer();  S   15 :f1855P1855
void CanSetMaskFilter();  S   16 :f1856P1856
void CanSetP2CanTimeout();  S   17 :f1857P1857
void CanDisable();  S   18 :f1858P1858
  S   19 :
#endif S   20 :E
  O   21 :
//#use rs232(baud=9600,xmit=PIN_B7,rcv=PIN_B5,parity=n,bits=8,stream=ISO_K_LINE_STREAM)  // laptop test only  O   22 :
#use rs232(baud=10400,xmit=PIN_B6,rcv=PIN_B5,invert,parity=n,bits=8,stream=ISO_K_LINE_STREAM)  O   23 :V619
#use rs232(baud=9600,xmit=PIN_B6,rcv=PIN_B5,invert,parity=n,bits=8,stream=ISO_K_9600_LINE_STREAM)  O   24 :V624
#use rs232(baud=10400,xmit=PIN_B7,invert,parity=n,bits=8,stream=ISO_L_LINE_STREAM)  O   25 :V628
#use rs232(baud=9600,xmit=PIN_B7,invert,parity=n,bits=8,stream=ISO_L_9600_LINE_STREAM)  O   26 :V632
  O   27 :
void VehInitISO(int8 addr);  O   28 :f1877V635P1877
void VehSendISO();  O   29 :f1879P1879
void VehRecvISO();  O   30 :f1880P1880
void VehSendJ1850(int8 type);  O   31 :f1881V639P1881
void VehRecvJ1850(int8 type);  O   32 :f1882V641P1882
void CheckSendRecvErr(int8 err);  O   33 :f1883V643P1883
void CheckCRC(int8* msgSizes);  O   34 :f1885V645P1885
void VehSend5BPS(int8 byte);  O   35 :f1887V647P1887
void VehFastInit();  O   36 :f1889P1889
void VehReadBatteryVoltage();  O   37 :f1890P1890
void VehSetLLineXmitEnable();  O   38 :f1891P1891
void VehSetIsoChecksumEnable();  O   39 :f1892P1892
void VehSetIso9600BaudEnable();  O   40 :f1893P1893
void VehSetIso5msByteDelayEnable();  O   41 :f1894P1894
int8 timed_getc(int8* timedOut, int16 timeout);  O   42 :f1895V655V656P1895
void VehSendKLine(int8 b);  O   43 :f1897V658P1897
void VehSendLLine(int8 b);  O   44 :f1899V660P1899
  O   45 :
//------------------------------------------------------------------------------  O   46 :
// Function Name: VehSendRecv  O   47 :
// Description: Send host query and receive vehicle response.   O   48 :
// Parameters:   O   49 :
// Output Parameters:  O   50 :
// Return Values:   O   51 :
//------------------------------------------------------------------------------  O   52 :
void VehSendRecv()  O   53 :f1849
{  O   54 :{535
    gVehicleBufCnt = 0;  O   55 :
  O   56 :
	// turn off CAN module if current command is not a CAN command  O   57 :
	if (CANGetOperationMode() != CAN_OP_MODE_SLEEP)  O   58 :
	{  O   59 :
		if (!IsCmdCAN(gCurrentCmd))  O   60 :{539
			CanDisable();  O   61 :
	}  O   62 :}542
  O   63 :
    if (IsCmdFirstResp(gCurrentCmd))  O   64 :
        gFlags.firstResp = TRUE;  O   65 :
    else  O   66 :
        gFlags.firstResp = FALSE;  O   67 :
  O   68 :
    // send message to vehicle based on host command type  O   69 :
    if (gCurrentCmd == CMD_VPW ||  O   70 :
        gCurrentCmd == CMD_VPW_1ST_RESPONSE)  O   71 :
    {  O   72 :
        gFlags.comType = MODE_VPW;  O   73 :{550
        VehSendJ1850(MODE_VPW);  O   74 :
        if (gError == ERR_NONE)  O   75 :
            VehRecvJ1850(MODE_VPW);  O   76 :
    }  O   77 :}553
    else if (gCurrentCmd == CMD_PWM ||  O   78 :
        gCurrentCmd == CMD_PWM_WITH_IFR ||  O   79 :
        gCurrentCmd == CMD_PWM_1ST_RESPONSE)  O   80 :
    {  O   81 :
        gFlags.comType = MODE_PWM;  O   82 :{561
        VehSendJ1850(MODE_PWM);  O   83 :
        if (gError == ERR_NONE)  O   84 :
            VehRecvJ1850(MODE_PWM);  O   85 :
    }  O   86 :}564
    else if (gCurrentCmd == CMD_ISO_WITH_5_BAUD ||  O   87 :
        gCurrentCmd == CMD_KWP_WITH_5_BAUD)  O   88 :
    {  O   89 :
        // if ISO, use 0x33 for 5BPS addr, otherwise use target addr. ISO 14230  O   90 :
        // says use 0x33 also, but for future expansion get value from target addr  O   91 :
        if (gCurrentCmd == CMD_ISO_WITH_5_BAUD)  O   92 :{570
        {  O   93 :
            gFlags.comType = MODE_ISO;  O   94 :{573
            VehInitISO(0x33);  O   95 :
        }  O   96 :}574
        else  O   97 :
        {  O   98 :
            gFlags.comType = MODE_KWP;  O   99 :{576
            VehInitISO(gHostBuf[IDX_HOST_START_DATA+1]);  O  100 :
        }  O  101 :}577
  O  102 :
        if (gError == ERR_NONE)  O  103 :
        {  O  104 :
            VehSendISO();  O  105 :{580
            VehRecvISO();  O  106 :
        }  O  107 :}581
    }  O  108 :}582
    else if (gCurrentCmd == CMD_ISO ||  O  109 :
        gCurrentCmd == CMD_ISO_1ST_RESPONSE ||  O  110 :
        gCurrentCmd == CMD_KWP ||  O  111 :
        gCurrentCmd == CMD_KWP_1ST_RESPONSE ||  O  112 :
		gCurrentCmd == CMD_ISO_NO_RESPONSE)  O  113 :
    {  O  114 :
        if (gCurrentCmd == CMD_ISO ||  O  115 :{594
            gCurrentCmd == CMD_ISO_1ST_RESPONSE)  O  116 :
            gFlags.comType = MODE_ISO;  O  117 :
        else  O  118 :
            gFlags.comType = MODE_KWP;  O  119 :
        VehSendISO();  O  120 :
		if (gCurrentCmd != CMD_ISO_NO_RESPONSE)  O  121 :
        	VehRecvISO();  O  122 :
    }  O  123 :}602
    else if (gCurrentCmd == CMD_KWP_FAST_INIT ||  O  124 :
			 gCurrentCmd == CMD_KWP_FAST_INIT_9600)  O  125 :
    {  O  126 :
        gFlags.comType = MODE_KWP;  O  127 :{608
        VehFastInit();  O  128 :
        VehSendISO();  O  129 :
        VehRecvISO();  O  130 :
    }  O  131 :}609
    else if (IsCmdCAN(gCurrentCmd))  O  132 :
    {  O  133 :
		// disable CAN RX interrupts while Send/Recv on CAN  O  134 :
		disable_interrupts(INT_CANRX1);  O  135 :{613
		disable_interrupts(INT_CANRX0);  O  136 :
        gFlags.comType = MODE_CAN;  O  137 :
        VehSendCAN();  O  138 :
        if (gError == ERR_NONE && IsCmdNoResponse(gCurrentCmd) == 0)  O  139 :
		    VehRecvCAN();  O  140 :
  O  141 :
		enable_interrupts(INT_CANRX1);  O  142 :
		enable_interrupts(INT_CANRX0);  O  143 :
	}  O  144 :}620
	else if (gCurrentCmd == CMD_CAN_SET_STD_MASK_FILTER ||  O  145 :
			 gCurrentCmd == CMD_CAN_SET_XTD_MASK_FILTER)  O  146 :
		CanSetMaskFilter();  O  147 :
	else if (gCurrentCmd == CMD_CAN_SET_P2_CAN_TIMEOUT)  O  148 :
		CanSetP2CanTimeout();  O  149 :
	else if (gCurrentCmd == CMD_READ_BATTERY_VOLTAGE)  O  150 :
		VehReadBatteryVoltage();  O  151 :
	else if (gCurrentCmd == CMD_ISO_CHECKSUM_ENABLE)  O  152 :
		VehSetIsoChecksumEnable();  O  153 :
	else if (gCurrentCmd == CMD_ISO_5MS_BYTE_DELAY_ENABLE)  O  154 :
		VehSetIso5msByteDelayEnable();  O  155 :
	else if (gCurrentCmd == CMD_ISO_ENABLE_L_LINE_XMIT)  O  156 :
		VehSetLLineXmitEnable();  O  157 :
	else if (gCurrentCmd == CMD_ISO_SET_9600_BAUD)  O  158 :
		VehSetIso9600BaudEnable();  O  159 :
	else if (gCurrentCmd == CMD_READ_EEPROM)  O  160 :
		ReadEeprom();  O  161 :
	else if (gCurrentCmd == CMD_WRITE_EEPROM)  O  162 :
		WriteEeprom();  O  163 :
    else if (gCurrentCmd == CMD_UNLOCK_ADAPTER)  O  164 :
        gFlags.adapterLocked = FALSE;  O  165 :
    else  O  166 :
        gError = ERR_NOT_IMPLEMENTED;  O  167 :
}  O  168 :}654
  O  169 :
//------------------------------------------------------------------------------  O  170 :
// Function Name: VehSendISO  O  171 :
// Description: Send a query using ISO.  O  172 :
// Parameters:   O  173 :
// Output Parameters:  O  174 :
// Return Values:   O  175 :
//------------------------------------------------------------------------------  O  176 :
void VehSendISO()  O  177 :f1879
{  O  178 :{655
	int8 i;  O  179 :V661
  O  180 :
    // send the data out the ISO RS-232 port  O  181 :
    for (i=0; i<gHostBuf[IDX_HOST_BYTE_COUNT]; i++)  O  182 :
    {  O  183 :
		VehSendKLine(gHostBuf[i+3]);  O  184 :{663
		VehSendLLine(gHostBuf[i+3]);  O  185 :
		if (gFlags.enableIso5msByteDelay == TRUE)  O  186 :
	        delay_ms(5);   // satisfy P4 timing per ISO 9141 (spec says 5mS)  O  187 :
    }  O  188 :}668
  O  189 :
     O  190 :
	if (gFlags.enableIsoChecksum == TRUE)  O  191 :
	{   O  192 :
		// calc and send message checksum  O  193 :
    	i = checksum(&gHostBuf[3], gHostBuf[IDX_HOST_BYTE_COUNT]);  O  194 :{673
		VehSendKLine(i);  O  195 :
		VehSendLLine(i);  O  196 :
	}  O  197 :}674
}  O  198 :}675
  O  199 :
//------------------------------------------------------------------------------  O  200 :
// Function Name: VehSendKLine  O  201 :
// Description: Send 1 byte out the ISO K line.  O  202 :
// Parameters:   O  203 :
// Output Parameters:  O  204 :
// Return Values:   O  205 :
//------------------------------------------------------------------------------  O  206 :
void VehSendKLine(int8 b)  O  207 :f1897V658
{  O  208 :{676
	if (gFlags.enableIso9600Baud == TRUE)  O  209 :
		fputc(b, ISO_K_9600_LINE_STREAM);  O  210 :
	else  O  211 :
	    fputc(b, ISO_K_LINE_STREAM);  O  212 :
}  O  213 :}683
  O  214 :
//------------------------------------------------------------------------------  O  215 :
// Function Name: VehSendLLine  O  216 :
// Description: Send 1 byte out the ISO L line.  O  217 :
// Parameters:   O  218 :
// Output Parameters:  O  219 :
// Return Values:   O  220 :
//------------------------------------------------------------------------------  O  221 :
void VehSendLLine(int8 b)  O  222 :f1899V660
{  O  223 :{684
	if (gFlags.enableLLineXmit == TRUE)  O  224 :
	{  O  225 :
		if (gFlags.enableIso9600Baud == TRUE)  O  226 :{690
			fputc(b, ISO_L_9600_LINE_STREAM);  O  227 :
		else  O  228 :
			fputc(b, ISO_L_LINE_STREAM);  O  229 :
	}  O  230 :}696
}  O  231 :}697
  O  232 :
//------------------------------------------------------------------------------  O  233 :
// Function Name: VehRecvISO  O  234 :
// Description: Receive one or more messages using ISO.  O  235 :
// Parameters:   O  236 :
// Output Parameters:  O  237 :
// Return Values:   O  238 :
//------------------------------------------------------------------------------  O  239 :
void VehRecvISO()  O  240 :f1880
{  O  241 :{698
    int8 charTimeout;  O  242 :V662
    int8 cnt;     O  243 :V663
    HstTimer recvTimer;  O  244 :V664
    int8 msgSize[VEHICLE_MAX_MSGS];  O  245 :V665
  O  246 :
    recvTimer = HstGetTicks();  O  247 :
  O  248 :
    // get all ISO messages. 50mS of no data terminates the receive  O  249 :
    do   O  250 :
    {  O  251 :
        // is there a char coming in the RS-232 port?? O  252 :
        if (kbhit())  O  253 :{703
        {  O  254 :
            // get one entire ISO OBD II message. once first char arrives,   O  255 :
            // each char will be max 20mS apart  O  256 :
            for (cnt=0; cnt<VEHICLE_MSG_SIZE; cnt++)  O  257 :{706
            {  O  258 :
                gVehicleBuf[gVehicleBufCnt][cnt] = timed_getc(&charTimeout, 2000);  O  259 :{713V667V668
                if (charTimeout)  O  260 :
                    break;  O  261 :
            }  O  262 :}722
  O  263 :
            // if no chars arrived and not a single buffer filled  O  264 :
            if (cnt == 0 && gVehicleBufCnt == 0)  O  265 :
            {  O  266 :
                gError = ERR_ISO_NO_RESPONSE;  O  267 :{727
                return;  O  268 :
            }  O  269 :}728
  O  270 :
            // Message filter: if message is not a response for scan tool, ignore it.   O  271 :
            // Mode byte bit 6 = 0 are requests, bit 6 = 1 are responses  O  272 :
			// This filter is not necessary, and could interfere with KWP fast init messages  O  273 :
            //if (gVehicleBuf[gVehicleBufCnt][3] != (gHostBuf[6] | 0x40))  O  274 :
            //    continue;  O  275 :
  O  276 :
            // successfully obtained a message (checksum not checked yet)  O  277 :
            msgSize[gVehicleBufCnt] = cnt;  O  278 :
            if (++gVehicleBufCnt >= VEHICLE_MAX_MSGS)  O  279 :
                break;  O  280 :
  O  281 :
            // if host only wants one response message  O  282 :
            if (gFlags.firstResp)  O  283 :
                break;  O  284 :
  O  285 :
            // reset timer for next message  O  286 :
            recvTimer = HstGetTicks();  O  287 :
        }  O  288 :}733
    } while (!HstTestTimer(recvTimer, HST_FIFTY_MS));  O  289 :}734
  O  290 :
    if (gVehicleBufCnt == 0)  O  291 :
    {  O  292 :
        gError = ERR_ISO_NO_RESPONSE;  O  293 :{739
        return;  O  294 :
    }  O  295 :}740
  O  296 :
	if (gFlags.enableIsoChecksum == TRUE)  O  297 :
	{  O  298 :
		// error check each received message using checksum  O  299 :
    	for (cnt=0; cnt<gVehicleBufCnt; cnt++)  O  300 :{745
	    {         O  301 :
    	    // does received checksum match what was sent??         O  302 :
        	if (gVehicleBuf[cnt][msgSize[cnt]-1] !=   O  303 :{752
	            checksum(&gVehicleBuf[cnt][0], msgSize[cnt]-1))  O  304 :
    	    {  O  305 :
	            gError = ERR_ISO_BAD_CHECKSUM;  O  306 :{755
    	        return;  O  307 :
	        }  O  308 :}756
	    }  O  309 :}757
	}  O  310 :}758
}  O  311 :}759
  O  312 :
//------------------------------------------------------------------------------  O  313 :
// Function Name: VehInitISO  O  314 :
// Description: Performs the ISO initialization sequence.   O  315 :
// Parameters: addr - 5BPS ISO initialization address.   O  316 :
// Output Parameters:  O  317 :
// Return Values:   O  318 :
//------------------------------------------------------------------------------  O  319 :
void VehInitISO(int8 addr)  O  320 :f1877V635
{  O  321 :{760
    int8 b, i, timeout;	  O  322 :V669V670V671
  O  323 :
    VehSend5BPS(addr);  O  324 :
	gErrorExtraData1 = addr;  O  325 :
  O  326 :
    // get sychronization byte  O  327 :
    b = timed_getc(&timeout, 30000);  O  328 :
	if (timeout == TRUE)  O  329 :
	{  O  330 :
		gError = ERR_ISO_SYNC_BYTE_NOT_RECEIVED;  O  331 :{764
		return;  O  332 :
	}    O  333 :}765
    if (b != 0x55)    O  334 :
    {  O  335 :
        gError = ERR_ISO_NO_SYNC;  O  336 :{768
		gErrorExtraData2 = b;  O  337 :
        return;  O  338 :
    }  O  339 :}769
  O  340 :
    // get two keywords bytes (allow any key bytes)  O  341 :
    for (i=0; i<2; i++)  O  342 :
    {  O  343 :
        b = timed_getc(&timeout, 2000);  O  344 :{776
        if (timeout)  O  345 :
        {  O  346 :
            gError = ERR_ISO_NO_KEYBYTE;      O  347 :{779
            return;  O  348 :
        }  O  349 :}780
    }  O  350 :}781
  O  351 :
    delay_ms(35);  // satisfy W4 per ISO 9141		  O  352 :
  O  353 :
    // send inv second keyword  O  354 :
	VehSendKLine(~b);  O  355 :
	gErrorExtraData2 = b;  O  356 :
  O  357 :
    // get address  O  358 :
    b = timed_getc(&timeout, 5000);  O  359 :
	if (timeout == TRUE)  O  360 :
	{  O  361 :
		gError = ERR_ISO_INV_ADDR_NOT_RECEIVED;  O  362 :{784
		return;  O  363 :
	}        O  364 :}785
    if (b != ~addr)         O  365 :
    {  O  366 :
        gError = ERR_ISO_INCORRECT_INV_ADDR;  O  367 :{788
		gErrorExtraData2 = b;  O  368 :
        return;  O  369 :
    }  O  370 :}789
  O  371 :
    delay_ms(60);   // satisfy P3 timing per ISO 9141 (55ms really, don't shave too close)  O  372 :
}  O  373 :}790
  O  374 :
//------------------------------------------------------------------------------  O  375 :
// Function Name: VehSendJ1850  O  376 :
// Description: Send a message using J1850.   O  377 :
// Parameters: type - VPW or PWM.   O  378 :
// Output Parameters:  O  379 :
// Return Values:   O  380 :
//------------------------------------------------------------------------------  O  381 :
void VehSendJ1850(int8 type)  O  382 :f1881V639
{  O  383 :{791
    int8 err;  O  384 :V672
      O  385 :
    // tack on the CRC to end of message  O  386 :
    gHostBuf[IDX_HOST_START_DATA + gHostBuf[IDX_HOST_BYTE_COUNT]] =  O  387 :
        crc8(&gHostBuf[IDX_HOST_START_DATA], gHostBuf[IDX_HOST_BYTE_COUNT]);  O  388 :
  O  389 :
    // send J1850 message to vehicle (max 100mS timeout to get on bus)  O  390 :
    if (type == MODE_VPW)  O  391 :
        err = VPWSend(&gHostBuf[IDX_HOST_START_DATA], gHostBuf[IDX_HOST_BYTE_COUNT]+1, 50);  O  392 :
    else    O  393 :
        err = PWMSend(&gHostBuf[IDX_HOST_START_DATA], gHostBuf[IDX_HOST_BYTE_COUNT]+1, 50);  O  394 :
          O  395 :
    CheckSendRecvErr(err);  O  396 :
}  O  397 :}796
  O  398 :
//------------------------------------------------------------------------------  O  399 :
// Function Name: VehRecvJ1850  O  400 :
// Description: Recv a message using J1850. If 1st response, this routine should   O  401 :
//  exit on the first message. If not 1st response, this routine should exit  O  402 :
//  after VEHICLE_MAX_MSGS received or a recv timeout occurs.    O  403 :
//  Note: The VPWRecv and PWMRecv funcs must pass in a buffer located in bank 0.   O  404 :
// Parameters: type - VPW or PWM.   O  405 :
// Output Parameters:  O  406 :
// Return Values:   O  407 :
//------------------------------------------------------------------------------  O  408 :
void VehRecvJ1850(int8 type)  O  409 :f1882V641
{  O  410 :{797
    int8 cpyCnt, err, size;  O  411 :V673V674V675
    int8 msgSizes[VEHICLE_MAX_MSGS];  O  412 :V676
    int32 totalRecvTimeout;  O  413 :V677
    int16 recvTimeout;  O  414 :V678
      O  415 :
    totalRecvTimeout = 0;  O  416 :
    recvTimeout = HstGetTicks();  O  417 :
  O  418 :
    gVehicleBufCnt = 0;  O  419 :
    while (1)  O  420 :
    {  O  421 :
        // get message from vehicle. Per J2190 if no response in 100mS, then timeout  O  422 :
        if (type == MODE_VPW)  O  423 :{801
            err = VPWRecv(&gVehicleBuf[gVehicleBufCnt][0], &size, 50);  // 50 * 2mS = 100mS timeout  O  424 :
        else  O  425 :
            err = PWMRecv(&gVehicleBuf[gVehicleBufCnt][0], &size, 50);  O  426 :
              O  427 :
        // has 150mS passed since VPWRecv/PWMRecv call?? O  428 :
		// each msg 100mS appart is the spec, but some vehicles take longer. This check allows for more waiting time.  O  429 :
        totalRecvTimeout += (int32)HstElapsedTime(recvTimeout);  O  430 :
        if (totalRecvTimeout > 93750)      // 150mS in 1.6uS ticks.   O  431 :
        {  O  432 :
            gError = ERR_J1850_NO_RESPONSE;  O  433 :{807
            break;  O  434 :
        }  O  435 :}808
        recvTimeout = HstGetTicks();  O  436 :
          O  437 :
        // if no bus activity (i.e. no response) then try again  O  438 :
        if (bit_test(err, 5))  O  439 :
            continue;  O  440 :
  O  441 :
        CheckSendRecvErr(err);  O  442 :
        if (gError)  O  443 :
            break;  O  444 :
              O  445 :
        // Message filter: if message is not a response for scan tool, ignore it.   O  446 :
        // Mode byte bit 6 = 0 are requests, bit 6 = 1 are responses  O  447 :
        if (gVehicleBuf[gVehicleBufCnt][3] != (gHostBuf[6] | 0x40))  O  448 :
            continue;  O  449 :
          O  450 :
        // successfully obtained a message (CRC not checked yet)  O  451 :
        msgSizes[gVehicleBufCnt] = size;  O  452 :
  O  453 :
		// valid msg for scan tool received, so reset total timeout. Each message arriving can be 100mS appart.  O  454 :
    	totalRecvTimeout = 0;  O  455 :
	  O  456 :
        if (++gVehicleBufCnt >= VEHICLE_MAX_MSGS)  O  457 :
            break;  O  458 :
  O  459 :
        // if host wanted only 1 response, then break early  O  460 :
        if (gFlags.firstResp)  O  461 :
            break;  O  462 :
    }  O  463 :}819
  O  464 :
    // if vehicle obtained at least 1 message then timed out, that is okay  O  465 :
    if (gVehicleBufCnt && gError == ERR_J1850_NO_RESPONSE)  O  466 :
        gError = ERR_NONE;  O  467 :
  O  468 :
    // check the CRC of the incoming messages  O  469 :
    CheckCRC(msgSizes);	  O  470 :
}  O  471 :}824
  O  472 :
//------------------------------------------------------------------------------  O  473 :
// Function Name: CheckSendRecvErr  O  474 :
// Description: Test for VPW and PWM send/recv errors.   O  475 :
// Parameters: err - error byte returned from either PWMSend, PWMRecv, VPWSend,  O  476 :
//  VPWRecv.  O  477 :
//  Sets the global error byte to error is detected.  O  478 :
// Output Parameters:  O  479 :
// Return Values:   O  480 :
//------------------------------------------------------------------------------  O  481 :
void CheckSendRecvErr(int8 err)  O  482 :f1883V643
{  O  483 :{825
    // test for recv errors  O  484 :
    if (bit_test(err, 1))  O  485 :
        gError = ERR_J1850_FRAMING_ERROR;  O  486 :
    else if (bit_test(err, 5))  O  487 :
        gError = ERR_J1850_NO_RESPONSE;  O  488 :
    else if (bit_test(err, 4))  O  489 :
        gError = ERR_J1850_MSG_OVERFLOW;  O  490 :
}  O  491 :}835
  O  492 :
//------------------------------------------------------------------------------  O  493 :
// Function Name: CheckCRC  O  494 :
// Description: Check J1850 CRC on incoming messages. Sets global error flag  O  495 :
//  if error found.    O  496 :
// Parameters: msgSize - an array of message sizes. Array can't exceed   O  497 :
//  VEHICLE_MAX_MSGS.  O  498 :
// Output Parameters:  O  499 :
// Return Values:   O  500 :
//-----------------------------------------------------------------------------  O  501 :
void CheckCRC(int8* msgSizes)  O  502 :f1885V645
{  O  503 :{836
    int8 cnt;  O  504 :V679
      O  505 :
    // error check each received message using checksum  O  506 :
    for (cnt=0; cnt<gVehicleBufCnt; cnt++)  O  507 :
    {         O  508 :
        // does received checksum match what was sent??         O  509 :
        if (gVehicleBuf[cnt][msgSizes[cnt]-1] !=   O  510 :{844
            crc8(&gVehicleBuf[cnt][0], msgSizes[cnt]-1))  O  511 :
        {  O  512 :
            gError = ERR_J1850_BAD_CRC;  O  513 :{847
            return;  O  514 :
        }  O  515 :}848
    }  O  516 :}849
}  O  517 :}850
  O  518 :
//------------------------------------------------------------------------------  O  519 :
// Function Name: VehSend5BPS  O  520 :
// Description: Sends one address byte out on the ISO K and L lines at at rate  O  521 :
//  of 5 BPS.  O  522 :
//  NOTE: Logic values are inverted (i.e. 1 = low and 0 = high) by the scan tool  O  523 :
//  hardaware.  O  524 :
// Parameters: byte - target address byte to send.  O  525 :
// Output Parameters:  O  526 :
// Return Values:   O  527 :
//------------------------------------------------------------------------------  O  528 :
void VehSend5BPS(int8 byte)  O  529 :f1887V647
{  O  530 :{851
    int8 bit;  O  531 :V680
  O  532 :
    // TBD - KWP time W5 delay here?? O  533 :
    // ensure ISO 9141 time W0 of 2mS satisfied  O  534 :
    output_bit(PIN_B6, 0);    O  535 :
    output_bit(PIN_B7, 0);  O  536 :
    delay_ms(2);  O  537 :
  O  538 :
    // send out one address byte at 5 BPS  O  539 :
    // start bit  O  540 :
    output_bit(PIN_B6, 1);  O  541 :
    output_bit(PIN_B7, 1);  O  542 :
    delay_ms(200);  O  543 :
  O  544 :
    // send byte starting with LSB  O  545 :
    for (bit=0; bit<8; bit++)  O  546 :
    {  O  547 :
        if (bit_test(byte, 0))  O  548 :{863
        {  O  549 :
            output_bit(PIN_B6, 0);  O  550 :{866
            output_bit(PIN_B7, 0);  O  551 :
            delay_ms(200);  O  552 :
        }  O  553 :}869
        else  O  554 :
        {  O  555 :
            output_bit(PIN_B6, 1);  O  556 :{871
            output_bit(PIN_B7, 1);  O  557 :
            delay_ms(200);  O  558 :
        }  O  559 :}874
        // go to next bit  O  560 :
        byte = byte >> 1;  O  561 :
    }   O  562 :}875
  O  563 :
    // stop bit  O  564 :
    output_bit(PIN_B6, 0);  O  565 :
    output_bit(PIN_B7, 0);  O  566 :
    delay_ms(200);  O  567 :
}  O  568 :}878
  O  569 :
//------------------------------------------------------------------------------  O  570 :
// Function Name: VehFastInit  O  571 :
// Description: Perform the KWP fast initalization on K and L lines.   O  572 :
//  NOTE: Logic values are inverted (i.e. 1 = low and 0 = high) by the scan tool  O  573 :
//  hardaware.  O  574 :
// Parameters:  O  575 :
// Output Parameters:  O  576 :
// Return Values:   O  577 :
//------------------------------------------------------------------------------  O  578 :
void VehFastInit()  O  579 :f1889
{  O  580 :{879
    //TBD - W5 delay here?? O  581 :
  O  582 :
    // TiniL from 14230-2 spec  O  583 :
    output_bit(PIN_B6, 1);  O  584 :
    output_bit(PIN_B7, 1);  O  585 :
	if (gCurrentCmd == CMD_KWP_FAST_INIT_9600)  O  586 :
	{  O  587 :
		gFlags.enableIso9600Baud = TRUE;  O  588 :{885
    	delay_ms(35);  O  589 :
	}  O  590 :}886
	else  O  591 :
	{  O  592 :
		gFlags.enableIso9600Baud = FALSE;  O  593 :{888
    	delay_ms(25);  O  594 :
	}  O  595 :}889
  O  596 :
    // TiniH from 14230-2 spec  O  597 :
    output_bit(PIN_B6, 0);  O  598 :
    output_bit(PIN_B7, 0);  O  599 :
	if (gCurrentCmd == CMD_KWP_FAST_INIT_9600)  O  600 :
		delay_ms(15);  O  601 :
	else  O  602 :
    	delay_ms(25);  O  603 :
  O  604 :
    // TBD - toggle low here?? O  605 :
}  O  606 :}895
  O  607 :
//------------------------------------------------------------------------------  O  608 :
// Function Name: VehSetIso5msByteDelayEnable  O  609 :
// Description: ISO 9141 states the interbyte message timing to the vehicle  O  610 :
//	must be 5mS. When enabled, the 5mS between each byte is inserted, when   O  611 :
//	disabled no delay is inserted and the data is sent as fast as possible.  O  612 :
// Parameters:  O  613 :
// Output Parameters:  O  614 :
// Return Values:   O  615 :
//------------------------------------------------------------------------------  O  616 :
void VehSetIso5msByteDelayEnable()  O  617 :f1894
{  O  618 :{896
	if (gHostBuf[2] == 0)  O  619 :
		gFlags.enableIso5msByteDelay = FALSE;  O  620 :
	else  O  621 :
		gFlags.enableIso5msByteDelay = TRUE;  O  622 :
}  O  623 :}901
  O  624 :
//------------------------------------------------------------------------------  O  625 :
// Function Name: VehSetLLineXmitEnable  O  626 :
// Description: Sets the L line transmit either true of false.   O  627 :
// Parameters:  O  628 :
// Output Parameters:  O  629 :
// Return Values:   O  630 :
//------------------------------------------------------------------------------  O  631 :
void VehSetLLineXmitEnable()  O  632 :f1891
{  O  633 :{902
	if (gHostBuf[2] == 0)  O  634 :
		gFlags.enableLLineXmit = FALSE;  O  635 :
	else  O  636 :
		gFlags.enableLLineXmit = TRUE;  O  637 :
}  O  638 :}907
  O  639 :
//------------------------------------------------------------------------------  O  640 :
// Function Name: VehIsoSet9600BaudEnable  O  641 :
// Description: Sets ISO baud rate to 9600 or 10.4k   O  642 :
// Parameters:  O  643 :
// Output Parameters:  O  644 :
// Return Values:   O  645 :
//------------------------------------------------------------------------------  O  646 :
void VehSetIso9600BaudEnable()  O  647 :f1893
{  O  648 :{908
	if (gHostBuf[2] == 0)  O  649 :
		gFlags.enableIso9600Baud = FALSE;  O  650 :
	else  O  651 :
		gFlags.enableIso9600Baud = TRUE;  O  652 :
}  O  653 :}913
  O  654 :
//------------------------------------------------------------------------------  O  655 :
// Function Name: VehSetIsoChecksumEnable  O  656 :
// Description: Sets adding ISO checksum to the end of each messsage, or to  O  657 :
//	not add the checksum byte.   O  658 :
// Parameters:  O  659 :
// Output Parameters:  O  660 :
// Return Values:   O  661 :
//------------------------------------------------------------------------------  O  662 :
void VehSetIsoChecksumEnable()  O  663 :f1892
{  O  664 :{914
	if (gHostBuf[2] == 0)  O  665 :
		gFlags.enableIsoChecksum = FALSE;  O  666 :
	else  O  667 :
		gFlags.enableIsoChecksum = TRUE;  O  668 :
}  O  669 :}919
  O  670 :
//------------------------------------------------------------------------------  O  671 :
// Function Name: VehReadBatteryVoltage  O  672 :
// Description: Read the battery voltage via the A/D converter. A/D is assumed  O  673 :
//	to be already setup and on the right channel before this function is called.  O  674 :
// Parameters:  O  675 :
// Output Parameters:  O  676 :
// Return Values:   O  677 :
//------------------------------------------------------------------------------  O  678 :
void VehReadBatteryVoltage()  O  679 :f1890
{  O  680 :{920
	int16 voltage;  O  681 :V681
	  O  682 :
	if (gDevid2 == VER_18F248)  O  683 :
	{	  O  684 :
		// on old 18F248 part, we can use the CCS compiler built in function  O  685 :
		set_adc_channel(0);  O  686 :{924
		delay_us(10);  O  687 :
		voltage = read_adc();  O  688 :
		  O  689 :
		// put A/D reading into buffer for transmission to host  O  690 :
		gVehicleBuf[0][0] = (int8)(voltage >> 8);  O  691 :
		gVehicleBuf[0][1] = (int8)voltage;  O  692 :
	}  O  693 :}927
	else  O  694 :
	{  O  695 :
		// on new 18F2480 part, the register/bit locations changed so must do manually  O  696 :
		  O  697 :
		// start ADC conversion  O  698 :
		bit_set(ADCON0, 1);  O  699 :{929
		  O  700 :
		// wait for conversion to complete  O  701 :
		while (bit_test(ADCON0, 1));  O  702 :
		  O  703 :
		// read A/D reading into buffer for transmission to host  O  704 :
		gVehicleBuf[0][0] = ADRESH;  O  705 :
		gVehicleBuf[0][1] = ADRESL;  O  706 :
	}	  O  707 :}933
}  O  708 :}934
  O  709 :
//------------------------------------------------------------------------------  O  710 :
// Function Name: timed_getc  O  711 :
// Description: Get a character from the ISO UART using a timeout. If a   O  712 :
//  character doesn't arrive in the timeout specified the function returns.  O  713 :
//  NOTE: timeout units of measure is 10's of uS. (e.g. 100 = 1000uS)  O  714 :
// Parameters: timedOut - TRUE if routine timed out with no char, FALSE otherwise.  O  715 :
//  timeout - the timeout to wait for the char in 10's of uS.  O  716 :
// Output Parameters:  O  717 :
// Return Values: The received character. Valid only if timedOut is FALSE.  O  718 :
//------------------------------------------------------------------------------  O  719 :
int8 timed_getc(BOOLEAN* timedOut, int16 timeout)   O  720 :f1895V655V656
{  O  721 :{935
    int16 time;  O  722 :V682
  O  723 :
    *timedOut = FALSE;  O  724 :
    time=0;  O  725 :
  O  726 :
    // wait up to timeout for a character to arrive  O  727 :
    while(!kbhit()&&(++time<timeout))     O  728 :
        delay_us(10);  O  729 :
  O  730 :
    if(kbhit())  O  731 :
	{  O  732 :
		if (gFlags.enableIso9600Baud == TRUE)  O  733 :{945
	        return(fgetc(ISO_K_9600_LINE_STREAM));  O  734 :
		else  O  735 :
			return(fgetc(ISO_K_LINE_STREAM));  O  736 :
	}  O  737 :}951
    else  O  738 :
    {  O  739 :
        *timedOut=TRUE;  O  740 :{953
        return(0);  O  741 :
    }   O  742 :}954
}  O  743 :}955
  O  744 :
  O  745 :
  O  746 :
  O  747 :
  O  748 :
  O  749 :
  O  750 :
  O  751 :
  O  752 :
  O  753 :E
 O  753 :
#include "Host.c" A   48 :
 //------------------------------------------------------------------------------  T    1 :I19
// File: Host  T    2 :
//  T    3 :
// Purpose: Host communication and parsing routines.   T    4 :
//  T    5 :
// Change History:  T    6 :
// Date		Author		Description  T    7 :
//          Lafreniere	Created  T    8 :
//------------------------------------------------------------------------------  T    9 :
#include "Host.h" T   10 :
 //------------------------------------------------------------------------------  U    1 :I20
// File: Host  U    2 :
//  U    3 :
// Purpose: Host communication and parsing routines.   U    4 :
//  U    5 :
// Change History:  U    6 :
// Date		Author		Description  U    7 :
//          Lafreniere	Created  U    8 :
//------------------------------------------------------------------------------  U    9 :
#ifndef HOST_H  U   10 :
#define HOST_H  U   11 :
  U   12 :
BOOLEAN HostParseMsg();  U   13 :f1912P1912
void HostSendVehicleData();  U   14 :f1913P1913
void HostSendLocalData();  U   15 :f1914P1914
void HostSendError();  U   16 :f1915P1915
  U   17 :
#endif  U   18 :E
 U   18 :
#include "Globals.h" T   11 :
 //------------------------------------------------------------------------------  F    1 :I5
// File: Globals  F    2 :
//  F    3 :
// Purpose: Project global variables.  F    4 :
//  F    5 :
// Change History:  F    6 :
// Date		Author		Description  F    7 :
//          Lafreniere	Created  F    8 :
//------------------------------------------------------------------------------  F    9 :
#ifndef GLOBALS_H  F   10 :
#define GLOBALS_H  F   11 :
  F   12 :
#include "Const.h"  F   13 :
#include "Timer.h"  F   14 :
                   F   15 :
typedef struct   F   16 :
{  F   17 :
    int8 comType : 3;  F   18 :
    int8 firstResp : 1;  F   19 :
	int8 forceInitCAN : 1;  F   20 :
    int8 canModeChanged : 1;  // true when mode changes (e.g. 250kb to 500kb, or SI to EI)  F   21 :
    int8 adapterLocked : 1;  F   22 :
	int8 enableLLineXmit : 1; 		// transmit at 10.4 on both K and L lines (default is K line only)  F   23 :
	int8 enableIso9600Baud : 1;		// transmit ISO at 9600 if true, false means 10.4k (default is 10.4k)  F   24 :
	int8 enableIso5msByteDelay : 1; // true means 5mS between each byte sent to vehicle, false no delay (default is true)  F   25 :
	int8 enableIsoChecksum : 1;		// add checksum byte to ISO messages if true, no byte added if false (default is true)  F   26 :
} Flags;  F   27 :
  F   28 :
int8 gDevid1;  F   29 :
int8 gDevid2;  F   30 :
  F   31 :
Flags gFlags = { MODE_ISO, FALSE };  F   32 :
int8 gError = ERR_NONE;  F   33 :
int8 gErrorExtraData1 = 0;  F   34 :
int8 gErrorExtraData2 = 0;  F   35 :
int8 gErrorExtraData3 = 0;  F   36 :
  F   37 :
int8 gHostBuf[HOST_RECV_MSG_SIZE];  F   38 :
//*** #locate gHostBuf=0x2d  // pic18f248 should not require ram to be managed  F   39 :
int8 gHostBufCnt = 0;  F   40 :
int16 gHostRecvTimeout = 0;  F   41 :
  F   42 :
int8 gVehicleBuf[VEHICLE_MAX_MSGS][VEHICLE_MSG_SIZE];  F   43 :
//*** #locate gVehicleBuf=0xa0  F   44 :
  F   45 :
int8 gVehicleBufCnt = 0;  F   46 :
  F   47 :
int8 gCurrentCmd = 0;   // current command sent from host  F   48 :
int8 gLastCmd = 0;      // last command sent from host  F   49 :
  F   50 :
int32 gP2can = HST_FIFTY_MS;  F   51 :
  F   52 :
// decyption variables  F   53 :
int16  gLfsr;  F   54 :
//int8 gLast;  F   55 :
  F   56 :
#endif  F   57 :E
 F   57 :
#include "Const.h" T   12 :
 //------------------------------------------------------------------------------  E    1 :I4
// File: Const  E    2 :
//  E    3 :
// Purpose: Project constants.  E    4 :
//  E    5 :
// Change History:  E    6 :
// Date		Author		Description  E    7 :
//          Lafreniere	Created  E    8 :
//------------------------------------------------------------------------------  E    9 :
#ifndef CONST_H  E   10 :
#define CONST_H  E   11 :
  E   12 :
#ifdef DEBUG  E   13 :
    #define TRACE(char) Trace(char);  E   14 :
#else  E   15 :
    #define TRACE(char)   E   16 :
#endif  E   17 :
  E   18 :
// software revision  E   19 :
#define SOFTWARE_REV            0x08  E   20 :
  E   21 :
#define MAX_ECU				8 	// per ISO 15675-4 7.3.3. max ECUs is 8  E   22 :
  E   23 :
#define DEVID1_ADDR 0x3FFFFEL  E   24 :
#define DEVID2_ADDR 0x3FFFFFL   E   25 :
  E   26 :
// The old 18F248 and the new 18F2480 have some differences, mostly in the analog  E   27 :
// to digital converter. Using _DEVID2 check the processor version.   E   28 :
#define VER_18F248				0x08  E   29 :
//#define VER_18F2480 					  E   30 :
  E   31 :
// destination address  E   32 :
#define DESTINATION_ADDR        0x2d  E   33 :
  E   34 :
// from host msg byte positions  E   35 :
#define IDX_HOST_DESTINATION        0  E   36 :
#define IDX_HOST_COMMAND            1  E   37 :
#define IDX_HOST_BYTE_COUNT         2  E   38 :
#define IDX_HOST_START_DATA         3  E   39 :
#define IDX_HOST_CHECKSUM           14  E   40 :
  E   41 :
// to host msg byte positions  E   42 :
#define IDX_VEHICLE_DESTINATION     0  E   43 :
#define IDX_VEHICLE_COMMAND         1  E   44 :
#define IDX_VEHICLE_CHECKSUM        13  E   45 :
  E   46 :
// max size of all messages  E   47 :
#define HOST_RECV_MSG_SIZE          15      // from host size including all non-OBD II bytes  E   48 :
#define HOST_SEND_MSG_SIZE          14      // to host size  E   49 :
#define VEHICLE_MSG_SIZE            12      // to/from max vehicle size, not as sent to host (RSP byte not included)   E   50 :
#define VEHICLE_MAX_MSGS            32      // number of VEHICLE_MSG_SIZE we can store in RAM  E   51 :
  E   52 :
// error codes returned to host  E   53 :
#define ERR_NONE                        0x00   // ERR_NONE must be 0!  E   54 :
#define ERR_NOT_IMPLEMENTED             0x01  E   55 :
#define ERR_BAD_CHECKSUM                0x02  E   56 :
#define ERR_ISO_NO_SYNC                 0x03  E   57 :
#define ERR_ISO_INCORRECT_INV_ADDR      0x04  E   58 :
#define ERR_ISO_NO_RESPONSE             0x05  E   59 :
#define ERR_J1850_NO_RESPONSE           0x07  E   60 :
#define ERR_ISO_BAD_CHECKSUM            0x08  E   61 :
#define ERR_J1850_BAD_CRC               0x09      E   62 :
#define ERR_KWP_BAUD_TOO_SLOW           0x0b    // not used  E   63 :
#define ERR_KWP_NO_RESPONSE             0x0c    // not used  E   64 :
#define ERR_KWP_INCORRECT_SYNC          0x0d    // not used  E   65 :
#define ERR_ISO_NOT_ENABLED             0x10    // not used  E   66 :
#define ERR_J1850_VPW_NOT_ENABLED       0x11    // not used  E   67 :
#define ERR_J1850_PWM_NOT_ENABLED       0x12    // not used  E   68 :
#define ERR_KWP_NOT_ENABLED             0x13    // not used  E   69 :
#define ERR_VW_PASS_THRU_NOT_ENABLED    0x14    // not used  E   70 :
#define ERR_CAN_NO_RESPONSE             0x15	// COMSTAT CAN register returned as extra data  E   71 :
#define ERR_CAN_RX_OVERFLOW             0x16  E   72 :
#define ERR_CAN_TX_BUFFER_UNAVAIL       0x18  E   73 :
#define ERR_CAN_RX_MESSAGE_LEN_WRONG    0x19  E   74 :
#define ERR_CAN_ERROR_INTERRUPT			0x1A	// COMSTAT CAN register returned as extra data  E   75 :
#define ERR_CAN_INVALID_MSG_INTERRUPT   0x1B    // TXBnCON CAN register returned as extra data 1, 2 and 3  E   76 :
#define ERR_ISO_INV_ADDR_NOT_RECEIVED	0x1F  E   77 :
#define ERR_ISO_SYNC_BYTE_NOT_RECEIVED	0x20  E   78 :
  E   79 :
#define ERR_WRONG_DESTINATION           0x80      E   80 :
#define ERR_BYTE_COUNT_TOO_LARGE        0x81  E   81 :
#define ERR_J1850_FRAMING_ERROR         0x82  E   82 :
#define ERR_J1850_MSG_OVERFLOW          0x83   E   83 :
#define ERR_ISO_NO_KEYBYTE              0x84  E   84 :
#define ERR_ADAPTER_LOCKED              0x85  E   85 :
#define ERR_INVALID_NON_VOLATILE_SECTOR 0x86  E   86 :
#define ERR_NON_VOLATILE_SECTOR_LOCKED  0x87  E   87 :
  E   88 :
// host-to-adapter commands  E   89 :
#define CMD_ISO_WITH_5_BAUD             0x01  E   90 :
#define CMD_VPW                         0x02  E   91 :
#define CMD_PWM                         0x04  E   92 :
#define CMD_CAN_SI_250KB                0x08      E   93 :
#define CMD_ISO                         0x10  E   94 :
#define CMD_VW_PASS_THRU_WITH_5_BAUD    0x20    // not used  E   95 :
#define CMD_VW_PASS_THRU_WITHOUT_5_BAUD 0x40    // not used  E   96 :
#define CMD_PWM_WITH_IFR                0x80  E   97 :
#define CMD_ISO_1ST_RESPONSE            0x81  E   98 :
#define CMD_VPW_1ST_RESPONSE            0x82  E   99 :
#define CMD_ATOD_CONVERSION             0x83    // not used  E  100 :
#define CMD_PWM_1ST_RESPONSE            0x84  E  101 :
#define CMD_KWP_WITH_5_BAUD             0x85  E  102 :
#define CMD_KWP_REPORT_KW1_KW2          0x86    // not used  E  103 :
#define CMD_KWP_FAST_INIT               0x87  E  104 :
#define CMD_KWP                         0x88  E  105 :
#define CMD_KWP_1ST_RESPONSE            0x89  E  106 :
#define CMD_CAN_SI_500KB                0x90  E  107 :
#define CMD_CAN_EI_250KB                0x91  E  108 :
#define CMD_CAN_EI_500KB                0x92  E  109 :
#define CMD_CAN_SI_250KB_1ST            0x93  E  110 :
#define CMD_CAN_SI_500KB_1ST            0x94  E  111 :
#define CMD_CAN_EI_250KB_1ST            0x95  E  112 :
#define CMD_CAN_EI_500KB_1ST            0x96  E  113 :
#define CMD_CAN_SET_STD_MASK_FILTER		0x97  E  114 :
#define CMD_CAN_SET_XTD_MASK_FILTER		0x98  E  115 :
#define CMD_CAN_SET_P2_CAN_TIMEOUT		0x99  E  116 :
#define CMD_CAN_SI_250KB_FBGO			0x9A	// FBGO = fast bus get off  E  117 :
#define CMD_CAN_SI_500KB_FBGO			0x9B	// FBGO = fast bus get off  E  118 :
#define CMD_CAN_EI_250KB_FBGO			0x9C	// FBGO = fast bus get off  E  119 :
#define CMD_CAN_EI_500KB_FBGO			0x9D	// FBGO = fast bus get off  E  120 :
#define CMD_CAN_SI_250KB_LISTEN			0x9E	  E  121 :
#define CMD_CAN_SI_500KB_LISTEN			0x9F	  E  122 :
#define CMD_CAN_EI_250KB_LISTEN			0xA0	  E  123 :
#define CMD_CAN_EI_500KB_LISTEN			0xA1  E  124 :
#define CMD_CAN_SI_250KB_NO_RESPONSE	0xA2	  E  125 :
#define CMD_CAN_SI_500KB_NO_RESPONSE	0xA3	  E  126 :
#define CMD_CAN_EI_250KB_NO_RESPONSE	0xA4	  E  127 :
#define CMD_CAN_EI_500KB_NO_RESPONSE	0xA5  E  128 :
#define CMD_ISO_NO_RESPONSE				0xA6  E  129 :
#define CMD_ISO_ENABLE_L_LINE_XMIT		0xA9  E  130 :
#define CMD_ISO_SET_9600_BAUD			0xAB  E  131 :
#define CMD_ISO_CHECKSUM_ENABLE			0xAC  E  132 :
#define CMD_ISO_5MS_BYTE_DELAY_ENABLE	0xAD  E  133 :
#define CMD_UNLOCK_ADAPTER              0xB0	  E  134 :
#define CMD_READ_EEPROM					0xB9  E  135 :
#define CMD_WRITE_EEPROM				0xBA  E  136 :
#define CMD_KWP_FAST_INIT_9600			0xC4  E  137 :
#define CMD_READ_BATTERY_VOLTAGE		0xF0  E  138 :
  E  139 :
// adapter-to-host commands  E  140 :
#define CMD_ERROR                       0x80  E  141 :
#define CMD_ISO_MSG                     0x81  E  142 :
#define CMD_VPW_MSG                     0x82  E  143 :
#define CMD_PWM_MSG                     0x84  E  144 :
#define CMD_CAN_MSG                     0x88  E  145 :
#define CMD_KWP_MSG                     0x01  E  146 :
#define CMD_LOCAL_DATA					0x40  E  147 :
  E  148 :
// transmit modes (must fit in 3-bits!)  E  149 :
#define MODE_ISO                 0x00  E  150 :
#define MODE_VPW                 0x01  E  151 :
#define MODE_PWM                 0x02  E  152 :
#define MODE_KWP                 0x03  E  153 :
#define MODE_CAN                 0x04  E  154 :
  E  155 :
// interface capabilites (i.e. what com modes does the adapter support)  E  156 :
#define CAP_ISO         0x01  E  157 :
#define CAP_VPW         0x02  E  158 :
#define CAP_PWM         0x04  E  159 :
#define CAP_KWP         0x08  E  160 :
#define CAP_CAN         0x10  E  161 :
#define CAP_DUAL_CAN	0x20  E  162 :
#define DASH_DYNO_VER	0x40  E  163 :
#ifdef DASH_DYNO  E  164 :
#define CAP_INTERFACE   (CAP_ISO | CAP_VPW | CAP_PWM | CAP_KWP | CAP_CAN | DASH_DYNO_VER)  E  165 :
#else  E  166 :
#define CAP_INTERFACE   (CAP_ISO | CAP_VPW | CAP_PWM | CAP_KWP | CAP_CAN)  E  167 :
#endif  E  168 :
  E  169 :
#endif   E  170 :E
 E  170 :
#include "Timer.h" T   13 :
 //------------------------------------------------------------------------------  G    1 :I6
// File: Timer  G    2 :
//  G    3 :
// Purpose: High speed timer (HST) routines.   G    4 :
//  G    5 :
// Change History:  G    6 :
// Date		Author		Description  G    7 :
//          Lafreniere	Created  G    8 :
//------------------------------------------------------------------------------  G    9 :
#ifndef TIMER_H  G   10 :
#define TIMER_H  G   11 :
  G   12 :
#define TIMER1_TIMEOUT          0     // 1.6uS per tick with div set to 8  G   13 :
#define MS_TO_TICKS(mS) 		((mS * 10000) / 16)	  // 1.6uS per tick  G   14 :
  G   15 :
// max 16-bit number  G   16 :
#define HST_TWO_MS              1250  G   17 :
#define HST_TEN_MS              6250  G   18 :
#define HST_TWENTY_FIVE_MS      15625  G   19 :
#define HST_FIFTY_MS            31250  G   20 :
#define HST_FIVE_HUNDRED_MS		312500	// NOTE: this number exceeds 16-bit timer and must be used with Int32  G   21 :
#define HST_ONE_S				625000	// NOTE: this number exceeds 16-bit timer and must be used with Int32  G   22 :
  G   23 :
typedef int16 HstTimer; //TBD DEBUG  G   24 :
//typedef int32 HstTimer;  G   25 :
              G   26 :
HstTimer HstGetTicks(void) { return get_timer1(); }  G   27 :
BOOLEAN HstTestTimer(HstTimer timer, HstTimer ticks);  G   28 :
BOOLEAN HstTestTimerRetrig(HstTimer *timer, HstTimer ticks);  G   29 :
HstTimer HstElapsedTime(HstTimer timer);  G   30 :
  G   31 :
#endif  G   32 :E
 G   32 :
#include "Util.h" T   14 :
 //------------------------------------------------------------------------------  L    1 :I11
// File: Util  L    2 :
//  L    3 :
// Purpose: Misc utility routines.   L    4 :
//  L    5 :
// Change History:  L    6 :
// Date		Author		Description  L    7 :
//          Lafreniere	Created  L    8 :
//------------------------------------------------------------------------------  L    9 :
#ifndef UTIL_H  L   10 :
#define UTIL_H  L   11 :
  L   12 :
// starting address for the 4-byte EEPOM write protect table  L   13 :
#define EEPROM_WRITE_PROTECT_TABLE_ADDR 	252  L   14 :
  L   15 :
// the logical sector size is arbitrary and has nothing to do with the PIC hardware  L   16 :
#define EEPROM_SECTOR_SIZE 	8  L   17 :
  L   18 :
void ReadEeprom();  L   19 :
void ReadEepromLocal(int8 sector);  L   20 :
void WriteEeprom();  L   21 :
int8 IsEepromSectorWriteProtected(int8 sector);  L   22 :
int32 ReadEepromSectorWriteProtectTable();  L   23 :
void WriteEerpomSectorWriteProtectTable(int32 writeProtectBits);  L   24 :
void init_ports();  L   25 :
void Bus_If_Init(void);  L   26 :
void DecryptBlock(int8 *outbfr, int8 *inbfr);  L   27 :
int8 IsCmdCAN(int8 cmd);  L   28 :
int8 IsCmdLocal(int8 cmd);  L   29 :
int8 IsCmdFBGO(int8 cmd);  L   30 :
int8 IsCmdListen(int8 cmd);  L   31 :
int8 IsCmdNoResponse(int8 cmd);  L   32 :
int8 IsCmdFirstResp(int8 cmd);  L   33 :
int8 IsCmdStandardId(int8 cmd);  L   34 :
int8 IsCmd250kb(int8 cmd);  L   35 :
int8 checksum(int8* pMsg, int8 size);  L   36 :
int8 crc8(int8* buffer, int8 count);  L   37 :
int32 StrToInt32(int8* str);  L   38 :
int8 TraceStr(int8* pMsg, int8 size);  L   39 :
int8 Trace(int8 msg);  L   40 :
  L   41 :
#endif  L   42 :E
 L   42 :
  T   15 :
// setup the host UART which is the hardware UART  T   16 :
#ifdef DASH_DYNO  T   17 :
#use rs232(baud=115200,xmit=PIN_C6,rcv=PIN_C7,parity=n,bits=8,stream=STREAM_HOST)   T   18 :
#else  T   19 :
#use rs232(baud=19200,xmit=PIN_C6,rcv=PIN_C7,parity=n,bits=8,stream=STREAM_HOST)   T   20 :
#endif  T   21 :
  T   22 :
//------------------------------------------------------------------------------  T   23 :
// Function Name: HostParseMsg   T   24 :
// Description: Parse and error check the incoming host message. gError will   T   25 :
//  contain an error if parse fails.   T   26 :
// Parameters:   T   27 :
// Output Parameters:  T   28 :
// Return Values:   T   29 :
//------------------------------------------------------------------------------  T   30 :
void HostParseMsg()  T   31 :f1912
{  T   32 :{964
	// error check incoming message (order of these checks is important! Last  T   33 :
    // check has the highest priority error code).  T   34 :
    if (gFlags.adapterLocked == TRUE && gHostBuf[IDX_HOST_COMMAND] != CMD_UNLOCK_ADAPTER)  T   35 :
        gError = ERR_ADAPTER_LOCKED;  T   36 :
    if (gHostBuf[IDX_HOST_DESTINATION] != DESTINATION_ADDR)  T   37 :
        gError = ERR_WRONG_DESTINATION;  T   38 :
    if (gHostBuf[IDX_HOST_BYTE_COUNT] > 10 && !IsCmdCAN(gHostBuf[IDX_HOST_COMMAND]) &&  T   39 :
    	!IsCmdLocal(gHostBuf[IDX_HOST_COMMAND]))  T   40 :
        gError = ERR_BYTE_COUNT_TOO_LARGE;  T   41 :
    if (gHostBuf[IDX_HOST_CHECKSUM] != checksum(gHostBuf+1, HOST_RECV_MSG_SIZE-2))  T   42 :
        gError = ERR_BAD_CHECKSUM;  T   43 :
}  T   44 :}982
  T   45 :
//------------------------------------------------------------------------------  T   46 :
// Function Name: HostSendVehicleData  T   47 :
// Description: Send a vehilce data message to the host. The message(s) to send   T   48 :
//	is contained  within global arrays. Messages must be sent to host in the   T   49 :
//	order they were received from the vehicle.  T   50 :
// Parameters:   T   51 :
// Output Parameters:  T   52 :
// Return Values:   T   53 :
//------------------------------------------------------------------------------  T   54 :
void HostSendVehicleData()  T   55 :f1913
{  T   56 :{983
    int8 charCnt;  T   57 :V688
    int8 msgCnt = 0;  T   58 :V689
  T   59 :
    // send the data out the ISO RS-232 port  T   60 :
    while (msgCnt < gVehicleBufCnt)  T   61 :
    {  T   62 :
        // zero all buffer bytes  T   63 :
        //memset(gHostBuf, 0x00, HOST_SEND_MSG_SIZE-1);  T   64 :
  T   65 :
        // add destination  T   66 :
        gHostBuf[IDX_VEHICLE_DESTINATION] = DESTINATION_ADDR;  T   67 :{988
  T   68 :
        // add command  T   69 :
        if (gFlags.comType == MODE_ISO)  T   70 :
            gHostBuf[IDX_VEHICLE_COMMAND] = CMD_ISO_MSG;  T   71 :
        else if (gFlags.comType == MODE_VPW)  T   72 :
            gHostBuf[IDX_VEHICLE_COMMAND] = CMD_VPW_MSG;  T   73 :
        else if (gFlags.comType == MODE_PWM)  T   74 :
            gHostBuf[IDX_VEHICLE_COMMAND] = CMD_PWM_MSG;  T   75 :
        else if (gFlags.comType == MODE_KWP)  T   76 :
            gHostBuf[IDX_VEHICLE_COMMAND] = CMD_KWP_MSG;  T   77 :
		else if (gFlags.comType == MODE_CAN)  T   78 :
            gHostBuf[IDX_VEHICLE_COMMAND] = CMD_CAN_MSG;  T   79 :
   T   80 :
        // add 11-bytes of response  T   81 :
        for (charCnt=0; charCnt<VEHICLE_MSG_SIZE-1; charCnt++)  T   82 :
            gHostBuf[charCnt+2] = gVehicleBuf[msgCnt][charCnt];  T   83 :
  T   84 :
        // add checksum (don't count first byte in checksum)  T   85 :
        gHostBuf[IDX_VEHICLE_CHECKSUM] = checksum(&gHostBuf[1], HOST_SEND_MSG_SIZE-2);  T   86 :
          T   87 :
        // send message to host  T   88 :
        for (charCnt=0; charCnt<HOST_SEND_MSG_SIZE; charCnt++)  T   89 :
	        fputc(gHostBuf[charCnt], STREAM_HOST);   T   90 :
  T   91 :
        msgCnt++;      T   92 :
    }  T   93 :}1016
      T   94 :
    // all messages sent  T   95 :
    gVehicleBufCnt = 0;  T   96 :
}  T   97 :}1017
  T   98 :
//------------------------------------------------------------------------------  T   99 :
// Function Name: HostSendLocalData  T  100 :
// Description: Send a message to the host that doesn't require vehicle   T  101 :
//	communication (e.g. A/D battery reading). The message to send is contained   T  102 :
//  within gVehicleBuf[0] up to 10 bytes of information.  T  103 :
// Parameters:   T  104 :
// Output Parameters:  T  105 :
// Return Values:   T  106 :
//------------------------------------------------------------------------------  T  107 :
void HostSendLocalData()  T  108 :f1914
{  T  109 :{1018
    int8 charCnt;  T  110 :V690
  T  111 :
    // zero all buffer bytes  T  112 :
    //memset(gHostBuf, 0x00, HOST_SEND_MSG_SIZE-1);  T  113 :
  T  114 :
    // add bytes  T  115 :
    gHostBuf[IDX_VEHICLE_DESTINATION] = DESTINATION_ADDR;  T  116 :
    gHostBuf[IDX_VEHICLE_COMMAND] = CMD_LOCAL_DATA;  T  117 :
    gHostBuf[IDX_HOST_BYTE_COUNT] = gCurrentCmd;  T  118 :
  T  119 :
    // add up to 10-bytes of response bytes from vehicle buffer 0  T  120 :
    for (charCnt=0; charCnt<VEHICLE_MSG_SIZE-2; charCnt++)  T  121 :
        gHostBuf[charCnt+3] = gVehicleBuf[0][charCnt];  T  122 :
  T  123 :
    // add checksum (don't count first byte in checksum)  T  124 :
    gHostBuf[IDX_VEHICLE_CHECKSUM] = checksum(&gHostBuf[1], HOST_SEND_MSG_SIZE-2);  T  125 :
              T  126 :
    // send local data message to host  T  127 :
    for (charCnt=0; charCnt<HOST_SEND_MSG_SIZE; charCnt++)  T  128 :
        fputc(gHostBuf[charCnt], STREAM_HOST);  T  129 :
}  T  130 :}1033
  T  131 :
//------------------------------------------------------------------------------  T  132 :
// Function Name: HostSendError  T  133 :
// Description: Sends an error message to the host. Checks the global error   T  134 :
//  byte set by some other part of the system.  T  135 :
// Parameters:   T  136 :
// Output Parameters:  T  137 :
// Return Values:   T  138 :
//------------------------------------------------------------------------------  T  139 :
void HostSendError()  T  140 :f1915
{  T  141 :{1034
    int8 charCnt;  T  142 :V691
  T  143 :
    // zero all buffer bytes  T  144 :
    //memset(gHostBuf, 0x00, HOST_SEND_MSG_SIZE-1);  T  145 :
  T  146 :
    // add bytes  T  147 :
    gHostBuf[IDX_VEHICLE_DESTINATION] = DESTINATION_ADDR;  T  148 :
    gHostBuf[IDX_VEHICLE_COMMAND] = CMD_ERROR;  T  149 :
    gHostBuf[2] = 0xFF;         // ME software rev byte, make FF  T  150 :
    gHostBuf[3] = gError;  T  151 :
    gHostBuf[4] = CAP_INTERFACE;  T  152 :
    gHostBuf[5] = SOFTWARE_REV; // Auterra software rev byte  T  153 :
	gHostBuf[6] = gErrorExtraData1;   // extra data, if any  T  154 :
	gHostBuf[7] = gErrorExtraData2;  T  155 :
	gHostBuf[8] = gErrorExtraData3;  T  156 :
  T  157 :
    // add checksum (don't count first byte in checksum)  T  158 :
    gHostBuf[IDX_VEHICLE_CHECKSUM] = checksum(&gHostBuf[1], HOST_SEND_MSG_SIZE-2);  T  159 :
              T  160 :
    // send error message to host  T  161 :
    for (charCnt=0; charCnt<HOST_SEND_MSG_SIZE; charCnt++)  T  162 :
        fputc(gHostBuf[charCnt], STREAM_HOST);  T  163 :
  T  164 :
    // sent error so no vehicle buffers to send  T  165 :
    gVehicleBufCnt = 0;   T  166 :
    gError = ERR_NONE;  T  167 :
}  T  168 :}1043
  T  169 :
#ifdef BLUETOOTH  T  170 :
//------------------------------------------------------------------------------  T  171 :
// Function Name: SendHost  T  172 :
// Description:   T  173 :
// Parameters:   T  174 :
// Output Parameters:  T  175 :
// Return Values:   T  176 :
//------------------------------------------------------------------------------  T  177 :
void HostSend(int8* bufToSend, int8 size)  T  178 :f1920V693V694
{  T  179 :{1045
	int8 charCnt;  T  180 :V695
	for (charCnt=0; charCnt<size; charCnt++)  T  181 :
	{  T  182 :
        fputc(bufToSend[charCnt], STREAM_HOST);  T  183 :{1053
        delay_ms(20);  T  184 :
    }  T  185 :}1055
}  T  186 :}1056
  T  187 :
//------------------------------------------------------------------------------  T  188 :
// Function Name: HostInitBluetooth  T  189 :
// Description:   T  190 :
// Parameters:   T  191 :
// Output Parameters:  T  192 :
// Return Values:   T  193 :
//------------------------------------------------------------------------------  T  194 :
void HostInitBluetooth()  T  195 :f1922
{  T  196 :{1058
	// If the EEPROM sector 30 first byte is 0xFF then auto pair the adapter to the  T  197 :
	// Windows PC for manufacturing ease. Otherwise, don't auto pair for shipment to  T  198 :
	// the customer. The AdapterTest windows software writes a non-FF value after  T  199 :
	// successfully completing the test.  T  200 :
	int8 autoPair;  T  201 :V697
	autoPair = read_eeprom(30 * EEPROM_SECTOR_SIZE);  T  202 :
	if (autoPair != 0xFF)  T  203 :
		return;  T  204 :
	  T  205 :
	delay_ms(1000);  T  206 :
	  T  207 :
	// Get the RN42 Bluetooth module into command mode  T  208 :
	gHostBuf[0] = '$';  T  209 :
	gHostBuf[1] = '$';  T  210 :
	gHostBuf[2] = '$';	  T  211 :
    HostSend(&gHostBuf[0], 3);  T  212 :
      T  213 :
	delay_ms(50);  T  214 :
	  T  215 :
	// Send RN42 command and Bluetooth address to auto-pair  T  216 :
	gHostBuf[0] = 'C';	  T  217 :
	gHostBuf[1] = ',';	  T  218 :
	gHostBuf[2] = '0';  T  219 :
	gHostBuf[3] = '0';  T  220 :
	gHostBuf[4] = '0';  T  221 :
	gHostBuf[5] = '2';  T  222 :
	gHostBuf[6] = '7';  T  223 :
	gHostBuf[7] = '2';  T  224 :
	gHostBuf[8] = '3';  T  225 :
	gHostBuf[9] = '3';  T  226 :
	gHostBuf[10] = '3';  T  227 :
	gHostBuf[11] = 'C';  T  228 :
	gHostBuf[12] = '6';  T  229 :
	gHostBuf[13] = 'D';  T  230 :
	HostSend(&gHostBuf[0], 14);  T  231 :
	  T  232 :
	// This was to read the Bluetooth address from sector 0 EEPROM, didn't work  T  233 :
	// so for now the address is hard coded  T  234 :
/*	gHostBuf[0] = 'C';	  T  235 :
	gHostBuf[1] = ',';	  T  236 :
	HostSend(&gHostBuf[0], 2);  T  237 :
	  T  238 :
	ReadEepromLocal(0);  T  239 :
	HostSend(&gVehicleBuf[0][2], 8);  T  240 :
	  T  241 :
	ReadEepromLocal(1);  T  242 :
	HostSend(&gVehicleBuf[0][2], 4);*/  T  243 :
	  T  244 :
	delay_ms(3000);  T  245 :
	  T  246 :
	// Get the RN42 Bluetooth out of command mode  T  247 :
	//memcpy(gHostBuf, "---\r", 4);  T  248 :
	gHostBuf[0] = '-';  T  249 :
	gHostBuf[1] = '-';  T  250 :
	gHostBuf[2] = '-';  T  251 :
	gHostBuf[3] = '\r';  T  252 :
    HostSend(&gHostBuf[0], 4);  T  253 :
	  T  254 :
	gHostBufCnt = 0;  T  255 :
}  T  256 :}1064
  T  257 :
#endif  T  258 :
  T  259 :
//------------------------------------------------------------------------------  T  260 :
// Function Name: HostUartISR  T  261 :
// Description: Interrupt function to handling incoming bytes from the host.   T  262 :
//  Put the bytes into a global array to be picked up by the main loop.   T  263 :
// Parameters:   T  264 :
// Output Parameters:  T  265 :
// Return Values:   T  266 :
//------------------------------------------------------------------------------  T  267 :
#int_rda  T  268 :
void HostUartISR()  T  269 :f1924
{  T  270 :{1066
	int8 junk;  T  271 :V699
  T  272 :
	// if UART error occurred  T  273 :
	if (bit_test(RCSTA, OERR))  T  274 :
	{  T  275 :
        // per Microchip spec, clear CREN to clear OERR error  T  276 :
        bit_clear(RCSTA, CREN);	 // disable UART  T  277 :{1070
        bit_set(RCSTA, CREN);	 // re-enable UART  T  278 :
        return;  T  279 :
    }   T  280 :}1071
    if (bit_test(RCSTA, FERR))  T  281 :
    {  T  282 :
		// per Microship spec, read RCREG to clear FERR	and discard byte  T  283 :
		junk = RCREG;	   // read and discard byte  T  284 :{1074
		return;  T  285 :
	}  T  286 :}1075
  T  287 :
    // don't overrun host buffer  T  288 :
    if (gHostBufCnt < HOST_RECV_MSG_SIZE)  T  289 :
    {  T  290 :
        // get byte from UART and place in global array  T  291 :
        gHostBuf[gHostBufCnt] = RCREG; //fgetc(STREAM_HOST);  T  292 :{1078
  T  293 :
        // if this is the first byte it must be the destination addr  T  294 :
        // this helps get the scan tool re-sync'ed with host  T  295 :
        if (gHostBuf[0] == DESTINATION_ADDR)  T  296 :
            gHostBufCnt++;  T  297 :
		else  T  298 :
			gHostBufCnt = 0;    T  299 :
  T  300 :
        // keep reseting timer while chars coming in  T  301 :
        gHostRecvTimeout = HstGetTicks();  T  302 :
    }  T  303 :}1082
    else  T  304 :
        // eat char from port to stop UART interrupt from firing  T  305 :
        junk = RCREG; //fgetc(STREAM_HOST);  T  306 :
  T  307 :
}  T  308 :}1084
  T  309 :
  T  310 :
  T  311 :E
 T  311 :
#include "CAN.c" A   49 :
 //------------------------------------------------------------------------------  V    1 :I21
// File: CAN  V    2 :
//  V    3 :
// Purpose: CAN communication and parsing routines.   V    4 :
//  V    5 :
// Change History:  V    6 :
// Date		Author		Description  V    7 :
//          Lafreniere	Created  V    8 :
//------------------------------------------------------------------------------  V    9 :
#include "CAN.h" V   10 :
 //------------------------------------------------------------------------------  S    1 :I18
// File: CAN  S    2 :
//  S    3 :
// Purpose: CAN communication and parsing routines.   S    4 :
//  S    5 :
// Change History:  S    6 :
// Date		Author		Description  S    7 :
//          Lafreniere	Created  S    8 :
//------------------------------------------------------------------------------  S    9 :
#ifndef CAN_H  S   10 :
#define CAN_H  S   11 :
  S   12 :
void VehSendCAN();  S   13 :
void VehRecvCAN();  S   14 :
void CanEmptyRxBuffer();  S   15 :
void CanSetMaskFilter();  S   16 :
void CanSetP2CanTimeout();  S   17 :
void CanDisable();  S   18 :
  S   19 :
#endif S   20 :E
#include <stdlib.h> V   11 :
 ///////////////////////////////////////////////////////////////////////////  W    1 :I22
////        (C) Copyright 1996,2003 Custom Computer Services           ////  W    2 :
//// This source code may only be used by licensed users of the CCS C  ////  W    3 :
//// compiler.  This source code may only be distributed to other      ////  W    4 :
//// licensed users of the CCS C compiler.  No other use, reproduction ////  W    5 :
//// or distribution is permitted without written permission.          ////  W    6 :
//// Derivative programs created using this software in object code    ////  W    7 :
//// form are not restricted in any way.                               ////  W    8 :
///////////////////////////////////////////////////////////////////////////  W    9 :
  W   10 :
#ifndef _STDLIB  W   11 :
#define _STDLIB  W   12 :
  W   13 :
//---------------------------------------------------------------------------  W   14 :
// Definitions and types  W   15 :
//---------------------------------------------------------------------------  W   16 :
  W   17 :
#ifndef RAND_MAX  W   18 :
#define RAND_MAX  32767    // The value of which is the maximum value  W   19 :
                           // ... returned by the rand function  W   20 :
#endif  W   21 :
  W   22 :
typedef struct {  W   23 :
   signed int quot;  W   24 :T700
   signed int rem;  W   25 :
} div_t;  W   26 :
  W   27 :
typedef struct {  W   28 :
   signed long quot;  W   29 :T704
   signed long rem;  W   30 :
} ldiv_t;  W   31 :
  W   32 :
#include <stddef.h> W   33 :
 ///////////////////////////////////////////////////////////////////////////  X    1 :I23
////        (C) Copyright 1996,2003 Custom Computer Services           ////  X    2 :
//// This source code may only be used by licensed users of the CCS C  ////  X    3 :
//// compiler.  This source code may only be distributed to other      ////  X    4 :
//// licensed users of the CCS C compiler.  No other use, reproduction ////  X    5 :
//// or distribution is permitted without written permission.          ////  X    6 :
//// Derivative programs created using this software in object code    ////  X    7 :
//// form are not restricted in any way.                               ////  X    8 :
///////////////////////////////////////////////////////////////////////////  X    9 :
  X   10 :
#ifndef _STDDEF  X   11 :
  X   12 :
#define _STDDEF  X   13 :
  X   14 :
#if sizeof(int *)==1  X   15 :
#define ptrdiff_t int  X   16 :
#else  X   17 :
#define ptrdiff_t long  X   18 :
#endif  X   19 :
  X   20 :
#define size_t int  X   21 :
#define wchar_t char  X   22 :
#define NULL 0  X   23 :
  X   24 :
#define offsetof(s,f) (offsetofbit(s,f)/8)  X   25 :
  X   26 :
#endif  X   27 :E
 X   27 :
  W   34 :
//---------------------------------------------------------------------------  W   35 :
// String conversion functions  W   36 :
//---------------------------------------------------------------------------  W   37 :
  W   38 :
/* Standard template: float atof(char * s)  W   39 :
 * converts the initial portion of the string s to a float.  W   40 :
 * returns the converted value if any, 0 otherwise  W   41 :
 */  W   42 :
float atof(char * s);  W   43 :f1938V709P1938
  W   44 :
/* Standard template: signed int  atoi(char * s)  W   45 :
 * converts the initial portion of the string s to a signed int  W   46 :
 * returns the converted value if any, 0 otherwise  W   47 :
 */  W   48 :
signed int atoi(char *s);  W   49 :f1940V711P1940
  W   50 :
/* Syntax: signed int32  atoi32(char * s)  W   51 :
   converts the initial portion of the string s to a signed int32  W   52 :
   returns the converted value if any, 0 otherwise*/  W   53 :
signed int32 atoi32(char *s);  W   54 :f1941V713P1941
  W   55 :
/* Standard template: signed long  atol(char * s)  W   56 :
 * converts the initial portion of the string s to a signed long  W   57 :
 * returns the converted value if any, 0 otherwise  W   58 :
 */  W   59 :
signed long atol(char *s);  W   60 :f1942V715P1942
  W   61 :
/* Standard template: float strtol(char * s,char *endptr)  W   62 :
 * converts the initial portion of the string s to a float  W   63 :
 * returns the converted value if any, 0 otherwise  W   64 :
 * the final string is returned in the endptr, if endptr is not null  W   65 :
 */  W   66 :
float strtod(char *s,char *endptr);  W   67 :f1943V717V718P1943
  W   68 :
/* Standard template: long strtoul(char * s,char *endptr,signed int base)  W   69 :
 * converts the initial portion of the string s, represented as an  W   70 :
 * integral value of radix base  to a signed long.  W   71 :
 * Returns the converted value if any, 0 otherwise  W   72 :
 * the final string is returned in the endptr, if endptr is not null  W   73 :
 */  W   74 :
signed long strtol(char *s,char *endptr,signed int base);  W   75 :f1945V720V721V722P1945
  W   76 :
/* Standard template: long strtoul(char * s,char *endptr,signed int base)  W   77 :
 * converts the initial portion of the string s, represented as an  W   78 :
 * integral value of radix base to a unsigned long.  W   79 :
 * returns the converted value if any, 0 otherwise  W   80 :
 * the final string is returned in the endptr, if endptr is not null  W   81 :
 */  W   82 :
long strtoul(char *s,char *endptr,signed int base);  W   83 :f1947V724V725V726P1947
  W   84 :
//---------------------------------------------------------------------------  W   85 :
// Pseudo-random sequence generation functions  W   86 :
//---------------------------------------------------------------------------  W   87 :
  W   88 :
/* The rand function computes a sequence of pseudo-random integers in  W   89 :
 * the range 0 to RAND_MAX  W   90 :
 *  W   91 :
 * Parameters:  W   92 :
 *       (none)  W   93 :
 *  W   94 :
 * Returns:  W   95 :
 *       The pseudo-random integer  W   96 :
 */  W   97 :
long rand(void);  W   98 :f1948P1948
  W   99 :
/* The srand function uses the argument as a seed for a new sequence of  W  100 :
 * pseudo-random numbers to be returned by subsequent calls to rand.  W  101 :
 *  W  102 :
 * Parameters:  W  103 :
 *       [in] seed: The seed value to start from. You might need to pass  W  104 :
 *  W  105 :
 * Returns:  W  106 :
 *       (none)  W  107 :
 *  W  108 :
 * Remarks  W  109 :
 *          The srand function sets the starting point for generating  W  110 :
 *       a series of pseudorandom integers. To reinitialize the  W  111 :
 *       generator, use 1 as the seed argument. Any other value for  W  112 :
 *       seed sets the generator to a random starting point. rand  W  113 :
 *       retrieves the pseudorandom numbers that are generated.  W  114 :
 *       Calling rand before any call to srand generates the same  W  115 :
 *       sequence as calling srand with seed passed as 1.  W  116 :
 *          Usually, you need to pass a time here from outer source  W  117 :
 *       so that the numbers will be different every time you run.  W  118 :
 */  W  119 :
void srand(unsigned int32 seed);  W  120 :f1949V729P1949
  W  121 :
//---------------------------------------------------------------------------  W  122 :
// Memory management functions  W  123 :
//---------------------------------------------------------------------------  W  124 :
  W  125 :
// Comming soon  W  126 :
  W  127 :
//---------------------------------------------------------------------------  W  128 :
// Communication with the environment  W  129 :
//---------------------------------------------------------------------------  W  130 :
  W  131 :
/* The function returns 0 always  W  132 :
 */  W  133 :
signed int system(char *string);  W  134 :f1951V731P1951
  W  135 :
//---------------------------------------------------------------------------  W  136 :
// Searching and sorting utilities  W  137 :
//---------------------------------------------------------------------------  W  138 :
  W  139 :
/* Performs a binary search of a sorted array..  W  140 :
 *  W  141 :
 * Parameters:  W  142 :
 *       [in] key: Object to search for  W  143 :
 *       [in] base: Pointer to base of search data  W  144 :
 *       [in] num: Number of elements  W  145 :
 *       [in] width: Width of elements  W  146 :
 *       [in] compare: Function that compares two elements  W  147 :
 *  W  148 :
 * Returns:  W  149 :
 *       bsearch returns a pointer to an occurrence of key in the array pointed  W  150 :
 *       to by base. If key is not found, the function returns NULL. If the  W  151 :
 *       array is not in order or contains duplicate records with identical keys,  W  152 :
 *       the result is unpredictable.  W  153 :
 */  W  154 :
//void *bsearch(const void *key, const void *base, size_t num, size_t width,  W  155 :
//              int (*compare)(const void *, const void *));  W  156 :
  W  157 :
/* Performs the shell-metzner sort (not the quick sort algorithm). The contents  W  158 :
 * of the array are sorted into ascending order according to a comparison  W  159 :
 * function pointed to by compar.  W  160 :
 *  W  161 :
 * Parameters:  W  162 :
 *       [in] base: Pointer to base of search data  W  163 :
 *       [in] num: Number of elements  W  164 :
 *       [in] width: Width of elements  W  165 :
 *       [in] compare: Function that compares two elements  W  166 :
 *  W  167 :
 * Returns:  W  168 :
 *       (none)  W  169 :
 */  W  170 :
//void *qsort(const void *base, size_t num, size_t width,  W  171 :
//              int (*compare)(const void *, const void *));  W  172 :
  W  173 :
//---------------------------------------------------------------------------  W  174 :
// Integer arithmetic functions  W  175 :
//---------------------------------------------------------------------------  W  176 :
  W  177 :
#define labs abs  W  178 :
  W  179 :
div_t div(signed int numer,signed int denom);  W  180 :f1954V733V734P1954
ldiv_t ldiv(signed long numer,signed long denom);  W  181 :f1957V736V737P1957
  W  182 :
//---------------------------------------------------------------------------  W  183 :
// Multibyte character functions  W  184 :
//---------------------------------------------------------------------------  W  185 :
  W  186 :
// Not supported  W  187 :
  W  188 :
//---------------------------------------------------------------------------  W  189 :
// Multibyte string functions  W  190 :
//---------------------------------------------------------------------------  W  191 :
  W  192 :
// Not supported  W  193 :
  W  194 :
  W  195 :
//---------------------------------------------------------------------------  W  196 :
// Internal implementation  W  197 :
//---------------------------------------------------------------------------  W  198 :
  W  199 :
#include <stddef.h> W  200 :
 ///////////////////////////////////////////////////////////////////////////  X    1 :I23
////        (C) Copyright 1996,2003 Custom Computer Services           ////  X    2 :
//// This source code may only be used by licensed users of the CCS C  ////  X    3 :
//// compiler.  This source code may only be distributed to other      ////  X    4 :
//// licensed users of the CCS C compiler.  No other use, reproduction ////  X    5 :
//// or distribution is permitted without written permission.          ////  X    6 :
//// Derivative programs created using this software in object code    ////  X    7 :
//// form are not restricted in any way.                               ////  X    8 :
///////////////////////////////////////////////////////////////////////////  X    9 :
  X   10 :
#ifndef _STDDEF  X   11 :
  X   12 :
#define _STDDEF  X   13 :
  X   14 :
#if sizeof(int *)==1  X   15 :
#define ptrdiff_t int  X   16 :
#else  X   17 :
#define ptrdiff_t long  X   18 :
#endif  X   19 :
  X   20 :
#define size_t int  X   21 :
#define wchar_t char  X   22 :
#define NULL 0  X   23 :
  X   24 :
#define offsetof(s,f) (offsetofbit(s,f)/8)  X   25 :
  X   26 :
#endif  X   27 :E
 X   27 :
#include <string.h> W  201 :
 ////////////////////////////////////////////////////////////////////////////  Y    1 :I24
////        (C) Copyright 1996,2003 Custom Computer Services            ////  Y    2 :
//// This source code may only be used by licensed users of the CCS C   ////  Y    3 :
//// compiler.  This source code may only be distributed to other       ////  Y    4 :
//// licensed users of the CCS C compiler.  No other use, reproduction  ////  Y    5 :
//// or distribution is permitted without written permission.           ////  Y    6 :
//// Derivative programs created using this software in object code     ////  Y    7 :
//// form are not restricted in any way.                                ////  Y    8 :
////////////////////////////////////////////////////////////////////////////  Y    9 :
  Y   10 :
#ifndef _STRING  Y   11 :
#define _STRING  Y   12 :
#include <stddef.h> Y   13 :
 ///////////////////////////////////////////////////////////////////////////  X    1 :I23
////        (C) Copyright 1996,2003 Custom Computer Services           ////  X    2 :
//// This source code may only be used by licensed users of the CCS C  ////  X    3 :
//// compiler.  This source code may only be distributed to other      ////  X    4 :
//// licensed users of the CCS C compiler.  No other use, reproduction ////  X    5 :
//// or distribution is permitted without written permission.          ////  X    6 :
//// Derivative programs created using this software in object code    ////  X    7 :
//// form are not restricted in any way.                               ////  X    8 :
///////////////////////////////////////////////////////////////////////////  X    9 :
  X   10 :
#ifndef _STDDEF  X   11 :
  X   12 :
#define _STDDEF  X   13 :
  X   14 :
#if sizeof(int *)==1  X   15 :
#define ptrdiff_t int  X   16 :
#else  X   17 :
#define ptrdiff_t long  X   18 :
#endif  X   19 :
  X   20 :
#define size_t int  X   21 :
#define wchar_t char  X   22 :
#define NULL 0  X   23 :
  X   24 :
#define offsetof(s,f) (offsetofbit(s,f)/8)  X   25 :
  X   26 :
#endif  X   27 :E
 X   27 :
#include <ctype.h> Y   14 :
 ////////////////////////////////////////////////////////////////////////////  Z    1 :I25
////        (C) Copyright 1996,2003 Custom Computer Services            ////  Z    2 :
//// This source code may only be used by licensed users of the CCS C   ////  Z    3 :
//// compiler.  This source code may only be distributed to other       ////  Z    4 :
//// licensed users of the CCS C compiler.  No other use, reproduction  ////  Z    5 :
//// or distribution is permitted without written permission.           ////  Z    6 :
//// Derivative programs created using this software in object code     ////  Z    7 :
//// form are not restricted in any way.                                ////  Z    8 :
////////////////////////////////////////////////////////////////////////////  Z    9 :
  Z   10 :
#ifndef _CTYPE  Z   11 :
#define _CTYPE  Z   12 :
  Z   13 :
#define islower(x)  isamoung(x,"abcdefghijklmnopqrstuvwxyz")  Z   14 :
#define isupper(x)  isamoung(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")  Z   15 :
#define isalnum(x)  isamoung(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")  Z   16 :
#define isalpha(x)  isamoung(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")  Z   17 :
#define isdigit(x)  isamoung(x,"0123456789")  Z   18 :
#define isspace(x)  (x==' ')  Z   19 :
#define isxdigit(x) isamoung(x,"0123456789ABCDEFabcdef")  Z   20 :
#define iscntrl(x)  (x<' ')  Z   21 :
#define isprint(x)  (x>=' ')  Z   22 :
#define isgraph(x)  (x>' ')  Z   23 :
#define ispunct(x)  ((x>' ')&&!isalnum(x))  Z   24 :
  Z   25 :
#endif  Z   26 :
  Z   27 :E
 Z   27 :
  Y   15 :
/*Copying functions*/  Y   16 :
/* standard template:  Y   17 :
   void *memmove(void *s1, void *s2, size_t n).  Y   18 :
   Copies max of n characters safely (not following ending '\0')  Y   19 :
   from s2 in s1; if s2 has less than n characters, appends 0 */  Y   20 :
  Y   21 :
char *memmove(void *s1,char *s2,size_t n)  Y   22 :f1971V739V740V741
{  Y   23 :{1110
   char *sc1;  Y   24 :V742
   char *sc2;  Y   25 :V743
   sc1=s1;  Y   26 :
   sc2=s2;  Y   27 :
   if(sc2<sc1 && sc1 <sc2 +n)  Y   28 :
      for(sc1+=n,sc2+=n;0<n;--n)  Y   29 :
         *--sc1=*--sc2;  Y   30 :
   else  Y   31 :
      for(;0<n;--n)  Y   32 :
         *sc1++=*sc2++;  Y   33 :
  return s1;  Y   34 :
  }  Y   35 :}1129
/*    Standard template: char *strcpy(char *s1, const char *s2)  Y   36 :
copies the string s2 including the null character to s1*/  Y   37 :
  Y   38 :
char *strcpy(char *s1, char *s2)  Y   39 :f44V745V746
{  Y   40 :{1131
  char *s;  Y   41 :V747
  Y   42 :
  for (s = s1; *s2 != 0; s++, s2++)  Y   43 :
	  *s = *s2;  Y   44 :
  return(s1);  Y   45 :
}  Y   46 :}1139
/* compiler ignored the name 'strcpy()'; perhaps, it's reserved?? Y   47 :
   Standard template: char *strcpy(char *s1, const char *s2)  Y   48 :
   copies the string s2 including the null character to s1*/  Y   49 :
  Y   50 :
char *strcopy(char *s1, char *s2)  Y   51 :f1977V749V750
{  Y   52 :{1141
  char *s;  Y   53 :V751
  Y   54 :
  for (s = s1; *s2 != 0; s++, s2++)  Y   55 :
	  *s = *s2;  Y   56 :
  return(s1);  Y   57 :
}  Y   58 :}1149
  Y   59 :
/* standard template:  Y   60 :
   char *strncpy(char *s1, const char *s2, size_t n).  Y   61 :
   Copies max of n characters (not following ending '\0')  Y   62 :
   from s2 in s1; if s2 has less than n characters, appends 0 */  Y   63 :
  Y   64 :
char *strncpy(char *s1, char *s2, size_t n)  Y   65 :f1978V753V754V755
{  Y   66 :{1151
  char *s;  Y   67 :V756
  Y   68 :
  for (s = s1; n > 0 && *s2 != '\0'; n--)  Y   69 :
     *s++ = *s2++;  Y   70 :
  for (; n > 0; n--)  Y   71 :
     *s++ = '\0';  Y   72 :
  Y   73 :
  return(s1);  Y   74 :
}  Y   75 :}1167
/***********************************************************/  Y   76 :
  Y   77 :
/*concatenation functions*/  Y   78 :
/* standard template: char *strcat(char *s1, const char *s2)  Y   79 :
appends s2 to s1*/  Y   80 :
  Y   81 :
char *strcat(char *s1, char *s2)  Y   82 :f1979V758V759
{  Y   83 :{1169
   char *s;  Y   84 :V760
  Y   85 :
   for (s = s1; *s != '\0'; s++);  Y   86 :
   while ((*s = *s2) != '\0')  Y   87 :
   {  Y   88 :
       s++;  Y   89 :{1180
       s2++;  Y   90 :
   }  Y   91 :}1181
   return(s1);  Y   92 :
}  Y   93 :}1182
/* standard template: char *strncat(char *s1, char *s2,size_t n)  Y   94 :
appends not more than n characters from s2 to s1*/  Y   95 :
  Y   96 :
char *strncat(char *s1, char *s2, size_t n)  Y   97 :f1980V762V763V764
{  Y   98 :{1184
   char *s;  Y   99 :V765
  Y  100 :
   for (s = s1; *s != '\0'; s++);  Y  101 :
   while ((*s = *s2) != '\0' && 0< n)  Y  102 :
   {  Y  103 :
       s++;  Y  104 :{1197
       s2++;  Y  105 :
       --n;  Y  106 :
   }  Y  107 :}1198
   *s='\0';  Y  108 :
   return(s1);  Y  109 :
}  Y  110 :}1199
  Y  111 :
/***********************************************************/  Y  112 :
  Y  113 :
/*comparison functions*/  Y  114 :
/* standard template: signed int memcmp(void *s1, void *s2).  Y  115 :
   Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */  Y  116 :
  Y  117 :
signed int memcmp(void * s1,char *s2,size_t n)  Y  118 :f1981V767V768V769
{  Y  119 :{1201
char *su1,su2;  Y  120 :V770V771
for(su1=s1,su2=s2;0<n;++su1,++su2,--n)  Y  121 :
{  Y  122 :
   if(*su1!=*su2)  Y  123 :{1209
      return ((*su1<*su2)??1:+1);  Y  124 :
}  Y  125 :}1215
return 0;  Y  126 :
}  Y  127 :}1216
/* standard template: int strcmp(const char *s1, const char *s2).  Y  128 :
   Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */  Y  129 :
  Y  130 :
signed int strcmp(char *s1, char *s2)  Y  131 :f1984V773V774
{  Y  132 :{1218
   for (; *s1 == *s2; s1++, s2++)  Y  133 :
      if (*s1 == '\0')  Y  134 :
         return(0);  Y  135 :
   return((*s1 < *s2) ??-1: 1);  Y  136 :
}  Y  137 :}1231
/* standard template: int strcoll(const char *s1, const char *s2).  Y  138 :
   Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */  Y  139 :
  Y  140 :
signed int strcoll(char *s1, char *s2)  Y  141 :f1985V776V777
{  Y  142 :{1233
   for (; *s1 == *s2; s1++, s2++)  Y  143 :
      if (*s1 == '\0')  Y  144 :
         return(0);  Y  145 :
   return((*s1 < *s2) ??-1: 1);  Y  146 :
}  Y  147 :}1246
  Y  148 :
/* standard template:  Y  149 :
   int strncmp(const char *s1, const char *s2, size_t n).  Y  150 :
   Compares max of n characters (not following 0) from s1 to s2;  Y  151 :
   returns same as strcmp */  Y  152 :
  Y  153 :
signed int strncmp(char *s1, char *s2, size_t n)  Y  154 :f1986V779V780V781
{  Y  155 :{1248
   for (; n > 0; s1++, s2++, n--)  Y  156 :
      if (*s1 != *s2)  Y  157 :
         return((*s1 <*s2) ??-1: 1);  Y  158 :
      else if (*s1 == '\0')  Y  159 :
         return(0);  Y  160 :
   return(0);  Y  161 :
}  Y  162 :}1264
/* standard template:  Y  163 :
   int strxfrm(const char *s1, const char *s2, size_t n).  Y  164 :
   transforms maximum of n characters from s2 and places them into s1*/  Y  165 :
size_t strxfrm(char *s1, char *s2, size_t n)  Y  166 :f1987V783V784V785
{  Y  167 :{1266
  char *s;  Y  168 :V786
  int n1;  Y  169 :V787
  n1=n;  Y  170 :
  for (s = s1; n > 0 && *s2 != '\0'; n--)  Y  171 :
     *s++ = *s2++;  Y  172 :
  for (; n > 0; n--)  Y  173 :
     *s++ = '\0';  Y  174 :
  Y  175 :
  return(n1);  Y  176 :
}  Y  177 :}1282
  Y  178 :
  Y  179 :
  Y  180 :
  Y  181 :
  Y  182 :
/***********************************************************/  Y  183 :
/*Search functions*/  Y  184 :
/* standard template: void *memchr(const char *s, int c).  Y  185 :
   Finds first occurrence of c in n characters of s */  Y  186 :
  Y  187 :
char *memchr(void *s,int c,size_t n)  Y  188 :f1989V789V790V791
{  Y  189 :{1284
   char uc;  Y  190 :V792
   char *su;  Y  191 :V793
   uc=c;  Y  192 :
   for(su=s;0<n;++su,--n)  Y  193 :
      if(*su==uc)  Y  194 :
      return su;  Y  195 :
   return NULL;  Y  196 :
}  Y  197 :}1294
  Y  198 :
/* standard template: char *strchr(const char *s, int c).  Y  199 :
   Finds first occurrence of c in s */  Y  200 :
  Y  201 :
char *strchr(char *s, int c)  Y  202 :f1993V795V796
{  Y  203 :{1296
   for (; *s != c; s++)  Y  204 :
      if (*s == '\0')  Y  205 :
         return(0);  Y  206 :
   return(s);  Y  207 :
}  Y  208 :}1306
/* standard template:  Y  209 :
   size_t strcspn(const char *s1, const char *s2).  Y  210 :
   Computes length of max initial segment of s1 that  Y  211 :
   consists entirely of characters NOT from s2*/  Y  212 :
  Y  213 :
int *strcspn(char *s1, char *s2)  Y  214 :f1994V798V799
{  Y  215 :{1308
   char *sc1, *sc2;  Y  216 :V800V801
  Y  217 :
   for (sc1 = s1; *sc1 != 0; sc1++)  Y  218 :
      for (sc2 = s2; *sc2 != 0; sc2++)  Y  219 :
         if (*sc1 == *sc2)  Y  220 :
            return(sc1 - s1);  Y  221 :
   return(sc1 - s1);  Y  222 :
}  Y  223 :}1324
/* standard template:  Y  224 :
   char *strpbrk(const char *s1, const char *s2).  Y  225 :
   Locates first occurence of any character from s2 in s1;  Y  226 :
   returns s1 if s2 is empty string */  Y  227 :
  Y  228 :
char *strpbrk(char *s1, char *s2)  Y  229 :f1995V803V804
{  Y  230 :{1326
   char *sc1, *sc2;  Y  231 :V805V806
  Y  232 :
   for (sc1 = s1; *sc1 != 0; sc1++)  Y  233 :
      for (sc2 = s2; *sc2 != 0; sc2++)  Y  234 :
         if (*sc1 == *sc2)  Y  235 :
            return(sc1);  Y  236 :
   return(0);  Y  237 :
}  Y  238 :}1342
  Y  239 :
  Y  240 :
/* standard template: char *strrchr(const char *s, int c).  Y  241 :
   Finds last occurrence of c in s */  Y  242 :
  Y  243 :
char *strrchr(char *s, int c)  Y  244 :f1996V808V809
{  Y  245 :{1344
   char *p;  Y  246 :V810
  Y  247 :
   for (p = 0; ; s++)  Y  248 :
   {  Y  249 :
      if (*s == c)  Y  250 :{1350
         p = s;  Y  251 :
      if (*s == '\0')  Y  252 :
         return(p);  Y  253 :
   }  Y  254 :}1355
}  Y  255 :}1356
/* computes length of max initial segment of s1 consisting  Y  256 :
   entirely of characters from s2 */  Y  257 :
  Y  258 :
int *strspn(char *s1, char *s2)  Y  259 :f1998V812V813
{  Y  260 :{1358
   char *sc1, *sc2;  Y  261 :V814V815
  Y  262 :
   for (sc1 = s1; *sc1 != 0; sc1++)  Y  263 :
      for (sc2 = s2; ; sc2++)  Y  264 :
	 if (*sc2 == '\0')  Y  265 :
	    return(sc1 - s1);  Y  266 :
         else if (*sc1 == *sc2)  Y  267 :
            break;  Y  268 :
   return(sc1 - s1);  Y  269 :
}  Y  270 :}1375
/* standard template:  Y  271 :
   char *strstr(const char *s1, const char *s2);  Y  272 :
   Locates first occurence of character sequence s2 in s1;  Y  273 :
   returns 0 if s2 is empty string */  Y  274 :
  Y  275 :
char *strstr(char *s1, char *s2)  Y  276 :f1999V817V818
{  Y  277 :{1377
   char *sc1, *sc2;  Y  278 :V819V820
  Y  279 :
   if (*s2 == 0)  Y  280 :
         return(s1);  Y  281 :
   for (; s1 = strchr(s1, *s2); s1++)  Y  282 :
   {  Y  283 :
      for (sc1 = s1, sc2 = s2; ; sc1++, sc2++)  Y  284 :{1387
         if (*sc2 == 0)  Y  285 :
	    return(s1);  Y  286 :
         else if (*sc1 != *sc2)  Y  287 :
            break;  Y  288 :
   }  Y  289 :}1397
   return(0);  Y  290 :
}  Y  291 :}1398
/* standard template: char *strtok(char *s1, const char *s2).  Y  292 :
  Y  293 :
   Finds next token in s1 delimited by a character from separator  Y  294 :
   string s2 (which can be different from call to call).  First call  Y  295 :
   starts at beginning of s1 searching for first character NOT  Y  296 :
   contained in s2; returns 0 if none is found.  Y  297 :
   If one is found, it is the start of first token (return value).  Y  298 :
   Function then searches from there for a character contained in s2.  Y  299 :
   If none is found, current token extends to end of s1, and subsequent  Y  300 :
   searches for a token will return 0.  If one is found, it is  Y  301 :
   overwritten by '\0', which terminates current token.  Function saves  Y  302 :
   pointer to following character from which next search will start.  Y  303 :
   Each subsequent call, with 0 as first argument, starts searching  Y  304 :
   from saved pointer */  Y  305 :
  Y  306 :
char *strtok(char *s1, char *s2)  Y  307 :f2000V822V823
{  Y  308 :{1400
   char *beg, *end;  Y  309 :V824V825
   static char *save;  Y  310 :V826
  Y  311 :
   beg = (s1)??s1: save;  Y  312 :
   beg += strspn(beg, s2);  Y  313 :
   if (*beg == '\0')  Y  314 :
   {  Y  315 :
      *save = ' ';  Y  316 :{1407
      return(0);  Y  317 :
   }  Y  318 :}1408
   end = strpbrk(beg, s2);  Y  319 :
   if (*end != '\0')  Y  320 :
   {  Y  321 :
      *end = '\0';  Y  322 :{1411
      end++;  Y  323 :
   }  Y  324 :}1412
   save = end;  Y  325 :
   return(beg);  Y  326 :
}  Y  327 :}1413
  Y  328 :
/*****************************************************************/  Y  329 :
/*Miscellaneous functions*/  Y  330 :
/* standard template  Y  331 :
maps error number in errnum to an error message string  Y  332 :
Returns: Pointer to string  Y  333 :
*/  Y  334 :
#ifdef _ERRNO  Y  335 :
char * strerror(int errnum)  Y  336 :
{  Y  337 :
char s[15];  Y  338 :
switch( errnum)  Y  339 :
{  Y  340 :
case 0:  Y  341 :
   strcpy(s,"no errors");  Y  342 :
   return s;  Y  343 :
case EDOM :  Y  344 :
   strcpy(s,"domain error");  Y  345 :
   return s;  Y  346 :
case ERANGE:  Y  347 :
   strcpy(s,"range error");  Y  348 :
   return s;  Y  349 :
}  Y  350 :
}  Y  351 :
#ENDIF  Y  352 :
/* standard template: size_t strlen(const char *s).  Y  353 :
   Computes length of s1 (preceding terminating 0) */  Y  354 :
  Y  355 :
int *strlen(char *s)  Y  356 :f2004V828
{  Y  357 :{1415
   char *sc;  Y  358 :V829
  Y  359 :
   for (sc = s; *sc != 0; sc++);  Y  360 :
   return(sc - s);  Y  361 :
}  Y  362 :}1423
  Y  363 :
/* standard template: size_t stricmp(const char *s1, const char *s2).  Y  364 :
   Compares s1 to s2 ignoring case (upper vs. lower) */  Y  365 :
  Y  366 :
signed int stricmp(char *s1, char *s2)  Y  367 :f2006V831V832
{  Y  368 :{1425
 for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32));  Y  369 :
    s1++, s2++)  Y  370 :
    if (*s1 == '\0')  Y  371 :
       return(0);  Y  372 :
 return((*s1 < *s2) ??-1: 1);  Y  373 :
}  Y  374 :}1458
  Y  375 :
  Y  376 :
/* standard template: char *strlwr(char *s).  Y  377 :
   Replaces uppercase letters by lowercase;  Y  378 :
   returns pointer to new string s */  Y  379 :
  Y  380 :
char *strlwr(char *s)  Y  381 :f2009V836
{  Y  382 :{1460
   char *p;  Y  383 :V837
  Y  384 :
   for (p = s; *p != '\0'; p++)  Y  385 :
      if (*p >= 'A' && *p <='Z')  Y  386 :
         *p += 'a' - 'A';  Y  387 :
   return(s);  Y  388 :
}  Y  389 :}1472
  Y  390 :
  Y  391 :
  Y  392 :
  Y  393 :
/************************************************************/  Y  394 :
  Y  395 :
  Y  396 :
  Y  397 :
  Y  398 :
  Y  399 :
  Y  400 :
  Y  401 :
#endif  Y  402 :E
 Y  402 :
  W  202 :
div_t div(signed int numer,signed int denom)  W  203 :f1954V733V734
{  W  204 :{1473
   div_t val;  W  205 :V838
   val.quot = numer / denom;  W  206 :V840V841
   val.rem = numer - (denom * val.quot);  W  207 :V843V844
   return (val);  W  208 :
}  W  209 :}1486
  W  210 :
ldiv_t ldiv(signed long numer,signed long denom)  W  211 :f1957V736V737
{  W  212 :{1487
   ldiv_t val;  W  213 :V845
   val.quot = numer / denom;  W  214 :V847V848
   val.rem = numer - (denom * val.quot);  W  215 :
   return (val);  W  216 :
}  W  217 :}1498
  W  218 :
float atof(char * s)  W  219 :f1938V709
{  W  220 :{1499
   float pow10 = 1.0;  W  221 :V849
   float result = 0.0;  W  222 :V850
   int sign = 0;  W  223 :V851
   char c;  W  224 :V852
   int ptr = 0;  W  225 :V853
  W  226 :
   c = s[ptr++];  W  227 :
  W  228 :
   if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') {  W  229 :
      if(c == '-') {  W  230 :{1511
         sign = 1;  W  231 :{1514
         c = s[ptr++];  W  232 :
      }  W  233 :}1515
      if(c == '+')  W  234 :
         c = s[ptr++];  W  235 :
  W  236 :
      while((c >= '0' && c <= '9')) {  W  237 :
         result = 10*result + c - '0';  W  238 :{1523V855V856V858V860V861
         c = s[ptr++];  W  239 :
      }  W  240 :}1591
  W  241 :
      if (c == '.') {  W  242 :
         c = s[ptr++];  W  243 :{1594
         while((c >= '0' && c <= '9')) {  W  244 :
             pow10 = pow10*10;  W  245 :{1600
             result += (c - '0')/pow10;  W  246 :V863V864
             c = s[ptr++];  W  247 :
         }  W  248 :}1626
      }  W  249 :}1627
  W  250 :
   }  W  251 :}1628
  W  252 :
   if (sign == 1)  W  253 :
      result = -1*result;  W  254 :
   return(result);  W  255 :
}  W  256 :}1631
  W  257 :
signed int atoi(char *s)  W  258 :f1940V711
{  W  259 :{1632
   signed int result;  W  260 :V865
   int sign, base, index;  W  261 :V866V867V868
   char c;  W  262 :V869
  W  263 :
   index = 0;  W  264 :
   sign = 0;  W  265 :
   base = 10;  W  266 :
   result = 0;  W  267 :
  W  268 :
   // Omit all preceeding alpha characters  W  269 :
   if(s)  W  270 :
      c = s[index++];  W  271 :
  W  272 :
   // increase index if either positive or negative sign is detected  W  273 :
   if (c == '-')  W  274 :
   {  W  275 :
      sign = 1;         // Set the sign to negative  W  276 :{1638
      c = s[index++];  W  277 :
   }  W  278 :}1639
   else if (c == '+')  W  279 :
   {  W  280 :
      c = s[index++];  W  281 :{1643
   }  W  282 :}1644
  W  283 :
   if (c >= '0' && c <= '9')  W  284 :
   {  W  285 :
  W  286 :
      // Check for hexa number  W  287 :
      if (c == '0' && (s[index] == 'x' || s[index] == 'X'))  W  288 :{1649
      {  W  289 :
         base = 16;  W  290 :{1656
         index++;  W  291 :
         c = s[index++];  W  292 :
      }  W  293 :}1657
  W  294 :
      // The number is a decimal number  W  295 :
      if (base == 10)  W  296 :
      {  W  297 :
         while (c >= '0' && c <= '9')  W  298 :{1660
         {  W  299 :
            result = 10*result + (c - '0');  W  300 :{1666
            c = s[index++];  W  301 :
         }  W  302 :}1667
      }  W  303 :}1668
      else if (base == 16)    // The number is a hexa number  W  304 :
      {  W  305 :
         while (c = toupper(c), (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))  W  306 :{1672
         {  W  307 :
            if (c >= '0' && c <= '9')  W  308 :{1686
               result = (result << 4) + (c - '0');  W  309 :
            else  W  310 :
               result = (result << 4) + (c - 'A' + 10);  W  311 :
  W  312 :
            c = s[index++];  W  313 :
         }  W  314 :}1692
      }  W  315 :}1693
   }  W  316 :}1694
  W  317 :
   if (sign == 1 && base == 10)  W  318 :
       result = -result;  W  319 :
  W  320 :
   return(result);  W  321 :
}  W  322 :}1699
  W  323 :
signed long atol(char *s)  W  324 :f1942V715
{  W  325 :{1700
   signed long result;  W  326 :V870
   int sign, base, index;  W  327 :V871V872V873
   char c;  W  328 :V874
  W  329 :
   index = 0;  W  330 :
   sign = 0;  W  331 :
   base = 10;  W  332 :
   result = 0;  W  333 :
  W  334 :
   if(s)  W  335 :
      c = s[index++];  W  336 :
  W  337 :
   // increase index if either positive or negative sign is detected  W  338 :
   if (c == '-')  W  339 :
   {  W  340 :
      sign = 1;         // Set the sign to negative  W  341 :{1706
      c = s[index++];  W  342 :
   }  W  343 :}1707
   else if (c == '+')  W  344 :
   {  W  345 :
      c = s[index++];  W  346 :{1711
   }  W  347 :}1712
  W  348 :
   if (c >= '0' && c <= '9')  W  349 :
   {  W  350 :
      if (c == '0' && (s[index] == 'x' || s[index] == 'X'))  W  351 :{1717
      {  W  352 :
         base = 16;  W  353 :{1724
         index++;  W  354 :
         c = s[index++];  W  355 :
      }  W  356 :}1725
  W  357 :
      // The number is a decimal number  W  358 :
      if (base == 10)  W  359 :
      {  W  360 :
         while (c >= '0' && c <= '9')  W  361 :{1728
         {  W  362 :
            result = 10*result + (c - '0');  W  363 :{1734
            c = s[index++];  W  364 :
         }  W  365 :}1735
      }  W  366 :}1736
      else if (base == 16)    // The number is a hexa number  W  367 :
      {  W  368 :
         while (c = toupper(c), (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))  W  369 :{1740
         {  W  370 :
            if (c >= '0' && c <= '9')  W  371 :{1754
               result = (result << 4) + (c - '0');  W  372 :
            else  W  373 :
               result = (result << 4) + (c - 'A' + 10);  W  374 :
  W  375 :
            c = s[index++];  W  376 :
         }  W  377 :}1760
      }  W  378 :}1761
   }  W  379 :}1762
  W  380 :
   if (base == 10 && sign == 1)  W  381 :
      result = -result;  W  382 :
  W  383 :
   return(result);  W  384 :
}  W  385 :}1767
  W  386 :
/* A fast routine to multiply by 10  W  387 :
 */  W  388 :
signed int32 mult_with10(int32 num)  W  389 :f2021V876
{  W  390 :{1769
   return ( (num << 1) + (num << 3) );  W  391 :
}  W  392 :}1771
  W  393 :
signed int32 atoi32(char *s)  W  394 :f1941V713
{  W  395 :{1772
   signed int32 result;  W  396 :V877
   int sign, base, index;  W  397 :V878V879V880
   char c;  W  398 :V881
  W  399 :
   index = 0;  W  400 :
   sign = 0;  W  401 :
   base = 10;  W  402 :
   result = 0;  W  403 :
  W  404 :
   if(s)  W  405 :
      c = s[index++];  W  406 :
  W  407 :
   // increase index if either positive or negative sign is detected  W  408 :
   if (c == '-')  W  409 :
   {  W  410 :
      sign = 1;         // Set the sign to negative  W  411 :{1778
      c = s[index++];  W  412 :
   }  W  413 :}1779
   else if (c == '+')  W  414 :
   {  W  415 :
      c = s[index++];  W  416 :{1783
   }  W  417 :}1784
  W  418 :
   if (c >= '0' && c <= '9')  W  419 :
   {  W  420 :
      if (c == '0' && (s[index] == 'x' || s[index] == 'X'))  W  421 :{1789
      {  W  422 :
         base = 16;  W  423 :{1796
         index++;  W  424 :
         c = s[index++];  W  425 :
      }  W  426 :}1797
  W  427 :
      // The number is a decimal number  W  428 :
      if (base == 10)  W  429 :
      {  W  430 :
         while (c >= '0' && c <= '9') {  W  431 :{1800
            result = (result << 1) + (result << 3);  // result *= 10;  W  432 :{1806
            result += (c - '0');  W  433 :
            c = s[index++];  W  434 :
         }  W  435 :}1807
      }  W  436 :}1808
      else if (base == 16)    // The number is a hexa number  W  437 :
      {  W  438 :
         while (c = toupper(c), (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))  W  439 :{1812
         {  W  440 :
            if (c >= '0' && c <= '9')  W  441 :{1826
               result = (result << 4) + (c - '0');  W  442 :
            else  W  443 :
               result = (result << 4) + (c - 'A' + 10);  W  444 :
  W  445 :
            c = s[index++];  W  446 :
         }  W  447 :}1832
      }  W  448 :}1833
   }  W  449 :}1834
  W  450 :
   if (base == 10 && sign == 1)  W  451 :
      result = -result;  W  452 :
  W  453 :
   return(result);  W  454 :
}  W  455 :}1839
  W  456 :
float strtod(char *s,char *endptr) {  W  457 :f1943V717V718{1840
   float pow10 = 1.0;  W  458 :V882
   float result = 0.0;  W  459 :V883
   int sign = 0, point = 0;  W  460 :V884V885
   char c;  W  461 :V886
   int ptr = 0;  W  462 :V887
  W  463 :
   if(s)  W  464 :
   {  W  465 :
      c=s[ptr++];  W  466 :{1844
   }  W  467 :}1845
  W  468 :
   while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') {  W  469 :
      if(c == '-') {  W  470 :{1857
         sign = 1;  W  471 :{1860
         c = s[ptr++];  W  472 :
      }  W  473 :}1861
  W  474 :
      while((c >= '0' && c <= '9') && point == 0) {  W  475 :
         result = 10*result + c - '0';  W  476 :{1869
         c = s[ptr++];  W  477 :
      }  W  478 :}1870
  W  479 :
      if (c == '.') {  W  480 :
         point = 1;  W  481 :{1873
         c = s[ptr++];  W  482 :
      }  W  483 :}1874
  W  484 :
      while((c >= '0' && c <= '9') && point == 1) {  W  485 :
         pow10 = pow10*10;  W  486 :{1882
         result += (c - '0')/pow10;  W  487 :
         c = s[ptr++];  W  488 :
      }  W  489 :}1883
  W  490 :
      if (c == '+') {  W  491 :
         c = s[ptr++];  W  492 :{1886
      }  W  493 :}1887
   }  W  494 :}1888
  W  495 :
   if (sign == 1)  W  496 :
      result = -1*result;  W  497 :
   if(endptr)  W  498 :
   {  W  499 :
      if (ptr) {  W  500 :{1893
         ptr--;  W  501 :{1896
         *((char *)endptr)=s+ptr;  W  502 :
      }  W  503 :}1897
      else  W  504 :
         *((char *)endptr)=s;  W  505 :
   }  W  506 :}1899
  W  507 :
   return(result);  W  508 :
}  W  509 :}1900
  W  510 :
long strtoul(char *s,char *endptr,signed int base)  W  511 :f1947V724V725V726
{  W  512 :{1901
   char *sc,*s1,*s2,*sd;  W  513 :V888V889V890V891
   unsigned long x=0;  W  514 :V892
   char sign;  W  515 :V893
   char digits[]="0123456789abcdefghijklmnopqstuvwxyz";  W  516 :V894
   for(sc=s;isspace(*sc);++sc);  W  517 :
   sign=*sc=='-'||*sc=='+'??sc++:'+';  W  518 :
   if(sign=='-')  W  519 :
   {  W  520 :
      if (endptr)  W  521 :{1916
      {  W  522 :
        *((char *)endptr)=s;  W  523 :{1919
      }  W  524 :}1920
      return 0;  W  525 :
   }  W  526 :}1921
  W  527 :
   if (base <0 || base ==1|| base >36) // invalid base  W  528 :
   {  W  529 :
      if (endptr)  W  530 :{1928
      {  W  531 :
        *((char *)endptr)=s;  W  532 :{1931
      }  W  533 :}1932
      return 0;  W  534 :
   }  W  535 :}1933
   else if (base)  W  536 :
   {  W  537 :
      if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))  W  538 :{1937
         sc+=2;  W  539 :
      if(base==8 && *sc =='0')  W  540 :
         sc+=1;  W  541 :
      if(base==2 && *sc =='0'&&sc[1]=='b')  W  542 :
         sc+=2;  W  543 :
  W  544 :
   }  W  545 :}1956
   else if(*sc!='0') // base is 0, find base  W  546 :
      base=10;  W  547 :
   else if (sc[1]=='x' || sc[1]=='X')  W  548 :
      base =16,sc+=2;  W  549 :
   else if(sc[1]=='b')  W  550 :
      base=2,sc+=2;  W  551 :
   else  W  552 :
      base=8;  W  553 :
   for (s1=sc;*sc=='0';++sc);// skip leading zeroes  W  554 :
   for(s2=sc;(sd=memchr(digits,tolower(*sc),base))!=0;++sc)  W  555 :
   {  W  556 :
      x=x*base+(int16)(sd-digits);  W  557 :{1985
   }  W  558 :}1986
   if(s1==sc)  W  559 :
   {  W  560 :
      if (endptr)  W  561 :{1989
      {  W  562 :
        *((char *)endptr)=s;  W  563 :{1992
      }  W  564 :}1993
   return 0;  W  565 :
   }  W  566 :}1994
   if (endptr)  W  567 :
        *((char *)endptr)=sc;  W  568 :
   return x;  W  569 :
}  W  570 :}1997
  W  571 :
signed long strtol(char *s,char *endptr,signed int base)  W  572 :f1945V720V721V722
{  W  573 :{1998
   char *sc,*s1,*s2,*sd;  W  574 :V895V896V897V898
   signed long x=0;  W  575 :V899
   char sign;  W  576 :V900
   char digits[]="0123456789abcdefghijklmnopqstuvwxyz";  W  577 :V901
   for(sc=s;isspace(*sc);++sc);  W  578 :
   sign=*sc=='-'||*sc=='+'??sc++:'+';  W  579 :
   if (base <0 || base ==1|| base >36) // invalid base  W  580 :
   {  W  581 :
      if (endptr)  W  582 :{2017
      {  W  583 :
        *((char *)endptr)=s;  W  584 :{2020
      }  W  585 :}2021
      return 0;  W  586 :
   }  W  587 :}2022
   else if (base)  W  588 :
   {  W  589 :
      if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))  W  590 :{2026
         sc+=2;  W  591 :
      if(base==8 && *sc =='0')  W  592 :
         sc+=1;  W  593 :
      if(base==2 && *sc =='0'&&sc[1]=='b')  W  594 :
         sc+=2;  W  595 :
  W  596 :
   }  W  597 :}2045
   else if(*sc!='0') // base is 0, find base  W  598 :
      base=10;  W  599 :
   else if (sc[1]=='x' || sc[1]=='X')  W  600 :
      base =16,sc+=2;  W  601 :
   else if(sc[1]=='b')  W  602 :
      base=2,sc+=2;  W  603 :
   else  W  604 :
      base=8;  W  605 :
   for (s1=sc;*sc=='0';++sc);// skip leading zeroes  W  606 :
   for(s2=sc;(sd=memchr(digits,tolower(*sc),base))!=0;++sc)  W  607 :
   {  W  608 :
      x=x*base+(int16)(sd-digits);  W  609 :{2074
   }  W  610 :}2075
   if(s1==sc)  W  611 :
   {  W  612 :
      if (endptr)  W  613 :{2078
      {  W  614 :
        *((char *)endptr)=s;  W  615 :{2081
      }  W  616 :}2082
   return 0;  W  617 :
   }  W  618 :}2083
   if(sign=='-')  W  619 :
      x  =-x;  W  620 :
   if (endptr)  W  621 :
        *((char *)endptr)=sc;  W  622 :
   return x;  W  623 :
}  W  624 :}2088
  W  625 :
signed int system(char *string)  W  626 :f1951V731
{  W  627 :{2089
   return 0;  W  628 :
}  W  629 :}2091
  W  630 :
int mblen(char *s,size_t n)  W  631 :f2027V903V904
{  W  632 :{2093
   return strlen(s);  W  633 :
}  W  634 :}2095
  W  635 :
int mbtowc(wchar_t *pwc,char *s,size_t n)  W  636 :f2028V906V907V908
{  W  637 :{2097
   *pwc=*s;  W  638 :
   return 1;  W  639 :
}  W  640 :}2099
  W  641 :
int wctomb(char *s,wchar_t wchar)  W  642 :f2030V910V911
{  W  643 :{2101
   *s=wchar;  W  644 :
   return 1;  W  645 :
}  W  646 :}2103
  W  647 :
size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)  W  648 :f2032V913V914V915
{  W  649 :{2105
   strncpy(pwcs,s,n);  W  650 :
   return strlen(pwcs);  W  651 :
}  W  652 :}2107
  W  653 :
size_t wcstombs(char *s,wchar_t *pwcs,size_t n)  W  654 :f2034V917V918V919
{  W  655 :{2109
   strncpy(s,pwcs,n);  W  656 :
   return strlen(s);  W  657 :
}  W  658 :}2111
  W  659 :
//---------------------------------------------------------------------------  W  660 :
// The random number implementation  W  661 :
//---------------------------------------------------------------------------  W  662 :
  W  663 :
unsigned int32 _Randseed = 1;  W  664 :V920
  W  665 :
long rand(void)  W  666 :f1948
{  W  667 :{2112
   _Randseed = _Randseed * 1103515245 + 12345;  W  668 :V922V923
   return ((unsigned long)(_Randseed >> 16) % RAND_MAX);  W  669 :V925V926
}  W  670 :}2129
  W  671 :
void srand(unsigned int32 seed)  W  672 :f1949V729
{  W  673 :{2130
   _Randseed = seed;  W  674 :
}  W  675 :}2132
  W  676 :
//---------------------------------------------------------------------------  W  677 :
// Searching and sorting utilities implementation  W  678 :
//---------------------------------------------------------------------------  W  679 :
  W  680 :
typedef signed int (*_Cmpfun)(char * p1,char * p2);  W  681 :f2039V928V929P2039
  W  682 :
void qsort(char * qdata, int qitems, int qsize, _Cmpfun cmp) {  W  683 :f2042V932V933V934V935{2136
   int m,j,i,l;  W  684 :V936V937V938V939
   short done;  W  685 :V940
   BYTE t[16];  W  686 :V941
  W  687 :
   m = qitems/2;  W  688 :
   while( m > 0 ) {  W  689 :
     for(j=0; j<(qitems-m); ++j) {  W  690 :{2141
        i = j;  W  691 :{2148
        do  W  692 :
        {  W  693 :
           done=TRUE;  W  694 :{2152
           l = i+m;  W  695 :
           if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {  W  696 :
              memcpy(t, qdata+i*qsize, qsize);  W  697 :{2156
              memcpy(qdata+i*qsize, qdata+l*qsize, qsize);  W  698 :
              memcpy(qdata+l*qsize, t, qsize);  W  699 :
              if(m <= i)  W  700 :
                i -= m;  W  701 :
                done = FALSE;  W  702 :
           }  W  703 :}2165
        } while(!done);  W  704 :}2166
     }  W  705 :}2169
     m = m/2;  W  706 :
   }  W  707 :}2170
}  W  708 :}2171
  W  709 :
  W  710 :
char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)  W  711 :f2053V944V945V946V947V948
{  W  712 :{2173
   char *p, *q;  W  713 :V949V950
   size_t n;  W  714 :V951
   size_t pivot;  W  715 :V952
   int val;  W  716 :V953
  W  717 :
   p = base;  W  718 :
   n = num;  W  719 :
  W  720 :
   while (n > 0)  W  721 :
   {  W  722 :
      pivot = n >> 1;  W  723 :{2178
      q = p + width * pivot;  W  724 :
  W  725 :
      val = (*cmp)(key, q);  W  726 :
  W  727 :
      if (val < 0)  W  728 :
         n = pivot;  W  729 :
      else if (val == 0)  W  730 :
         return ((char *)q);  W  731 :
      else {  W  732 :
         p = q + width;  W  733 :{2182
         n -= pivot + 1;  W  734 :
      }  W  735 :}2183
   }  W  736 :}2184
  W  737 :
   return NULL;      // There's no match  W  738 :
}  W  739 :}2185
  W  740 :
  W  741 :
#endif  W  742 :E
 W  742 :
  V   12 :
#define SINGLE_FRAME        0x00  V   13 :
#define FIRST_FRAME         0x10  V   14 :
#define CONSECUTIVE_FRAME   0x20  V   15 :
#define FLOW_CONTROL        0x30  V   16 :
  V   17 :
typedef enum CAN_SEGMENTED_RECV_MODE  V   18 :
{  V   19 :T954
	RECV_NONE,		// no segmented messages are pending (i.e. no FirstFrame messages rcvd)  V   20 :
	RECV_PENDING,	// one or more segmented messages are pending (i.e. waiting on ConsecutiveFrame(s))  V   21 :
	RECV_COMPLETE	// all segmented messages are received (i.e. all ConsecutiveFrame(s) rcvd)  V   22 :
};  V   23 :
  V   24 :
static signed int16 gFirstFrameDataLength[MAX_ECU];  V   25 :V958
static int32 gFirstFrameIdentifier[MAX_ECU];  V   26 :V959
static int8 gFirstFrameRespondedECUs = 0;  V   27 :V960
  V   28 :
static int32 gIdentifier = 0;  V   29 :V961
static int32 gStdMask 		= 0x000007f8;	  // 11-bit  V   30 :V962
static int32 gStdFilter 	= 0x000007e8;	  // 11-bit  V   31 :V963
static int32 gXtdMask		= 0x1fffff00;	  // 29-bit  V   32 :V964
static int32 gXtdFilter		= 0x18daf100;  	  // 29-bit  V   33 :V965
  V   34 :
void CanInit();  V   35 :f2074P2074
void CanClearRxErrors();  V   36 :f2075P2075
void CanSend(int8* data);  V   37 :f2076V969P2076
void CanResetSegmentedRecvStats();  V   38 :f2078P2078
CAN_SEGMENTED_RECV_MODE CanIsSegmentedRecvComplete();  V   39 :f2079P2079
  V   40 :
//------------------------------------------------------------------------------  V   41 :
// Function Name: VehSendCAN  V   42 :
// Description: Send the vehicle a message using CAN.   V   43 :
// Parameters:    V   44 :
// Output Parameters:  V   45 :
// Return Values:   V   46 :
//------------------------------------------------------------------------------  V   47 :
void VehSendCAN()  V   48 :f1853
{  V   49 :{2196
	// only call init when the CAN mode changes	or someone forces  V   50 :
    if (gLastCmd != gCurrentCmd || gFlags.forceInitCAN)  V   51 :
	{  V   52 :
		gFlags.forceInitCAN = FALSE;  V   53 :{2202
        gFlags.canModeChanged = TRUE;  V   54 :
        CanInit();  V   55 :
	}  V   56 :}2203
    else  V   57 :
    {  V   58 :
        gFlags.canModeChanged = FALSE;  V   59 :{2205
    }  V   60 :}2206
	  V   61 :
	// extract host indentifer from host message  V   62 :
	gIdentifier = StrToInt32(&gHostBuf[2]);  V   63 :
	  V   64 :
	// send host message to vehicle using CAN, only if not a listen only cmd  V   65 :
	if (!IsCmdListen(gCurrentCmd))   V   66 :
		CanSend(&gHostBuf[6]);  V   67 :
}  V   68 :}2209
  V   69 :
//------------------------------------------------------------------------------  V   70 :
// Function Name: VehRecvCAN  V   71 :
// Description: Receive a message using CAN.  V   72 :
//  V   73 :
//	This routine obtains each FirstFrame message from the ECU(s), if any, and   V   74 :
//	responds with to the ECU with a FlowControl	message automatically without   V   75 :
//	intervention from the host. The FirstFrame tells the adapter how many more   V   76 :
//	bytes to expect	in ConsecutiveFrame(s) to follow. This routine waits for  V   77 :
//  all the bytes to arrive via ConsecutiveFrame(s) before returning.  V   78 :
//  V   79 :
//	All	FirstFrame and SingleFrame from all ECUs must arrive in 50mS. Then the   V   80 :
//	adapter must wait up to 1S (N_Cr) for reception of the next ConsecutiveFrame.  V   81 :
//  V   82 :
//	This routine polls for CAN responses and does not use RX interrupts.  V   83 :
// Parameters:    V   84 :
// Output Parameters:  V   85 :
// Return Values:   V   86 :
//------------------------------------------------------------------------------  V   87 :
void VehRecvCAN()  V   88 :f1854
{  V   89 :{2210
	int8 FLOW_CONTROL_MSG[8] = { 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };  V   90 :V972
    int16 recvTimeout;		  V   91 :V973
    int32 totalRecvTimeout;	   // J1979 P2can timeout  V   92 :V974
	int32 totalErrorTimeout;   // ISO 15765-2 N_Cr timeout  V   93 :V975
    int32 newMessageID;			  V   94 :V976
    int8 newMessageLen;  V   95 :V977
    CAN_RX_MSG_FLAGS newMessageFlags;  V   96 :V978
	int8 ecu;  V   97 :V979
	int16 elapsedTime;  V   98 :V980
	int32 firstRespECU;  V   99 :V981
  V  100 :
    recvTimeout = HstGetTicks();  V  101 :
	totalRecvTimeout = 0;  V  102 :
	totalErrorTimeout = 0;  V  103 :
	CanResetSegmentedRecvStats();  V  104 :
  V  105 :
    while (1)  V  106 :
	{  V  107 :
		elapsedTime = (int32)HstElapsedTime(recvTimeout);  V  108 :{2214
        recvTimeout += elapsedTime;  V  109 :
        totalRecvTimeout += elapsedTime;  V  110 :
        totalErrorTimeout += elapsedTime;  V  111 :
  V  112 :
		// if CAN error ISR sets an error while receiving messages then exit  V  113 :
		if (gError)    V  114 :
			return;  V  115 :
  V  116 :
		// else if timer exceeds P2can and no segmented messages are pending then exit  V  117 :
        else if (totalRecvTimeout > gP2can && CanIsSegmentedRecvComplete() != RECV_PENDING)    V  118 :
			break;  V  119 :
  V  120 :
		// if time since last message exceeds 1 second (ISO 15765-2 N_Cr) while waiting for a segmented   V  121 :
		// message (i.e. ConsecutiveFrame) to arrive then exit  V  122 :
        else if (totalErrorTimeout > HST_ONE_S && CanIsSegmentedRecvComplete() == RECV_PENDING)  V  123 :
			break;  V  124 :
      V  125 :
        // receive 1 CAN 8-byte message   V  126 :
        if (CANReceiveMessage(&newMessageID, &gVehicleBuf[gVehicleBufCnt][3],   V  127 :
	                          &newMessageLen, &newMessageFlags))  V  128 :
        {	  V  129 :
			// keep resetting CF error timeout as long as messages are arriving  V  130 :
			totalErrorTimeout = 0;  V  131 :{2229
  V  132 :
            if (newMessageFlags & CAN_RX_OVERFLOW)  V  133 :
		    {  V  134 :
    		    gError = ERR_CAN_RX_OVERFLOW;  V  135 :{2232
    		    return;  V  136 :
		    }  V  137 :}2233
			else if (newMessageLen != 8)  V  138 :
			{  V  139 :
				// some vehicle's like the Pontiac G6 2005 returns non-8 byte messages (which is a violation of  V  140 :
				// the specs. So just ignore if not exactly 8  V  141 :
			    //gError = ERR_CAN_RX_MESSAGE_LEN_WRONG;  TBD test  V  142 :
				//return;  V  143 :
			}  V  144 :{2237}2238
  V  145 :
			// save	ID of first ECU to respond  V  146 :
			if (gVehicleBufCnt == 0)  V  147 :
				firstRespECU = newMessageID;  V  148 :
			  V  149 :
			// what CAN frame type?? V  150 :
			if ((gVehicleBuf[gVehicleBufCnt][3] & 0xF0) == FIRST_FRAME)  V  151 :
			{  V  152 :
    			// if vehicle sends a FirstFrame message, respond with a FlowControl message  V  153 :
				// must send within <100mS (ISO 15765-4 N_Br)  V  154 :
			    CanSend(FLOW_CONTROL_MSG);  V  155 :{2243
			    if (gError != ERR_NONE)  V  156 :
				    return;  V  157 :
  V  158 :
				// get the data length specifying the total user bytes to receive on segmented msg  V  159 :
                gFirstFrameDataLength[gFirstFrameRespondedECUs] = (gVehicleBuf[gVehicleBufCnt][3] & 0x0F) << 8;  V  160 :
                gFirstFrameDataLength[gFirstFrameRespondedECUs] |= gVehicleBuf[gVehicleBufCnt][4];  V  161 :
			    gFirstFrameDataLength[gFirstFrameRespondedECUs] -= 6;     // FirstFrame has 6 user data bytes  V  162 :
            	gFirstFrameIdentifier[gFirstFrameRespondedECUs] = newMessageID;  V  163 :
				gFirstFrameRespondedECUs++;  V  164 :
			}  V  165 :}2246
			else if ((gVehicleBuf[gVehicleBufCnt][3] & 0xF0) == CONSECUTIVE_FRAME)  V  166 :
			{  V  167 :
				// search for received message identifier in list  V  168 :
				for (ecu=0; ecu<MAX_ECU; ecu++)  V  169 :{2250
				{  V  170 :
					if (newMessageID == gFirstFrameIdentifier[ecu])  V  171 :{2257
					{  V  172 :
						// found idendifier in list, decrement its remaining byte count  V  173 :
			    		gFirstFrameDataLength[ecu] -= 7;     // ConsecutiveFrame has, at most, 7 user data bytes  V  174 :{2260
						break;  V  175 :
					}  V  176 :}2261
				}  V  177 :}2262
			}  V  178 :}2263
  V  179 :
			// add three bytes of identifier into host message  V  180 :
            gVehicleBuf[gVehicleBufCnt][0]	= (int8)(newMessageID >> 16);  V  181 :
            gVehicleBuf[gVehicleBufCnt][1]	= (int8)(newMessageID >> 8);  V  182 :
            gVehicleBuf[gVehicleBufCnt][2]	= (int8)(newMessageID);  V  183 :
  V  184 :
			// if first response enable and not the 1st ECU, then toss this message by not  V  185 :
			// incrementing the gVehicleBufCnt below. Only accumulate messages from the  V  186 :
			// 1st ECU when host specifies 1st response cmd	  V  187 :
			if (gFlags.firstResp && firstRespECU != newMessageID)  V  188 :
				continue;  V  189 :
		  V  190 :
            // successfully obtained a message, inc buffer count  V  191 :
            if (++gVehicleBufCnt >= VEHICLE_MAX_MSGS)  V  192 :
                break;	   // all buffers full  V  193 :
				            V  194 :
            // if host wants one response message and entire segmented msg, if any, is received  V  195 :
            if (gFlags.firstResp && gFirstFrameDataLength[0] <= 0)  V  196 :
                break;  V  197 :
		}  V  198 :}2274
	}  V  199 :}2275
  V  200 :
    // if no CAN message received and no error already set  V  201 :
    if (gVehicleBufCnt == 0 && !gError)  V  202 :
	{  V  203 :
		// set error and save contents of COMSTAT register  V  204 :
	    gError = ERR_CAN_NO_RESPONSE;  V  205 :{2280
		gErrorExtraData1 = COMSTAT;  V  206 :
	}  V  207 :}2281
}  V  208 :}2282
  V  209 :
//------------------------------------------------------------------------------  V  210 :
// Function Name: CanSend  V  211 :
// Description: Send CAN message using the current interface and current   V  212 :
//  identifier.  V  213 :
// Parameters:    V  214 :
//  data - 8 OBD II frame data message to send  V  215 :
// Output Parameters:  V  216 :
// Return Values:   V  217 :
//------------------------------------------------------------------------------  V  218 :
void CanSend(BYTE* data)  V  219 :f2076V969
{  V  220 :{2283
    // is this a standard identifier message?? V  221 :
    if (IsCmdStandardId(gCurrentCmd))  V  222 :
	{  V  223 :
        // send standard id CAN message  V  224 :
	    if (!CANSendMessage(gIdentifier, data, 8, CAN_TX_PRIORITY_0    V  225 :{2287
	                                            & CAN_TX_STD_FRAME  V  226 :
                                                & CAN_TX_NO_RTR_FRAME))  V  227 :
            gError = ERR_CAN_TX_BUFFER_UNAVAIL;  V  228 :
	}  V  229 :}2290
	else  V  230 :
	{  V  231 :
        // send extended id CAN message  V  232 :
	    if (!CANSendMessage(gIdentifier, data, 8, CAN_TX_PRIORITY_0    V  233 :{2292
	                                            & CAN_TX_XTD_FRAME  V  234 :
                                                & CAN_TX_NO_RTR_FRAME))  V  235 :
            gError = ERR_CAN_TX_BUFFER_UNAVAIL;  V  236 :
	}  V  237 :}2295
}  V  238 :}2296
  V  239 :
//------------------------------------------------------------------------------  V  240 :
// Function Name: VehRecvCAN  V  241 :
// Description: Use RBX1 to double buffer RBX0.  V  242 :
// Parameters:    V  243 :
// Output Parameters:  V  244 :
// Return Values:   V  245 :
//------------------------------------------------------------------------------  V  246 :
void CanInit()  V  247 :f2074
{  V  248 :{2297
    // is this a standard id message?? V  249 :
    if (IsCmdStandardId(gCurrentCmd))  V  250 :
	{  V  251 :
	    // is this 250kb?? V  252 :
        if (IsCmd250kb(gCurrentCmd))  V  253 :{2301
		{  V  254 :
		    // 250kb standard message initialization  V  255 :
	        CANInitialize(3, 2, 8, 4, 7, CAN_CONFIG_PHSEG2_PRG_ON   V  256 :{2304
                                         & CAN_CONFIG_SAMPLE_THRICE  V  257 :
                                         & CAN_CONFIG_VALID_STD_MSG  V  258 :
                                         & CAN_CONFIG_DBL_BUFFER_ON);	  V  259 :
		}  V  260 :}2305
		else  V  261 :
		{  V  262 :
		    // 500kb standard message initialization  V  263 :
            CANInitialize(3, 1, 8, 4, 7, CAN_CONFIG_PHSEG2_PRG_ON   V  264 :{2307
                                        & CAN_CONFIG_SAMPLE_THRICE  V  265 :
                                        & CAN_CONFIG_VALID_STD_MSG  V  266 :
                                        & CAN_CONFIG_DBL_BUFFER_ON);  V  267 :
		}  V  268 :}2308
									   V  269 :
        // Set CAN module back into the configuration mode									       V  270 :
	    CANSetOperationMode(CAN_OP_MODE_CONFIG);		  V  271 :
					  V  272 :
		// 11bit ECU Identifier range 0x7e8 to 0x7ef  V  273 :
	    CANSetMask(CAN_MASK_B1, gStdMask, CAN_CONFIG_STD_MSG);    V  274 :
	    CANSetFilter(CAN_FILTER_B1_F1, gStdFilter, CAN_CONFIG_STD_MSG);  V  275 :
  V  276 :
		// disable all other filters and masks by setting them to opposite  V  277 :
		// of the used mask (i.e. used mask is STD, then unused set to XTD)  V  278 :
	    CANSetMask(CAN_MASK_B2, 0xFFFFFFFF, CAN_CONFIG_STD_MSG);  V  279 :
	    CANSetFilter(CAN_FILTER_B1_F2, 0x00000000, CAN_CONFIG_XTD_MSG);  V  280 :
	    CANSetFilter(CAN_FILTER_B2_F1, 0x00000000, CAN_CONFIG_XTD_MSG);  V  281 :
	    CANSetFilter(CAN_FILTER_B2_F2, 0x00000000, CAN_CONFIG_XTD_MSG);  V  282 :
	    CANSetFilter(CAN_FILTER_B2_F3, 0x00000000, CAN_CONFIG_XTD_MSG);  V  283 :
	    CANSetFilter(CAN_FILTER_B2_F4, 0x00000000, CAN_CONFIG_XTD_MSG);  V  284 :
	}  V  285 :}2309
	// else extended message  V  286 :
	else  V  287 :
	{  V  288 :
	    // is this 250kb?? V  289 :
        if (IsCmd250kb(gCurrentCmd))  V  290 :{2311
		{  V  291 :
		    // 250kb extended message initialization  V  292 :
	        CANInitialize(3, 2, 8, 4, 7, CAN_CONFIG_PHSEG2_PRG_ON   V  293 :{2314
                                         & CAN_CONFIG_SAMPLE_THRICE  V  294 :
                                         & CAN_CONFIG_VALID_XTD_MSG  V  295 :
                                         & CAN_CONFIG_DBL_BUFFER_ON);	  V  296 :
		}  V  297 :}2315
		else  V  298 :
		{  V  299 :
		    // 500kb extended message initialization  V  300 :
            CANInitialize(3, 1, 8, 4, 7, CAN_CONFIG_PHSEG2_PRG_ON   V  301 :{2317
                                        & CAN_CONFIG_SAMPLE_THRICE  V  302 :
                                        & CAN_CONFIG_VALID_XTD_MSG  V  303 :
                                        & CAN_CONFIG_DBL_BUFFER_ON);  V  304 :
		}  V  305 :}2318
										  V  306 :
        // Set CAN module back into the configuration mode										  V  307 :
        CANSetOperationMode(CAN_OP_MODE_CONFIG);					  V  308 :
  V  309 :
        // 29bit ECU Identifier range 18daf100 to 18daf1ff  V  310 :
		CANSetMask(CAN_MASK_B1, gXtdMask, CAN_CONFIG_XTD_MSG);	  V  311 :
        CANSetFilter(CAN_FILTER_B1_F1, gXtdFilter, CAN_CONFIG_XTD_MSG);  V  312 :
  V  313 :
		// disable all other filters and masks by setting them to opposite  V  314 :
		// of the used mask (i.e. used mask is STD, then unused set to XTD)  V  315 :
	    CANSetMask(CAN_MASK_B2, 0xFFFFFFFF, CAN_CONFIG_XTD_MSG);  V  316 :
	    CANSetFilter(CAN_FILTER_B1_F2, 0x00000000, CAN_CONFIG_STD_MSG);  V  317 :
	    CANSetFilter(CAN_FILTER_B2_F1, 0x00000000, CAN_CONFIG_STD_MSG);  V  318 :
	    CANSetFilter(CAN_FILTER_B2_F2, 0x00000000, CAN_CONFIG_STD_MSG);  V  319 :
	    CANSetFilter(CAN_FILTER_B2_F3, 0x00000000, CAN_CONFIG_STD_MSG);  V  320 :
	    CANSetFilter(CAN_FILTER_B2_F4, 0x00000000, CAN_CONFIG_STD_MSG);  V  321 :
	}  V  322 :}2319
	  V  323 :
	// Set CAN module for normal RX & TX operation  V  324 :
	CANSetOperationMode(CAN_OP_MODE_NORMAL);  V  325 :
  V  326 :
	// enable CAN output driver  V  327 :
   	output_low(PIN_C3);  V  328 :
}  V  329 :}2320
  V  330 :
//------------------------------------------------------------------------------  V  331 :
// Function Name: CanDisable  V  332 :
// Description: Disable CAN module, abort messages, and disable the external   V  333 :
//	CAN hardware driver chip.  V  334 :
// Parameters:    V  335 :
// Output Parameters:  V  336 :
// Return Values:   V  337 :
//------------------------------------------------------------------------------  V  338 :
void CanDisable()  V  339 :f1858
{  V  340 :{2321
	// disable the external CAN output driver MCP2551 chip. This is required  V  341 :
	// because the CAN module in sleep or listen is in the wrong logic state  V  342 :
	// causing other CAN modules on the bus to complain about being clobbered  V  343 :
   	output_high(PIN_C3);  V  344 :
  V  345 :
	// abort all pending messages, if any  V  346 :
	CANAbortAll();  V  347 :
  V  348 :
	// put CAN module to sleep  V  349 :
 	// This call makes the adapter lockup sometimes (e.g. Toyota Tacoma 2006), offers no value so no need to use  V  350 :
	//CANSetOperationModeNoWait(CAN_OP_MODE_SLEEP);  V  351 :
  V  352 :
	// on next CAN message, module needs to be reinitialized  V  353 :
	gFlags.forceInitCAN = TRUE;  V  354 :
}  V  355 :}2323
  V  356 :
//------------------------------------------------------------------------------  V  357 :
// Function Name: CanEmptyRxBuffer  V  358 :
// Description: Just discard any messages within the RX buffer.  V  359 :
// Parameters:    V  360 :
// Output Parameters:  V  361 :
// Return Values:   V  362 :
//------------------------------------------------------------------------------  V  363 :
void CanEmptyRxBuffer()  V  364 :f1855
{  V  365 :{2324
    int32 newMessageID;			  V  366 :V982
    int8 newMessageLen;  V  367 :V983
    CAN_RX_MSG_FLAGS newMessageFlags;  V  368 :V984
	  V  369 :
    if (IsCmdCAN(gLastCmd))  V  370 :
        // receive and discard a CAN message, if any  V  371 :
        CANReceiveMessage(&newMessageID, 0, &newMessageLen, &newMessageFlags);  V  372 :
}  V  373 :}2328
  V  374 :
//------------------------------------------------------------------------------  V  375 :
// Function Name: CanSetMaskFilter  V  376 :
// Description: Set the STD or XTD mask and filter based upon host message.  V  377 :
// Parameters:    V  378 :
// Output Parameters:  V  379 :
// Return Values:   V  380 :
//------------------------------------------------------------------------------  V  381 :
void CanSetMaskFilter()  V  382 :f1856
{  V  383 :{2329
	gFlags.forceInitCAN = TRUE;  V  384 :
  V  385 :
	if (gHostBuf[IDX_HOST_COMMAND] == CMD_CAN_SET_STD_MASK_FILTER)  V  386 :
	{  V  387 :
		gStdMask = StrToInt32(&gHostBuf[2]);  V  388 :{2333
		gStdFilter = StrToInt32(&gHostBuf[6]);  V  389 :
	}  V  390 :}2334
	else  V  391 :
	{  V  392 :
		gXtdMask = StrToInt32(&gHostBuf[2]);  V  393 :{2336
		gXtdFilter = StrToInt32(&gHostBuf[6]);  V  394 :
	}  V  395 :}2337
}  V  396 :}2338
  V  397 :
//------------------------------------------------------------------------------  V  398 :
// Function Name: CanSetP2CanTimeout  V  399 :
// Description: Set P2can timeout value to used to indicate how long the adapter  V  400 :
//	should wait for incoming ECU messages.  V  401 :
//  V  402 :
//  Host should never send any mS value larger than 214748mS otherwise coversion  V  403 :
//	to ticks with MS_TO_TICKS math will overflow.  V  404 :
// Parameters:    V  405 :
// Output Parameters:  V  406 :
// Return Values:   V  407 :
//------------------------------------------------------------------------------  V  408 :
void CanSetP2CanTimeout()  V  409 :f1857
{  V  410 :{2339
	// get host's new mS value  V  411 :
	gP2can = StrToInt32(&gHostBuf[2]);  V  412 :
  V  413 :
	// convert mS to timer ticks   V  414 :
	gP2can = MS_TO_TICKS(gP2can);  V  415 :
}		     V  416 :}2341
  V  417 :
//------------------------------------------------------------------------------  V  418 :
// Function Name: CANClearRxErrors  V  419 :
// Description: Clears any errors and resets the RX receive buffer status.  V  420 :
//	NOTE: This routine not tested!  V  421 :
// Parameters:    V  422 :
// Output Parameters:  V  423 :
// Return Values:   V  424 :
//------------------------------------------------------------------------------  V  425 :
void CanClearRxErrors()  V  426 :f2075
{  V  427 :{2342
    // Set CAN module back into the configuration mode									       V  428 :
	CANSetOperationMode(CAN_OP_MODE_CONFIG);		  V  429 :
	  V  430 :
    RXB0CON_RXFUL = 0;  V  431 :
    RXB1CON_RXFUL = 0;  V  432 :
    COMSTAT_RX0OVFL = 0;  V  433 :
    COMSTAT_RX1OVFL = 0;  V  434 :
    PIR3_RXB0IF = 0;  V  435 :
    PIR3_RXB1IF = 0;  V  436 :
	  V  437 :
	// Set CAN module for normal RX & TX operation  V  438 :
	CANSetOperationMode(CAN_OP_MODE_NORMAL);					  V  439 :
}  V  440 :}2344
  V  441 :
//------------------------------------------------------------------------------  V  442 :
// Function Name: CanResetSegmentedRecvStats  V  443 :
// Description: Reset the segmented message tracking variables.  V  444 :
// Parameters:   V  445 :
// Output Parameters:  V  446 :
// Return Values:   V  447 :
//------------------------------------------------------------------------------  V  448 :
void CanResetSegmentedRecvStats()  V  449 :f2078
{  V  450 :{2345
	gFirstFrameRespondedECUs = 0;  V  451 :
	gFirstFrameDataLength[0] = 0;  // only the 1st one reset to 0 required  V  452 :
}  V  453 :}2347
  V  454 :
//------------------------------------------------------------------------------  V  455 :
// Function Name: CanIsSegmentedRecvComplete  V  456 :
// Description: Returns the status of the segmented message receive (i.e.   V  457 :
//	ConsecutiveFrames).   V  458 :
// Parameters:   V  459 :
// Output Parameters:  V  460 :
// Return Values: RECV_NONE if no consecutive messages are being tracked,   V  461 :
//	RECV_PENDING if one or more messages are still arriving, and RECV_COMPLETE  V  462 :
//	when all segemented messages have arrived.   V  463 :
//------------------------------------------------------------------------------  V  464 :
int8 CanIsSegmentedRecvComplete()  V  465 :f2079
{  V  466 :{2348
	int8 cnt;  V  467 :V985
	if (gFirstFrameRespondedECUs == 0)  V  468 :
		return RECV_NONE;  V  469 :
  V  470 :
	// search each segmented message byte count in list to check if all are <= 0   V  471 :
	for (cnt=0; cnt<gFirstFrameRespondedECUs; cnt++)  V  472 :
	{  V  473 :
		if (gFirstFrameDataLength[cnt] > 0)  V  474 :{2358
			return RECV_PENDING;  V  475 :
	}  V  476 :}2361
	return RECV_COMPLETE;  V  477 :
}  V  478 :}2362
  V  479 :
//------------------------------------------------------------------------------  V  480 :
// Function Name: CanErrorIsr  V  481 :
// Description: Interrupt function to handle CAN bus errors. Sets the global  V  482 :
//	error flag to be handled by the main loop. Stops the CAN module from  V  483 :
//	continuing to retry transmissions.   V  484 :
// Parameters:   V  485 :
// Output Parameters:  V  486 :
// Return Values:   V  487 :
//------------------------------------------------------------------------------  V  488 :
#INT_CANERR  V  489 :
void CanErrorIsr()  V  490 :f2088
{  V  491 :{2364
	// if only warning bits are set, just return and ignore  V  492 :
	//if (!(gErrorExtraData1 & 0xF8))  V  493 :
	//	return;  V  494 :
  V  495 :
	if (gError == ERR_NONE)  V  496 :
	{  V  497 :
		// set error and save contents of COMSTAT register  V  498 :
		gError = ERR_CAN_ERROR_INTERRUPT;  V  499 :{2368
		gErrorExtraData1 = COMSTAT;  V  500 :
	}  V  501 :}2369
	  V  502 :
	CanDisable();  V  503 :
	  V  504 :
	// clear any overflow errors, if any  V  505 :
	bit_clear(COMSTAT, RXB0OVFL);  V  506 :
	bit_clear(COMSTAT, RXB1OVFL);  V  507 :
}  V  508 :}2370
  V  509 :
//------------------------------------------------------------------------------  V  510 :
// Function Name: CanIrxIsr  V  511 :
// Description: Interrupt function to handle CAN message TX and RX errors. Sets   V  512 :
//	the global error flag to be handled by the main loop. Stops the CAN module from  V  513 :
//	continuing to retry transmissions.  V  514 :
//  V  515 :
//	This ISR fires on TX and RX errors. This ISR is used during auto-detection.  V  516 :
//	This ISRs job is to get off the bus as soon as possible and not clobber   V  517 :
//	other vehicle's	communcation. When auto-detecting, we may transmit at the   V  518 :
//	wrong speed and	trash other communications. If we didn't get off the bus   V  519 :
//	fast enough on the the Mazda 6 2004 we'd generate U0100 and U0121 errors.  V  520 :
// Parameters:   V  521 :
// Output Parameters:  V  522 :
// Return Values:   V  523 :
//------------------------------------------------------------------------------  V  524 :
#INT_CANIRX  V  525 :
void CanIrxIsr()  V  526 :f2089
{  V  527 :{2372
	// only FBGO commands will do a fast bus get off  V  528 :
    if (!IsCmdFBGO(gCurrentCmd))  V  529 :
	{  V  530 :
    	// acknowledge interrupt by clearing status  V  531 :
		bit_clear(PIR3, IRXIF);   V  532 :{2376
        return;  V  533 :
	}   V  534 :}2377
  V  535 :
	if (gError == ERR_NONE)  V  536 :
	{  V  537 :
	    gError = ERR_CAN_INVALID_MSG_INTERRUPT;  V  538 :{2380
		gErrorExtraData1 = TXB0CON;  V  539 :
		gErrorExtraData2 = TXB1CON;  V  540 :
		gErrorExtraData3 = TXB2CON;  V  541 :
	}  V  542 :}2381
                V  543 :
	CanDisable();  V  544 :
      V  545 :
    // acknowledge interrupt by clearing status  V  546 :
    bit_clear(PIR3, IRXIF);  V  547 :
}   V  548 :}2382
  V  549 :
//------------------------------------------------------------------------------  V  550 :
// Function Name: CanRx1 CanRx2  V  551 :
// Description: CAN receive interrupt functions. When the adapter is idle and  V  552 :
//	not actively obtaining a CAN message, then just discard any received messages.  V  553 :
//  One of these ISR(s) will fire every time a CAN message arrives. However,  V  554 :
// 	the adapter receives messages by polling when servicing a host request.  V  555 :
//	Therefore, these ISRs must be disabled during receive.  V  556 :
// Parameters:   V  557 :
// Output Parameters:  V  558 :
// Return Values:   V  559 :
//------------------------------------------------------------------------------  V  560 :
#INT_CANRX1  V  561 :
void CanRx1()  V  562 :f2090
{  V  563 :{2384
	CanEmptyRxBuffer();    V  564 :
}  V  565 :}2386
#INT_CANRX0  V  566 :
void CanRx0()  V  567 :f2091
{  V  568 :{2388
	CanEmptyRxBuffer();    V  569 :
}  V  570 :}2390
  V  571 :
  V  572 :
  V  573 :
  V  574 :
  V  575 :
  V  576 :
  V  577 :
  V  578 :
  V  579 :E
 V  579 :
#include "Timer.c" A   50 :
 //------------------------------------------------------------------------------  [    1 :I26
// File: Timer  [    2 :
//  [    3 :
// Purpose: High speed timer (HST) routines.   [    4 :
//  [    5 :
// Change History:  [    6 :
// Date		Author		Description  [    7 :
//          Lafreniere	Created  [    8 :
//------------------------------------------------------------------------------  [    9 :
#include "Timer.h" [   10 :
 //------------------------------------------------------------------------------  G    1 :I6
// File: Timer  G    2 :
//  G    3 :
// Purpose: High speed timer (HST) routines.   G    4 :
//  G    5 :
// Change History:  G    6 :
// Date		Author		Description  G    7 :
//          Lafreniere	Created  G    8 :
//------------------------------------------------------------------------------  G    9 :
#ifndef TIMER_H  G   10 :
#define TIMER_H  G   11 :
  G   12 :
#define TIMER1_TIMEOUT          0     // 1.6uS per tick with div set to 8  G   13 :
#define MS_TO_TICKS(mS) 		((mS * 10000) / 16)	  // 1.6uS per tick  G   14 :
  G   15 :
// max 16-bit number  G   16 :
#define HST_TWO_MS              1250  G   17 :
#define HST_TEN_MS              6250  G   18 :
#define HST_TWENTY_FIVE_MS      15625  G   19 :
#define HST_FIFTY_MS            31250  G   20 :
#define HST_FIVE_HUNDRED_MS		312500	// NOTE: this number exceeds 16-bit timer and must be used with Int32  G   21 :
#define HST_ONE_S				625000	// NOTE: this number exceeds 16-bit timer and must be used with Int32  G   22 :
  G   23 :
typedef int16 HstTimer; //TBD DEBUG  G   24 :
//typedef int32 HstTimer;  G   25 :
              G   26 :
HstTimer HstGetTicks(void) { return get_timer1(); }  G   27 :
BOOLEAN HstTestTimer(HstTimer timer, HstTimer ticks);  G   28 :
BOOLEAN HstTestTimerRetrig(HstTimer *timer, HstTimer ticks);  G   29 :
HstTimer HstElapsedTime(HstTimer timer);  G   30 :
  G   31 :
#endif  G   32 :E
 G   32 :
  [   11 :
//------------------------------------------------------------------------------  [   12 :
// Function Name: HstTestTimer  [   13 :
// Description: Test a timer for timeout.   [   14 :
// Parameters: timer - A timer that was read at start of delay.  [   15 :
//	    ticks - Number of ticks to test.  [   16 :
// Output Parameters:  [   17 :
// Return Values: If the number of ticks in 'ticks' has passed since the   [   18 :
//	    initial reading of 'timer' return TRUE, else return	FALSE.  [   19 :
//------------------------------------------------------------------------------  [   20 :
BOOLEAN HstTestTimer(HstTimer timer, HstTimer ticks)  [   21 :f1500V249V250
{  [   22 :{2391
    // check to see if 'ticks' number of ticks have passed  [   23 :
    if (get_timer1() - timer >= ticks)  [   24 :
        return TRUE;  [   25 :
    else  [   26 :
        return FALSE;  [   27 :
}  [   28 :}2397
  [   29 :
//------------------------------------------------------------------------------  [   30 :
// Function Name: HstTestTimerRetrig  [   31 :
// Description: Test a timer for timeout, retrigger the timer.   [   32 :
//	    This routine will then retrigger the given timer, so that subsequent reads   [   33 :
//	    will again read false until the number of ticks in 'ticks' has again passed.  [   34 :
// Parameters: timer - Pointer to a timer that was read at start of delay.  [   35 :
//	    ticks - Number of ticks to test.  [   36 :
// Output Parameters:  [   37 :
// Return Values: If the number of ticks in 'ticks' has passed since the   [   38 :
//	    initial reading of 'timer' return TRUE, else return	FALSE.  [   39 :
//------------------------------------------------------------------------------  [   40 :
BOOLEAN HstTestTimerRetrig(HstTimer *timer, HstTimer ticks)  [   41 :f1503V252V253
{  [   42 :{2398
    // check to see if 'ticks' number of ticks have passed  [   43 :
    if (get_timer1() - *timer >= ticks)  [   44 :
    {     [   45 :
    	*timer += ticks;      // bring Timer up to date without accumulative errors  [   46 :{2403
        return TRUE;  [   47 :
    }  [   48 :}2404
    else  [   49 :
        return FALSE;  [   50 :
}  [   51 :}2406
  [   52 :
//-----------------------------------------------------------------------------  [   53 :
// Function Name: HstElapsedTime  [   54 :
// Description: Calculates the elapsed time.   [   55 :
// Parameters: timer - Pointer to a timer that was read at start of delay.  [   56 :
// Output Parameters:  [   57 :
// Return Values: The elapsed time in ticks.   [   58 :
//------------------------------------------------------------------------------  [   59 :
HstTimer HstElapsedTime(HstTimer timer)  [   60 :f1504V255
{  [   61 :{2407
    return (get_timer1() - timer);  [   62 :
}  [   63 :}2410
  [   64 :
  [   65 :E
 [   65 :
#include "Util.c" A   51 :
 //------------------------------------------------------------------------------  \    1 :I27
// File: Util  \    2 :
//  \    3 :
// Purpose: Misc utility routines.   \    4 :
//  \    5 :
// Change History:  \    6 :
// Date		Author		Description  \    7 :
//          Lafreniere	Created  \    8 :
//------------------------------------------------------------------------------  \    9 :
#include "Util.h" \   10 :
 //------------------------------------------------------------------------------  L    1 :I11
// File: Util  L    2 :
//  L    3 :
// Purpose: Misc utility routines.   L    4 :
//  L    5 :
// Change History:  L    6 :
// Date		Author		Description  L    7 :
//          Lafreniere	Created  L    8 :
//------------------------------------------------------------------------------  L    9 :
#ifndef UTIL_H  L   10 :
#define UTIL_H  L   11 :
  L   12 :
// starting address for the 4-byte EEPOM write protect table  L   13 :
#define EEPROM_WRITE_PROTECT_TABLE_ADDR 	252  L   14 :
  L   15 :
// the logical sector size is arbitrary and has nothing to do with the PIC hardware  L   16 :
#define EEPROM_SECTOR_SIZE 	8  L   17 :
  L   18 :
void ReadEeprom();  L   19 :
void ReadEepromLocal(int8 sector);  L   20 :
void WriteEeprom();  L   21 :
int8 IsEepromSectorWriteProtected(int8 sector);  L   22 :
int32 ReadEepromSectorWriteProtectTable();  L   23 :
void WriteEerpomSectorWriteProtectTable(int32 writeProtectBits);  L   24 :
void init_ports();  L   25 :
void Bus_If_Init(void);  L   26 :
void DecryptBlock(int8 *outbfr, int8 *inbfr);  L   27 :
int8 IsCmdCAN(int8 cmd);  L   28 :
int8 IsCmdLocal(int8 cmd);  L   29 :
int8 IsCmdFBGO(int8 cmd);  L   30 :
int8 IsCmdListen(int8 cmd);  L   31 :
int8 IsCmdNoResponse(int8 cmd);  L   32 :
int8 IsCmdFirstResp(int8 cmd);  L   33 :
int8 IsCmdStandardId(int8 cmd);  L   34 :
int8 IsCmd250kb(int8 cmd);  L   35 :
int8 checksum(int8* pMsg, int8 size);  L   36 :
int8 crc8(int8* buffer, int8 count);  L   37 :
int32 StrToInt32(int8* str);  L   38 :
int8 TraceStr(int8* pMsg, int8 size);  L   39 :
int8 Trace(int8 msg);  L   40 :
  L   41 :
#endif  L   42 :E
 L   42 :
  \   11 :
// must be a valid mask, not just any old number. Use different masks for different   \   12 :
// manufacturers.  \   13 :
#define LFSR_MASK 0xB38C    // Softworks    		  \   14 :
//#define LFSR_MASK 0x9C63    // Nology  \   15 :
  \   16 :
// decryption block size (not including 2-byte Lfsr pad)  \   17 :
#define BLOCK_SIZE 4				  \   18 :
  \   19 :
// trace debug port used to view debug chars on HyperTermial   \   20 :
#use rs232(baud=9600,xmit=PIN_B4,parity=n,bits=8,stream=STREAM_DEBUG)  \   21 :V992
  \   22 :
//------------------------------------------------------------------------------  \   23 :
// Function Name: init_ports  \   24 :
// Description: Initialize all PIC ports to power-on state.  \   25 :
// Parameters:   \   26 :
// Output Parameters:  \   27 :
// Return Values:   \   28 :
//------------------------------------------------------------------------------  \   29 :
void init_ports()   \   30 :f1564
{  \   31 :{2442
	set_tris_a ( 0x55 ); 	// This goes into TRISA, a 1 sets a port pin for input  \   32 :
							// See hardware.h for definitions of I/O pins & TRIS bits  \   33 :
	set_tris_b ( 0x28 );	// This goes into TRISB, a 1 sets a port pin for input  \   34 :
	set_tris_c ( 0xB7 );	// This goes into TRISC, a 1 sets a port pin for input  \   35 :
	#USE FAST_IO(a)			// forces compiler to not set port directions on every port write  \   36 :
	#USE FAST_IO(b)			// forces compiler to not set port directions on every port write  \   37 :
	#USE FAST_IO(c)			// forces compiler to not set port directions on every port write  \   38 :
   \   39 :
	port_b_pullups(TRUE);	// disable global Port B pull up resistors   \   40 :
							// set all bus outputs inactive (PWM, VPW, ISO & CAN)  \   41 :
	output_a(0x08);			// PWM_P_OUT RA3 = 1  \   42 :
							// PWM_N_OUT RA0 = 0  \   43 :
  \   44 :
	output_b(0x00);			// VPW_4X	 RB0 = 0  \   45 :
							// VPW_OUT   RB1 = 0  \   46 :
							// CAN_TX	 RB2 = 0  \   47 :
							// ISO_K_TX  RB6 = 0  \   48 :
							// ISO_L_TX  RB7 = 0  \   49 :
}  \   50 :}2444
  \   51 :
//------------------------------------------------------------------------------  \   52 :
// Function Name: IsEepromSectorWriteProtected  \   53 :
// Description: Checks if a EEPROM sector is write protected. The write-protect  \   54 :
// 	bits are stored at the end of the 256 byte EEPROM range.    \   55 :
// Parameters: sector - A value from 0 to 30 representing a sector number.  \   56 :
// Output Parameters:  \   57 :
// Return Values: 1 if write protected, 0 otherwise.  \   58 :
//------------------------------------------------------------------------------  \   59 :
int8 IsEepromSectorWriteProtected(int8 sector)  \   60 :f1560V310
{  \   61 :{2445
	int32 writeProtectBits;  \   62 :V994
  \   63 :
	writeProtectBits = ReadEepromSectorWriteProtectTable();  \   64 :
  \   65 :
	// a 1 in the EEPROM bit location within the table means not-write protected,   \   66 :
	// a 0 means protected  \   67 :
	writeProtectBits = writeProtectBits >> sector;  \   68 :
	if (writeProtectBits & 1)  \   69 :
		return 0;  \   70 :
	else  \   71 :
		return 1;  \   72 :
}  \   73 :}2450
  \   74 :
//------------------------------------------------------------------------------  \   75 :
// Function Name: ReadEepromSectorWriteProtectTable  \   76 :
// Description: Reads the 4-byte write-protect table. Each bit within the table  \   77 :
//  represents 1 sector (except the last location which is not used). Only  \   78 :
// 	31 sectors, so 31 bits to represent a write-protect state for each of those  \   79 :
//	sectors.   \   80 :
// Parameters:   \   81 :
// Output Parameters:  \   82 :
// Return Values: The write-protect table as a int32.   \   83 :
//------------------------------------------------------------------------------  \   84 :
int32 ReadEepromSectorWriteProtectTable()  \   85 :f1561
{  \   86 :{2451
	int8 cnt;  \   87 :V995
	int32 writeProtectBits;  \   88 :V996
	for (cnt = 0; cnt<4; cnt++)  \   89 :
		*(&writeProtectBits + cnt) = read_eeprom(EEPROM_WRITE_PROTECT_TABLE_ADDR + cnt);  \   90 :
	return writeProtectBits;  \   91 :
}  \   92 :}2459
  \   93 :
//------------------------------------------------------------------------------  \   94 :
// Function Name: WriteEerpomSectorWriteProtectTable  \   95 :
// Description: Write the 4-byte write-protect table.   \   96 :
// Parameters: writeProtectBits - a 32-bit integer representing the write-protect  \   97 :
//	sector table status.  \   98 :
// Output Parameters:  \   99 :
// Return Values:   \  100 :
//------------------------------------------------------------------------------  \  101 :
void WriteEerpomSectorWriteProtectTable(int32 writeProtectBits)  \  102 :f1562V313
{  \  103 :{2460
	int8 cnt;  \  104 :V997
	for (cnt = 0; cnt<4; cnt++)  \  105 :
		write_eeprom(EEPROM_WRITE_PROTECT_TABLE_ADDR + cnt, *(&writeProtectBits + cnt));  \  106 :
}  \  107 :}2469
  \  108 :
//------------------------------------------------------------------------------  \  109 :
// Function Name: ReadEepromLocal  \  110 :
// Description: Read PIC EEPROM and do not send to host. EEPROM data will be located in  \  111 :
//  gVehicleBuf[0][0], eVehicleBuf[0][EEPROM_SECTOR_SIZE].  \  112 :
//  \  113 :
//	For Bluetooth, EEPROM sector 0 and sector 1 PIC must be programmed with the Bluetooth   \  114 :
//  address used by the adapter test fixture. The Bluetooth address is 12 bytes and is used  \  115 :
//  to automatically pair and connect to the Windows test fixture. This prevents having  \  116 :
//  to manually pair each Bluetooth adapter to the PC during production. Once production  \  117 :
//  is done, the test fixture software writes all FF's to this location to prevent the   \  118 :
//  automatic pairing when used by the customer. The PIC programmer software is used  \  119 :
//  to modify the HEX file to add the unique 12 byte Bluetooth address and therefore  \  120 :
//  can be changed without recompiling the program.  \  121 :
// Parameters:   \  122 :
// Output Parameters:  \  123 :
// Return Values:   \  124 :
//------------------------------------------------------------------------------  \  125 :
void ReadEepromLocal(int8 sector)  \  126 :f1557V307
{  \  127 :{2470
	// put the sector in the host buf used by the ReadEeprom() function  \  128 :
	gHostBuf[2] = sector;  \  129 :
}  \  130 :}2472
  \  131 :
//------------------------------------------------------------------------------  \  132 :
// Function Name: ReadEeprom  \  133 :
// Description: Read PIC EEPROM and send to host.   \  134 :
//	The PIC has 256 bytes of EEPROM. 248 bytes can be accessed by the host. The  \  135 :
//	space is logically broken into 31 8-byte sections. The last 8-bytes is reserved  \  136 :
//	for bits to define whether a section is write-protected (i.e. locked) or not.  \  137 :
//	31 bits are required for the locking table, 1 bit for each section. A 1 means  \  138 :
//	the section is locked, a 0 means not-locked. Once a section is write-protected,  \  139 :
//  the host cannot reverse it.   \  140 :
//  \  141 :
//	During production, the PIC must be programmed to have the EEPROM programmed to  \  142 :
//	all locations 0xFF.  \  143 :
// Parameters:   \  144 :
// Output Parameters:  \  145 :
// Return Values:   \  146 :
//------------------------------------------------------------------------------  \  147 :
void ReadEeprom()  \  148 :f1556
{  \  149 :{2473
	int8 cnt;  \  150 :V998
	//gFlags.vehicleData = FALSE;  \  151 :
  \  152 :
	// only 31 8-byte EEPROM sectors (0 through 30) can be read  \  153 :
	if (gHostBuf[2] > 30)    \  154 :
	{  \  155 :
		gError = ERR_INVALID_NON_VOLATILE_SECTOR;  \  156 :{2477
		return;  \  157 :
	}  \  158 :}2478
  \  159 :
	// add sector number being read to buffer  \  160 :
	gVehicleBuf[0][0] = gHostBuf[2];  \  161 :
  \  162 :
	// add write-protect state to buffer  \  163 :
	if (IsEepromSectorWriteProtected(gHostBuf[2]))  \  164 :
		gVehicleBuf[0][1] = 1;  \  165 :
	else  \  166 :
		gVehicleBuf[0][1] = 0;  \  167 :
  \  168 :
	// copy 8 bytes if EEPROM data into outgoing host buffer  \  169 :
	for (cnt = 0; cnt<EEPROM_SECTOR_SIZE; cnt++)  \  170 :
		gVehicleBuf[0][cnt+2] = read_eeprom((gHostBuf[2] * EEPROM_SECTOR_SIZE) + cnt);  \  171 :
}  \  172 :}2488
  \  173 :
//------------------------------------------------------------------------------  \  174 :
// Function Name: WriteEeprom  \  175 :
// Description: Write to EEPROM values from host.   \  176 :
// Parameters:   \  177 :
// Output Parameters:  \  178 :
// Return Values:   \  179 :
//------------------------------------------------------------------------------  \  180 :
void WriteEeprom()  \  181 :f1559
{  \  182 :{2489
	int8 cnt;  \  183 :V999
	int32 writeProtectBits;  \  184 :V1000
	int32 bitLocation;  \  185 :V1001
	//gFlags.vehicleData = FALSE;  \  186 :
  \  187 :
	// only 31 8-byte EEPROM sectors (0 through 30) can be written  \  188 :
	if (gHostBuf[2] > 30)  \  189 :
	{  \  190 :
		gError = ERR_INVALID_NON_VOLATILE_SECTOR;  \  191 :{2493
		return;  \  192 :
	}  \  193 :}2494
  \  194 :
	// error check 8-byte section is not locked  \  195 :
	if (IsEepromSectorWriteProtected(gHostBuf[2]))  \  196 :
	{  \  197 :
		gError = ERR_NON_VOLATILE_SECTOR_LOCKED;  \  198 :{2497
		return;  \  199 :
	}  \  200 :}2498
  \  201 :
	// copy 8 bytes from host message into the appropriate EEPROM sector   \  202 :
	for (cnt = 0; cnt<EEPROM_SECTOR_SIZE; cnt++)  \  203 :
		write_eeprom((gHostBuf[2] * EEPROM_SECTOR_SIZE) + cnt, gHostBuf[cnt+4]);  \  204 :
  \  205 :
	// if host says to write-protect the EEPROM 8-byte section, then do it by  \  206 :
	// updating the EEPROM table.   \  207 :
	if (gHostBuf[3])  \  208 :
	{  \  209 :
		writeProtectBits = ReadEepromSectorWriteProtectTable();  \  210 :{2508
		bitLocation = 1;  \  211 :
		bitLocation = bitLocation << gHostBuf[2];  \  212 :
		writeProtectBits &= ~bitLocation;   // set 1 bit to 0. 0 means write-protected  \  213 :
		WriteEerpomSectorWriteProtectTable(writeProtectBits);	  \  214 :
	}  \  215 :}2509
  \  216 :
	// add sector number being wrote to buffer   \  217 :
	gVehicleBuf[0][0] = gHostBuf[2];  \  218 :
}  \  219 :}2510
  \  220 :
//------------------------------------------------------------------------------  \  221 :
// Function Name: Bus_If_Init  \  222 :
// Description: Bus routines, common variables & timers initialization  \  223 :
// Parameters: timeout - the timeout in 2mS increments  \  224 :
// Output Parameters:  \  225 :
// Return Values:   \  226 :
//------------------------------------------------------------------------------  \  227 :
void Bus_If_Init(void) {  \  228 :f1565{2511
	LinkFlags = 0;			// clear all local flags  \  229 :
	LinkControl = 0;  \  230 :
	BusByteCntr = 0;  \  231 :
    MaskReg = 0x80;  \  232 :
  \  233 :
	setup_timer_0( RTCC_INTERNAL | RTCC_DIV_2 );	//  intialize & start timer0 at 400ns per count  \  234 :
	setup_timer_2( T2_DIV_BY_16, 35, 16 );			//  intialize timer2 for 2ms rollover  \  235 :
}  \  236 :}2513
  \  237 :
//------------------------------------------------------------------------------  \  238 :
// Function Name: IsCmdCAN  \  239 :
// Description:  \  240 :
// Parameters: cmd - adapter command  \  241 :
// Output Parameters:  \  242 :
// Return Values: Return 1 if mode is CAN, 0 otherwise.  \  243 :
//------------------------------------------------------------------------------  \  244 :
int8 IsCmdCAN(int8 cmd)  \  245 :f1569V320
{  \  246 :{2514
    if (cmd == CMD_CAN_SI_250KB ||  \  247 :
        cmd == CMD_CAN_SI_500KB ||  \  248 :
		cmd == CMD_CAN_EI_250KB ||  \  249 :
		cmd == CMD_CAN_EI_500KB ||  \  250 :
        cmd == CMD_CAN_SI_250KB_1ST ||  \  251 :
        cmd == CMD_CAN_SI_500KB_1ST ||  \  252 :
		cmd == CMD_CAN_EI_250KB_1ST ||  \  253 :
		cmd == CMD_CAN_EI_500KB_1ST ||  \  254 :
		cmd == CMD_CAN_SI_250KB_FBGO ||  \  255 :
        cmd == CMD_CAN_SI_500KB_FBGO ||  \  256 :
		cmd == CMD_CAN_EI_250KB_FBGO ||  \  257 :
		cmd == CMD_CAN_EI_500KB_FBGO ||  \  258 :
		cmd == CMD_CAN_SI_250KB_LISTEN ||  \  259 :
        cmd == CMD_CAN_SI_500KB_LISTEN ||  \  260 :
		cmd == CMD_CAN_EI_250KB_LISTEN ||  \  261 :
		cmd == CMD_CAN_EI_500KB_LISTEN ||  \  262 :
		cmd == CMD_CAN_SI_250KB_NO_RESPONSE ||  \  263 :
        cmd == CMD_CAN_SI_500KB_NO_RESPONSE ||  \  264 :
		cmd == CMD_CAN_EI_250KB_NO_RESPONSE ||  \  265 :
		cmd == CMD_CAN_EI_500KB_NO_RESPONSE)  \  266 :
		return 1;  \  267 :
	else  \  268 :
		return 0;  \  269 :
}  \  270 :}2557
  \  271 :
//------------------------------------------------------------------------------  \  272 :
// Function Name: IsCmdFBGO  \  273 :
// Description:  \  274 :
// Parameters: cmd - adapter command  \  275 :
// Output Parameters:  \  276 :
// Return Values: Return 1 if mode is FBGO (fast bus get off), 0 otherwise.  \  277 :
//------------------------------------------------------------------------------  \  278 :
int8 IsCmdFBGO(int8 cmd)  \  279 :f1572V324
{  \  280 :{2558
	if (cmd == CMD_CAN_SI_250KB_FBGO ||  \  281 :
        cmd == CMD_CAN_SI_500KB_FBGO ||  \  282 :
		cmd == CMD_CAN_EI_250KB_FBGO ||  \  283 :
		cmd == CMD_CAN_EI_500KB_FBGO)  \  284 :
		return 1;  \  285 :
	else  \  286 :
		return 0;  \  287 :
}  \  288 :}2569
  \  289 :
//------------------------------------------------------------------------------  \  290 :
// Function Name: IsCmdListen  \  291 :
// Description:  \  292 :
// Parameters: cmd - adapter command  \  293 :
// Output Parameters:  \  294 :
// Return Values: Return 1 if mode is listen only, 0 otherwise.  \  295 :
//------------------------------------------------------------------------------  \  296 :
int8 IsCmdListen(int8 cmd)  \  297 :f1573V326
{  \  298 :{2570
	if (cmd == CMD_CAN_SI_250KB_LISTEN ||  \  299 :
        cmd == CMD_CAN_SI_500KB_LISTEN ||  \  300 :
		cmd == CMD_CAN_EI_250KB_LISTEN ||  \  301 :
		cmd == CMD_CAN_EI_500KB_LISTEN)  \  302 :
		return 1;  \  303 :
	else  \  304 :
		return 0;  \  305 :
}  \  306 :}2581
  \  307 :
//------------------------------------------------------------------------------  \  308 :
// Function Name: IsCmdNoResponse  \  309 :
// Description:  \  310 :
// Parameters: cmd - adapter command  \  311 :
// Output Parameters:  \  312 :
// Return Values: Return 1 if mode is no response type, 0 otherwise.  \  313 :
//------------------------------------------------------------------------------  \  314 :
int8 IsCmdNoResponse(int8 cmd)  \  315 :f1574V328
{  \  316 :{2582
	if (cmd == CMD_CAN_SI_250KB_NO_RESPONSE ||  \  317 :
        cmd == CMD_CAN_SI_500KB_NO_RESPONSE ||  \  318 :
		cmd == CMD_CAN_EI_250KB_NO_RESPONSE ||  \  319 :
		cmd == CMD_CAN_EI_500KB_NO_RESPONSE ||  \  320 :
		cmd == CMD_ISO_NO_RESPONSE)  \  321 :
		return 1;  \  322 :
	else  \  323 :
		return 0;  \  324 :
}  \  325 :}2595
  \  326 :
//------------------------------------------------------------------------------  \  327 :
// Function Name: IsCmdStandardId  \  328 :
// Description:	Is the CAN command a standard identifier?? \  329 :
// Parameters: cmd - adapter command  \  330 :
// Output Parameters:  \  331 :
// Return Values: Return 1 if command is standard, else extended.  \  332 :
//------------------------------------------------------------------------------  \  333 :
int8 IsCmdStandardId(int8 cmd)  \  334 :f1576V332
{  \  335 :{2596
    // is this a standard identifier message?? \  336 :
    if (cmd == CMD_CAN_SI_250KB ||  \  337 :
        cmd == CMD_CAN_SI_500KB ||  \  338 :
        cmd == CMD_CAN_SI_250KB_1ST ||  \  339 :
        cmd == CMD_CAN_SI_500KB_1ST ||  \  340 :
		cmd == CMD_CAN_SI_250KB_FBGO ||  \  341 :
        cmd == CMD_CAN_SI_500KB_FBGO ||  \  342 :
		cmd == CMD_CAN_SI_250KB_LISTEN ||  \  343 :
        cmd == CMD_CAN_SI_500KB_LISTEN ||  \  344 :
		cmd == CMD_CAN_SI_250KB_NO_RESPONSE ||  \  345 :
        cmd == CMD_CAN_SI_500KB_NO_RESPONSE)  \  346 :
		return 1;  \  347 :
	else  \  348 :
		return 0;  \  349 :
}  \  350 :}2619
  \  351 :
//------------------------------------------------------------------------------  \  352 :
// Function Name: IsCmd250kb  \  353 :
// Description:	Is the CAN command a 250kb/sec CAN message?? \  354 :
// Parameters: cmd - adapter command  \  355 :
// Output Parameters:  \  356 :
// Return Values: Return 1 if command is 250kb, else 500kb or non-CAN command.  \  357 :
//------------------------------------------------------------------------------  \  358 :
int8 IsCmd250kb(int8 cmd)  \  359 :f1577V334
{  \  360 :{2620
    // is this a 250kb message?? \  361 :
    if (cmd == CMD_CAN_SI_250KB ||  \  362 :
		cmd == CMD_CAN_EI_250KB ||  \  363 :
        cmd == CMD_CAN_SI_250KB_1ST ||  \  364 :
		cmd == CMD_CAN_EI_250KB_1ST ||  \  365 :
		cmd == CMD_CAN_SI_250KB_FBGO ||  \  366 :
		cmd == CMD_CAN_EI_250KB_FBGO ||  \  367 :
		cmd == CMD_CAN_SI_250KB_LISTEN ||  \  368 :
		cmd == CMD_CAN_EI_250KB_LISTEN ||  \  369 :
		cmd == CMD_CAN_SI_250KB_NO_RESPONSE ||  \  370 :
		cmd == CMD_CAN_EI_250KB_NO_RESPONSE)  \  371 :
		return 1;  \  372 :
	else  \  373 :
		return 0;  \  374 :
}  \  375 :}2643
  \  376 :
//------------------------------------------------------------------------------  \  377 :
// Function Name: IsCmdLocal  \  378 :
// Description:  \  379 :
// Parameters: cmd - adapter command  \  380 :
// Output Parameters:  \  381 :
// Return Values: Return 1 if command is local command, 0 otherwise.  \  382 :
//------------------------------------------------------------------------------  \  383 :
int8 IsCmdLocal(int8 cmd)  \  384 :f1571V322
{  \  385 :{2644
    if (cmd == CMD_CAN_SET_STD_MASK_FILTER ||  \  386 :
        cmd == CMD_CAN_SET_XTD_MASK_FILTER ||  \  387 :
		cmd == CMD_CAN_SET_P2_CAN_TIMEOUT ||  \  388 :
		cmd == CMD_READ_BATTERY_VOLTAGE ||  \  389 :
        cmd == CMD_UNLOCK_ADAPTER ||  \  390 :
		cmd == CMD_ISO_ENABLE_L_LINE_XMIT ||  \  391 :
		cmd == CMD_ISO_SET_9600_BAUD ||  \  392 :
		cmd == CMD_ISO_CHECKSUM_ENABLE ||  \  393 :
		cmd == CMD_ISO_5MS_BYTE_DELAY_ENABLE ||  \  394 :
		cmd == CMD_READ_EEPROM ||  \  395 :
		cmd == CMD_WRITE_EEPROM)  \  396 :
		return 1;  \  397 :
	else  \  398 :
		return 0;  \  399 :
}  \  400 :}2669
  \  401 :
//------------------------------------------------------------------------------  \  402 :
// Function Name: IsCmdFirstResp  \  403 :
// Description:  \  404 :
// Parameters: cmd - adapter command  \  405 :
// Output Parameters:  \  406 :
// Return Values: Return 1 if command is a 1st response cmd, 0 otherwise.  \  407 :
//------------------------------------------------------------------------------  \  408 :
int8 IsCmdFirstResp(int8 cmd)  \  409 :f1575V330
{  \  410 :{2670
    if (cmd == CMD_VPW_1ST_RESPONSE ||  \  411 :
        cmd == CMD_PWM_1ST_RESPONSE ||  \  412 :
        cmd == CMD_ISO_1ST_RESPONSE ||  \  413 :
        cmd == CMD_KWP_1ST_RESPONSE ||  \  414 :
        cmd == CMD_CAN_SI_250KB_1ST ||  \  415 :
	    cmd == CMD_CAN_SI_500KB_1ST ||  \  416 :
		cmd == CMD_CAN_EI_250KB_1ST ||  \  417 :
		cmd == CMD_CAN_EI_500KB_1ST )  \  418 :
		return TRUE;  \  419 :
	else  \  420 :
		return FALSE;  \  421 :
}  \  422 :}2689
  \  423 :
//------------------------------------------------------------------------------  \  424 :
// Function Name: checksum  \  425 :
// Description: Calculate a checksum over an array of chars.   \  426 :
// Parameters: pMsg - char array to compute checksum.  \  427 :
//  size - size of array  \  428 :
// Output Parameters:  \  429 :
// Return Values: computed checksum  \  430 :
//------------------------------------------------------------------------------  \  431 :
int8 checksum(int8* pMsg, int8 size)  \  432 :f1578V336V337
{  \  433 :{2690
    int8 cs=0;  \  434 :V1002
    int8 i=0;  \  435 :V1003
    for (i=0; i<size; i++)  \  436 :
        cs += pMsg[i];  \  437 :
    return cs;  \  438 :
}  \  439 :}2698
  \  440 :
//------------------------------------------------------------------------------  \  441 :
// Function Name: crc8  \  442 :
// Description: Calculate an 8-bit crc over an array of chars.   \  443 :
//  Interface definition for 8-bit CRC (cyclic redundancy check):  \  444 :
//     Polynomial:                 1D  \  445 :
//     Initial CRC register value: FF  \  446 :
//     Reflected input and output: No  \  447 :
//     Inverted final output:      Yes  \  448 :
//     CRC of string "123456789":  4B  \  449 :
// Parameters: buffer - char array to compute crc.  \  450 :
//  count - size of array  \  451 :
// Output Parameters:  \  452 :
// Return Values: computed crc  \  453 :
//------------------------------------------------------------------------------  \  454 :
int8 crc8(int8* buffer, int8 count)  \  455 :f1581V339V340
{  \  456 :{2699
    int8 crc = 0xFF;  \  457 :V1004
    int8 value;   \  458 :V1005
    int i;  \  459 :V1006
  \  460 :
    while (count--) {  \  461 :
        value = *buffer++;  \  462 :{2704
  \  463 :
        crc ^= (value << 0);  \  464 :
        for (i = 0; i < 8; i++) {  \  465 :
            if (crc & 0x80) {  \  466 :{2711
                crc = (crc << 1) ^ 0x1D;  \  467 :{2714
            }  \  468 :}2715
            else {  \  469 :
                crc <<= 1;  \  470 :{2717
            }  \  471 :}2718
        }  \  472 :}2719
    }  \  473 :}2720
    return crc ^ 0xFF;  \  474 :
}  \  475 :}2721
  \  476 :
//------------------------------------------------------------------------------  \  477 :
// Function Name: crc8  \  478 :
// Description: Extract binary long packed into a string and return a 32 bit  \  479 :
//	integer number. String is packed MSB first.  \  480 :
// Parameters: str - string must be at least 4 bytes long.  \  481 :
// Output Parameters:  \  482 :
// Return Values: extracted int32 number from string.  \  483 :
//------------------------------------------------------------------------------  \  484 :
int32 StrToInt32(int8* str)  \  485 :f1584V342
{  \  486 :{2722
	int32 l;  \  487 :V1007
    l = (int32)str[0] << 24;  \  488 :
    l |= (int32)str[1] << 16;  \  489 :
    l |= (int16)str[2] << 8;  \  490 :
    l |= str[3];  \  491 :
	return l;  \  492 :
}  \  493 :}2724
  \  494 :
//------------------------------------------------------------------------------  \  495 :
// Function Name: Decrypt  \  496 :
// Description: Decrypt a single byte using a LFSR (linear feedback shift   \  497 :
//  register).   \  498 :
// Parameters: cc - encrypted character to decrypt  \  499 :
// Output Paramters:   \  500 :
// Return Values: The decrypted character  \  501 :
//------------------------------------------------------------------------------  \  502 :
int8 Decrypt(int8 cc)  \  503 :f2101V1009
{  \  504 :{2726
/*    int8 cBit;  \  505 :
  \  506 :
    // update LFSR  \  507 :
    cBit = gLfsr & 1;  \  508 :
    gLfsr >>= 1;  \  509 :
  \  510 :
    if (cBit)  \  511 :
      gLfsr ^= LFSR_MASK;  \  512 :
  \  513 :
    // Decrypt byte  \  514 :
    gLast ^= cc ^ (int8)gLfsr ^ (int8)(gLfsr >> 8);  \  515 :
    return gLast;				// return 'Last' which is current character*/  \  516 :
}  \  517 :}2728
  \  518 :
//------------------------------------------------------------------------------  \  519 :
// Function Name: DecryptBlock  \  520 :
// Description: Decrypt BLOCK_SIZE string of characters. The first two bytes  \  521 :
//  of the string is the initial Lfsr value. The Lfsr can't be 0. Starting with   \  522 :
//  the 3rd inbuf byte is the encrypted data.   \  523 :
// Parameters: inbuf - encrypted string padded with the Lfsr initial value padded  \  524 :
//  into the first two bytes.  \  525 :
// Output Paramters: outbfr - the decrypted string minus the two pad bytes.  \  526 :
// Return Values: The decrypted character  \  527 :
//------------------------------------------------------------------------------  \  528 :
void DecryptBlock(int8 *outbfr, int8 *inbfr)  \  529 :f1566V317V318
{  \  530 :{2729
    int8 size = BLOCK_SIZE;  \  531 :V1010
    int8 last = 0;  \  532 :V1011
    int8 cBit;  \  533 :V1012
  \  534 :
    gLfsr = *inbfr++ << 8;  \  535 :
    gLfsr |= *inbfr++;  \  536 :
    last = 0;  \  537 :
  \  538 :
//    while (size-- > 0)  \  539 :
//        *outbfr++ = Decrypt(*inbfr++);   \  540 :
   while (size-- > 0)  \  541 :
   {  \  542 :
       cBit = gLfsr & 1;  \  543 :{2734
       gLfsr >>= 1;  \  544 :
  \  545 :
       if (cBit)  \  546 :
          gLfsr ^= LFSR_MASK;  \  547 :
  \  548 :
       // Decrypt byte  \  549 :
       last ^= *inbfr++ ^ (unsigned char)gLfsr ^ (unsigned char)(gLfsr >> 8);  \  550 :
       *outbfr++ = last;  \  551 :
   }  \  552 :}2737
}  \  553 :}2738
  \  554 :
//------------------------------------------------------------------------------  \  555 :
// Function Name: TraceStr  \  556 :
// Description: Send string to the debug output UART.  \  557 :
// Parameters: pMsg - char array to send to port.   \  558 :
//  size - size of array  \  559 :
// Output Parameters:  \  560 :
// Return Values:  \  561 :
//------------------------------------------------------------------------------  \  562 :
#ifdef DEBUG  \  563 :
void TraceStr(int8* pMsg, int8 size)  \  564 :
{  \  565 :
    while(size--)  \  566 :
    {  \  567 :
        fputc(*pMsg++, STREAM_DEBUG);  \  568 :
        delay_ms(1);  \  569 :
    }  \  570 :
}  \  571 :
#endif  \  572 :
  \  573 :
//------------------------------------------------------------------------------  \  574 :
// Function Name: Trace  \  575 :
// Description: Send a byte to the debug output UART.  \  576 :
// Parameters: msg - char to send to port.   \  577 :
// Output Parameters:  \  578 :
// Return Values:  \  579 :
//------------------------------------------------------------------------------  \  580 :
#ifdef DEBUG  \  581 :
void Trace(int8 msg)  \  582 :
{  \  583 :
    fputc(msg, STREAM_DEBUG);  \  584 :
    delay_ms(1);  \  585 :
}  \  586 :
#endif  \  587 :
  \  588 :
  \  589 :
  \  590 :
  \  591 :
  \  592 :
  \  593 :
  \  594 :E
 \  594 :
  A   52 :
//------------------------------------------------------------------------------  A   53 :
// Function Name: main  A   54 :
// Description: C program main entry point.   A   55 :
// Parameters:   A   56 :
// Output Parameters:  A   57 :
// Return Values:   A   58 :
//------------------------------------------------------------------------------  A   59 :
void main()  A   60 :f2105
{  A   61 :{2740
	gFlags.adapterLocked = TRUE;  A   62 :
	gFlags.enableIso5msByteDelay = TRUE;  A   63 :
	gFlags.enableIsoChecksum = TRUE;  A   64 :
	  A   65 :
    init_ports();  A   66 :
  A   67 :
	CanDisable();  A   68 :
  A   69 :
    setup_timer_1 ( T1_INTERNAL | T1_DIV_BY_8 );  A   70 :
      A   71 :
    setup_adc_ports(RA0_ANALOG);  A   72 :
      A   73 :
	gDevid1 = read_program_eeprom(DEVID1_ADDR);  A   74 :
	gDevid2 = read_program_eeprom(DEVID2_ADDR);   A   75 :
	   A   76 :
	// on old 18F248 part use the CCS built-in functions to setup ADC  A   77 :
	if (gDevid2 == VER_18F248)  A   78 :
	{  A   79 :
		setup_adc(ADC_CLOCK_DIV_64);  A   80 :{2745
		set_adc_channel(0);  A   81 :
	}  A   82 :}2746
	// on new 18F2480 part must setup manually as the ADC registers have changed  A   83 :
	else  A   84 :
	{		  A   85 :
		ADCON2 = 0xAD;  A   86 :{2748
		ADCON0 = 0x01;  A   87 :
	}  A   88 :}2749
    	  A   89 :
	enable_interrupts(GLOBAL);  A   90 :
    enable_interrupts(INT_RDA);  A   91 :
	enable_interrupts(INT_CANERR);  A   92 :
	enable_interrupts(INT_CANRX1);  A   93 :
	enable_interrupts(INT_CANRX0);  A   94 :
	enable_interrupts(INT_CANIRX);  A   95 :
  A   96 :
   	//output_low(PIN_B4);  A   97 :
   	//output_high(PIN_B4);  A   98 :
	//TRACE("A"); // send byte to get debug port initialized  A   99 :
	  A  100 :
#ifdef BLUETOOTH  A  101 :
	HostInitBluetooth();  A  102 :
#endif  A  103 :
  A  104 :
    // forever loop  A  105 :
    while(1)  A  106 :
    {  A  107 :
		// if a complete host message arrived  A  108 :
        if (gHostBufCnt >= HOST_RECV_MSG_SIZE)  A  109 :{2752
        {  A  110 :
            // ensure serial interrupts don't disturb accurate VPW and PWM timing loops  A  111 :
            disable_interrupts(INT_RDA);  A  112 :{2755
					     A  113 :
			// incase an ISR set an error while adatper was idle, let's clear it  A  114 :
			gError = 0;  A  115 :
  A  116 :
            // if the incoming message parses successfully  A  117 :
            HostParseMsg();  A  118 :
			  A  119 :
            // send the host's query message to the vehicle  A  120 :
            if (!gError)  A  121 :
		    {  A  122 :
            	gCurrentCmd = gHostBuf[IDX_HOST_COMMAND];  A  123 :{2759
                VehSendRecv();  A  124 :
			}  A  125 :}2760
                  A  126 :
            // if error generated, send host error message  A  127 :
            if (gError)  A  128 :
                HostSendError();  A  129 :
  A  130 :
			// else if vehicle data to send, send host vehicle data message  A  131 :
            else if (!IsCmdLocal(gCurrentCmd))  A  132 :
               HostSendVehicleData();  A  133 :
  A  134 :
			// else local data to send, send host local data message  A  135 :
			else  A  136 :
				HostSendLocalData();  A  137 :
  A  138 :
            gHostBufCnt = 0;  A  139 :
          	gLastCmd = gCurrentCmd;  A  140 :
              A  141 :
            // zero all vehicle buffer bytes for next time  A  142 :
            //memset(gVehicleBuf, 0x00, VEHICLE_MAX_MSGS * VEHICLE_MSG_SIZE);  A  143 :
            enable_interrupts(INT_RDA);  A  144 :
        }  A  145 :}2767
  A  146 :
        // if more than 25mS between chars, reset buf count. Could happen if  A  147 :
        // an incomplete host message is received or host is slow  A  148 :
        disable_interrupts(INT_RDA);  A  149 :
        if (HstTestTimer(gHostRecvTimeout, HST_TWENTY_FIVE_MS))  A  150 :
            gHostBufCnt = 0;  A  151 :
        enable_interrupts(INT_RDA);  A  152 :
    }   A  153 :}2771
}  A  154 :}2772E
 A  154 :
